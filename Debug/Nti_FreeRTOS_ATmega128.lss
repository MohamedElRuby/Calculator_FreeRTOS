
Nti_FreeRTOS_ATmega128.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000072  00800100  00009b7c  00009c10  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00009b7c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006f5  00800172  00800172  00009c82  2**0
                  ALLOC
  3 .stab         0000c114  00000000  00000000  00009c84  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006d90  00000000  00000000  00015d98  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0001cb28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0001cc68  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0001cdd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0001ea21  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001f90c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000206bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028e  00000000  00000000  0002081c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00020aaa  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00021278  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 30 0b 	jmp	0x1660	; 0x1660 <__vector_6>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 e7 0b 	jmp	0x17ce	; 0x17ce <__vector_11>
      30:	0c 94 e1 1b 	jmp	0x37c2	; 0x37c2 <__vector_12>
      34:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ec e7       	ldi	r30, 0x7C	; 124
      a0:	fb e9       	ldi	r31, 0x9B	; 155
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a2 37       	cpi	r26, 0x72	; 114
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	18 e0       	ldi	r17, 0x08	; 8
      b4:	a2 e7       	ldi	r26, 0x72	; 114
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a7 36       	cpi	r26, 0x67	; 103
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 75 4c 	call	0x98ea	; 0x98ea <main>
      c6:	0c 94 bc 4d 	jmp	0x9b78	; 0x9b78 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <__fixunssfsi>:
      ce:	ef 92       	push	r14
      d0:	ff 92       	push	r15
      d2:	0f 93       	push	r16
      d4:	1f 93       	push	r17
      d6:	7b 01       	movw	r14, r22
      d8:	8c 01       	movw	r16, r24
      da:	20 e0       	ldi	r18, 0x00	; 0
      dc:	30 e0       	ldi	r19, 0x00	; 0
      de:	40 e0       	ldi	r20, 0x00	; 0
      e0:	5f e4       	ldi	r21, 0x4F	; 79
      e2:	0e 94 67 03 	call	0x6ce	; 0x6ce <__gesf2>
      e6:	88 23       	and	r24, r24
      e8:	8c f0       	brlt	.+34     	; 0x10c <__fixunssfsi+0x3e>
      ea:	c8 01       	movw	r24, r16
      ec:	b7 01       	movw	r22, r14
      ee:	20 e0       	ldi	r18, 0x00	; 0
      f0:	30 e0       	ldi	r19, 0x00	; 0
      f2:	40 e0       	ldi	r20, 0x00	; 0
      f4:	5f e4       	ldi	r21, 0x4F	; 79
      f6:	0e 94 df 01 	call	0x3be	; 0x3be <__subsf3>
      fa:	0e 94 c7 03 	call	0x78e	; 0x78e <__fixsfsi>
      fe:	9b 01       	movw	r18, r22
     100:	ac 01       	movw	r20, r24
     102:	20 50       	subi	r18, 0x00	; 0
     104:	30 40       	sbci	r19, 0x00	; 0
     106:	40 40       	sbci	r20, 0x00	; 0
     108:	50 48       	sbci	r21, 0x80	; 128
     10a:	06 c0       	rjmp	.+12     	; 0x118 <__fixunssfsi+0x4a>
     10c:	c8 01       	movw	r24, r16
     10e:	b7 01       	movw	r22, r14
     110:	0e 94 c7 03 	call	0x78e	; 0x78e <__fixsfsi>
     114:	9b 01       	movw	r18, r22
     116:	ac 01       	movw	r20, r24
     118:	b9 01       	movw	r22, r18
     11a:	ca 01       	movw	r24, r20
     11c:	1f 91       	pop	r17
     11e:	0f 91       	pop	r16
     120:	ff 90       	pop	r15
     122:	ef 90       	pop	r14
     124:	08 95       	ret

00000126 <_fpadd_parts>:
     126:	a0 e0       	ldi	r26, 0x00	; 0
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	e9 e9       	ldi	r30, 0x99	; 153
     12c:	f0 e0       	ldi	r31, 0x00	; 0
     12e:	0c 94 4f 4d 	jmp	0x9a9e	; 0x9a9e <__prologue_saves__>
     132:	dc 01       	movw	r26, r24
     134:	2b 01       	movw	r4, r22
     136:	fa 01       	movw	r30, r20
     138:	9c 91       	ld	r25, X
     13a:	92 30       	cpi	r25, 0x02	; 2
     13c:	08 f4       	brcc	.+2      	; 0x140 <_fpadd_parts+0x1a>
     13e:	39 c1       	rjmp	.+626    	; 0x3b2 <_fpadd_parts+0x28c>
     140:	eb 01       	movw	r28, r22
     142:	88 81       	ld	r24, Y
     144:	82 30       	cpi	r24, 0x02	; 2
     146:	08 f4       	brcc	.+2      	; 0x14a <_fpadd_parts+0x24>
     148:	33 c1       	rjmp	.+614    	; 0x3b0 <_fpadd_parts+0x28a>
     14a:	94 30       	cpi	r25, 0x04	; 4
     14c:	69 f4       	brne	.+26     	; 0x168 <_fpadd_parts+0x42>
     14e:	84 30       	cpi	r24, 0x04	; 4
     150:	09 f0       	breq	.+2      	; 0x154 <_fpadd_parts+0x2e>
     152:	2f c1       	rjmp	.+606    	; 0x3b2 <_fpadd_parts+0x28c>
     154:	11 96       	adiw	r26, 0x01	; 1
     156:	9c 91       	ld	r25, X
     158:	11 97       	sbiw	r26, 0x01	; 1
     15a:	89 81       	ldd	r24, Y+1	; 0x01
     15c:	98 17       	cp	r25, r24
     15e:	09 f4       	brne	.+2      	; 0x162 <_fpadd_parts+0x3c>
     160:	28 c1       	rjmp	.+592    	; 0x3b2 <_fpadd_parts+0x28c>
     162:	a6 e5       	ldi	r26, 0x56	; 86
     164:	b1 e0       	ldi	r27, 0x01	; 1
     166:	25 c1       	rjmp	.+586    	; 0x3b2 <_fpadd_parts+0x28c>
     168:	84 30       	cpi	r24, 0x04	; 4
     16a:	09 f4       	brne	.+2      	; 0x16e <_fpadd_parts+0x48>
     16c:	21 c1       	rjmp	.+578    	; 0x3b0 <_fpadd_parts+0x28a>
     16e:	82 30       	cpi	r24, 0x02	; 2
     170:	a9 f4       	brne	.+42     	; 0x19c <_fpadd_parts+0x76>
     172:	92 30       	cpi	r25, 0x02	; 2
     174:	09 f0       	breq	.+2      	; 0x178 <_fpadd_parts+0x52>
     176:	1d c1       	rjmp	.+570    	; 0x3b2 <_fpadd_parts+0x28c>
     178:	9a 01       	movw	r18, r20
     17a:	ad 01       	movw	r20, r26
     17c:	88 e0       	ldi	r24, 0x08	; 8
     17e:	ea 01       	movw	r28, r20
     180:	09 90       	ld	r0, Y+
     182:	ae 01       	movw	r20, r28
     184:	e9 01       	movw	r28, r18
     186:	09 92       	st	Y+, r0
     188:	9e 01       	movw	r18, r28
     18a:	81 50       	subi	r24, 0x01	; 1
     18c:	c1 f7       	brne	.-16     	; 0x17e <_fpadd_parts+0x58>
     18e:	e2 01       	movw	r28, r4
     190:	89 81       	ldd	r24, Y+1	; 0x01
     192:	11 96       	adiw	r26, 0x01	; 1
     194:	9c 91       	ld	r25, X
     196:	89 23       	and	r24, r25
     198:	81 83       	std	Z+1, r24	; 0x01
     19a:	08 c1       	rjmp	.+528    	; 0x3ac <_fpadd_parts+0x286>
     19c:	92 30       	cpi	r25, 0x02	; 2
     19e:	09 f4       	brne	.+2      	; 0x1a2 <_fpadd_parts+0x7c>
     1a0:	07 c1       	rjmp	.+526    	; 0x3b0 <_fpadd_parts+0x28a>
     1a2:	12 96       	adiw	r26, 0x02	; 2
     1a4:	2d 90       	ld	r2, X+
     1a6:	3c 90       	ld	r3, X
     1a8:	13 97       	sbiw	r26, 0x03	; 3
     1aa:	eb 01       	movw	r28, r22
     1ac:	8a 81       	ldd	r24, Y+2	; 0x02
     1ae:	9b 81       	ldd	r25, Y+3	; 0x03
     1b0:	14 96       	adiw	r26, 0x04	; 4
     1b2:	ad 90       	ld	r10, X+
     1b4:	bd 90       	ld	r11, X+
     1b6:	cd 90       	ld	r12, X+
     1b8:	dc 90       	ld	r13, X
     1ba:	17 97       	sbiw	r26, 0x07	; 7
     1bc:	ec 80       	ldd	r14, Y+4	; 0x04
     1be:	fd 80       	ldd	r15, Y+5	; 0x05
     1c0:	0e 81       	ldd	r16, Y+6	; 0x06
     1c2:	1f 81       	ldd	r17, Y+7	; 0x07
     1c4:	91 01       	movw	r18, r2
     1c6:	28 1b       	sub	r18, r24
     1c8:	39 0b       	sbc	r19, r25
     1ca:	b9 01       	movw	r22, r18
     1cc:	37 ff       	sbrs	r19, 7
     1ce:	04 c0       	rjmp	.+8      	; 0x1d8 <_fpadd_parts+0xb2>
     1d0:	66 27       	eor	r22, r22
     1d2:	77 27       	eor	r23, r23
     1d4:	62 1b       	sub	r22, r18
     1d6:	73 0b       	sbc	r23, r19
     1d8:	60 32       	cpi	r22, 0x20	; 32
     1da:	71 05       	cpc	r23, r1
     1dc:	0c f0       	brlt	.+2      	; 0x1e0 <_fpadd_parts+0xba>
     1de:	61 c0       	rjmp	.+194    	; 0x2a2 <_fpadd_parts+0x17c>
     1e0:	12 16       	cp	r1, r18
     1e2:	13 06       	cpc	r1, r19
     1e4:	6c f5       	brge	.+90     	; 0x240 <_fpadd_parts+0x11a>
     1e6:	37 01       	movw	r6, r14
     1e8:	48 01       	movw	r8, r16
     1ea:	06 2e       	mov	r0, r22
     1ec:	04 c0       	rjmp	.+8      	; 0x1f6 <_fpadd_parts+0xd0>
     1ee:	96 94       	lsr	r9
     1f0:	87 94       	ror	r8
     1f2:	77 94       	ror	r7
     1f4:	67 94       	ror	r6
     1f6:	0a 94       	dec	r0
     1f8:	d2 f7       	brpl	.-12     	; 0x1ee <_fpadd_parts+0xc8>
     1fa:	21 e0       	ldi	r18, 0x01	; 1
     1fc:	30 e0       	ldi	r19, 0x00	; 0
     1fe:	40 e0       	ldi	r20, 0x00	; 0
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	04 c0       	rjmp	.+8      	; 0x20c <_fpadd_parts+0xe6>
     204:	22 0f       	add	r18, r18
     206:	33 1f       	adc	r19, r19
     208:	44 1f       	adc	r20, r20
     20a:	55 1f       	adc	r21, r21
     20c:	6a 95       	dec	r22
     20e:	d2 f7       	brpl	.-12     	; 0x204 <_fpadd_parts+0xde>
     210:	21 50       	subi	r18, 0x01	; 1
     212:	30 40       	sbci	r19, 0x00	; 0
     214:	40 40       	sbci	r20, 0x00	; 0
     216:	50 40       	sbci	r21, 0x00	; 0
     218:	2e 21       	and	r18, r14
     21a:	3f 21       	and	r19, r15
     21c:	40 23       	and	r20, r16
     21e:	51 23       	and	r21, r17
     220:	21 15       	cp	r18, r1
     222:	31 05       	cpc	r19, r1
     224:	41 05       	cpc	r20, r1
     226:	51 05       	cpc	r21, r1
     228:	21 f0       	breq	.+8      	; 0x232 <_fpadd_parts+0x10c>
     22a:	21 e0       	ldi	r18, 0x01	; 1
     22c:	30 e0       	ldi	r19, 0x00	; 0
     22e:	40 e0       	ldi	r20, 0x00	; 0
     230:	50 e0       	ldi	r21, 0x00	; 0
     232:	79 01       	movw	r14, r18
     234:	8a 01       	movw	r16, r20
     236:	e6 28       	or	r14, r6
     238:	f7 28       	or	r15, r7
     23a:	08 29       	or	r16, r8
     23c:	19 29       	or	r17, r9
     23e:	3c c0       	rjmp	.+120    	; 0x2b8 <_fpadd_parts+0x192>
     240:	23 2b       	or	r18, r19
     242:	d1 f1       	breq	.+116    	; 0x2b8 <_fpadd_parts+0x192>
     244:	26 0e       	add	r2, r22
     246:	37 1e       	adc	r3, r23
     248:	35 01       	movw	r6, r10
     24a:	46 01       	movw	r8, r12
     24c:	06 2e       	mov	r0, r22
     24e:	04 c0       	rjmp	.+8      	; 0x258 <_fpadd_parts+0x132>
     250:	96 94       	lsr	r9
     252:	87 94       	ror	r8
     254:	77 94       	ror	r7
     256:	67 94       	ror	r6
     258:	0a 94       	dec	r0
     25a:	d2 f7       	brpl	.-12     	; 0x250 <_fpadd_parts+0x12a>
     25c:	21 e0       	ldi	r18, 0x01	; 1
     25e:	30 e0       	ldi	r19, 0x00	; 0
     260:	40 e0       	ldi	r20, 0x00	; 0
     262:	50 e0       	ldi	r21, 0x00	; 0
     264:	04 c0       	rjmp	.+8      	; 0x26e <_fpadd_parts+0x148>
     266:	22 0f       	add	r18, r18
     268:	33 1f       	adc	r19, r19
     26a:	44 1f       	adc	r20, r20
     26c:	55 1f       	adc	r21, r21
     26e:	6a 95       	dec	r22
     270:	d2 f7       	brpl	.-12     	; 0x266 <_fpadd_parts+0x140>
     272:	21 50       	subi	r18, 0x01	; 1
     274:	30 40       	sbci	r19, 0x00	; 0
     276:	40 40       	sbci	r20, 0x00	; 0
     278:	50 40       	sbci	r21, 0x00	; 0
     27a:	2a 21       	and	r18, r10
     27c:	3b 21       	and	r19, r11
     27e:	4c 21       	and	r20, r12
     280:	5d 21       	and	r21, r13
     282:	21 15       	cp	r18, r1
     284:	31 05       	cpc	r19, r1
     286:	41 05       	cpc	r20, r1
     288:	51 05       	cpc	r21, r1
     28a:	21 f0       	breq	.+8      	; 0x294 <_fpadd_parts+0x16e>
     28c:	21 e0       	ldi	r18, 0x01	; 1
     28e:	30 e0       	ldi	r19, 0x00	; 0
     290:	40 e0       	ldi	r20, 0x00	; 0
     292:	50 e0       	ldi	r21, 0x00	; 0
     294:	59 01       	movw	r10, r18
     296:	6a 01       	movw	r12, r20
     298:	a6 28       	or	r10, r6
     29a:	b7 28       	or	r11, r7
     29c:	c8 28       	or	r12, r8
     29e:	d9 28       	or	r13, r9
     2a0:	0b c0       	rjmp	.+22     	; 0x2b8 <_fpadd_parts+0x192>
     2a2:	82 15       	cp	r24, r2
     2a4:	93 05       	cpc	r25, r3
     2a6:	2c f0       	brlt	.+10     	; 0x2b2 <_fpadd_parts+0x18c>
     2a8:	1c 01       	movw	r2, r24
     2aa:	aa 24       	eor	r10, r10
     2ac:	bb 24       	eor	r11, r11
     2ae:	65 01       	movw	r12, r10
     2b0:	03 c0       	rjmp	.+6      	; 0x2b8 <_fpadd_parts+0x192>
     2b2:	ee 24       	eor	r14, r14
     2b4:	ff 24       	eor	r15, r15
     2b6:	87 01       	movw	r16, r14
     2b8:	11 96       	adiw	r26, 0x01	; 1
     2ba:	9c 91       	ld	r25, X
     2bc:	d2 01       	movw	r26, r4
     2be:	11 96       	adiw	r26, 0x01	; 1
     2c0:	8c 91       	ld	r24, X
     2c2:	98 17       	cp	r25, r24
     2c4:	09 f4       	brne	.+2      	; 0x2c8 <_fpadd_parts+0x1a2>
     2c6:	45 c0       	rjmp	.+138    	; 0x352 <_fpadd_parts+0x22c>
     2c8:	99 23       	and	r25, r25
     2ca:	39 f0       	breq	.+14     	; 0x2da <_fpadd_parts+0x1b4>
     2cc:	a8 01       	movw	r20, r16
     2ce:	97 01       	movw	r18, r14
     2d0:	2a 19       	sub	r18, r10
     2d2:	3b 09       	sbc	r19, r11
     2d4:	4c 09       	sbc	r20, r12
     2d6:	5d 09       	sbc	r21, r13
     2d8:	06 c0       	rjmp	.+12     	; 0x2e6 <_fpadd_parts+0x1c0>
     2da:	a6 01       	movw	r20, r12
     2dc:	95 01       	movw	r18, r10
     2de:	2e 19       	sub	r18, r14
     2e0:	3f 09       	sbc	r19, r15
     2e2:	40 0b       	sbc	r20, r16
     2e4:	51 0b       	sbc	r21, r17
     2e6:	57 fd       	sbrc	r21, 7
     2e8:	08 c0       	rjmp	.+16     	; 0x2fa <_fpadd_parts+0x1d4>
     2ea:	11 82       	std	Z+1, r1	; 0x01
     2ec:	33 82       	std	Z+3, r3	; 0x03
     2ee:	22 82       	std	Z+2, r2	; 0x02
     2f0:	24 83       	std	Z+4, r18	; 0x04
     2f2:	35 83       	std	Z+5, r19	; 0x05
     2f4:	46 83       	std	Z+6, r20	; 0x06
     2f6:	57 83       	std	Z+7, r21	; 0x07
     2f8:	1d c0       	rjmp	.+58     	; 0x334 <_fpadd_parts+0x20e>
     2fa:	81 e0       	ldi	r24, 0x01	; 1
     2fc:	81 83       	std	Z+1, r24	; 0x01
     2fe:	33 82       	std	Z+3, r3	; 0x03
     300:	22 82       	std	Z+2, r2	; 0x02
     302:	88 27       	eor	r24, r24
     304:	99 27       	eor	r25, r25
     306:	dc 01       	movw	r26, r24
     308:	82 1b       	sub	r24, r18
     30a:	93 0b       	sbc	r25, r19
     30c:	a4 0b       	sbc	r26, r20
     30e:	b5 0b       	sbc	r27, r21
     310:	84 83       	std	Z+4, r24	; 0x04
     312:	95 83       	std	Z+5, r25	; 0x05
     314:	a6 83       	std	Z+6, r26	; 0x06
     316:	b7 83       	std	Z+7, r27	; 0x07
     318:	0d c0       	rjmp	.+26     	; 0x334 <_fpadd_parts+0x20e>
     31a:	22 0f       	add	r18, r18
     31c:	33 1f       	adc	r19, r19
     31e:	44 1f       	adc	r20, r20
     320:	55 1f       	adc	r21, r21
     322:	24 83       	std	Z+4, r18	; 0x04
     324:	35 83       	std	Z+5, r19	; 0x05
     326:	46 83       	std	Z+6, r20	; 0x06
     328:	57 83       	std	Z+7, r21	; 0x07
     32a:	82 81       	ldd	r24, Z+2	; 0x02
     32c:	93 81       	ldd	r25, Z+3	; 0x03
     32e:	01 97       	sbiw	r24, 0x01	; 1
     330:	93 83       	std	Z+3, r25	; 0x03
     332:	82 83       	std	Z+2, r24	; 0x02
     334:	24 81       	ldd	r18, Z+4	; 0x04
     336:	35 81       	ldd	r19, Z+5	; 0x05
     338:	46 81       	ldd	r20, Z+6	; 0x06
     33a:	57 81       	ldd	r21, Z+7	; 0x07
     33c:	da 01       	movw	r26, r20
     33e:	c9 01       	movw	r24, r18
     340:	01 97       	sbiw	r24, 0x01	; 1
     342:	a1 09       	sbc	r26, r1
     344:	b1 09       	sbc	r27, r1
     346:	8f 5f       	subi	r24, 0xFF	; 255
     348:	9f 4f       	sbci	r25, 0xFF	; 255
     34a:	af 4f       	sbci	r26, 0xFF	; 255
     34c:	bf 43       	sbci	r27, 0x3F	; 63
     34e:	28 f3       	brcs	.-54     	; 0x31a <_fpadd_parts+0x1f4>
     350:	0b c0       	rjmp	.+22     	; 0x368 <_fpadd_parts+0x242>
     352:	91 83       	std	Z+1, r25	; 0x01
     354:	33 82       	std	Z+3, r3	; 0x03
     356:	22 82       	std	Z+2, r2	; 0x02
     358:	ea 0c       	add	r14, r10
     35a:	fb 1c       	adc	r15, r11
     35c:	0c 1d       	adc	r16, r12
     35e:	1d 1d       	adc	r17, r13
     360:	e4 82       	std	Z+4, r14	; 0x04
     362:	f5 82       	std	Z+5, r15	; 0x05
     364:	06 83       	std	Z+6, r16	; 0x06
     366:	17 83       	std	Z+7, r17	; 0x07
     368:	83 e0       	ldi	r24, 0x03	; 3
     36a:	80 83       	st	Z, r24
     36c:	24 81       	ldd	r18, Z+4	; 0x04
     36e:	35 81       	ldd	r19, Z+5	; 0x05
     370:	46 81       	ldd	r20, Z+6	; 0x06
     372:	57 81       	ldd	r21, Z+7	; 0x07
     374:	57 ff       	sbrs	r21, 7
     376:	1a c0       	rjmp	.+52     	; 0x3ac <_fpadd_parts+0x286>
     378:	c9 01       	movw	r24, r18
     37a:	aa 27       	eor	r26, r26
     37c:	97 fd       	sbrc	r25, 7
     37e:	a0 95       	com	r26
     380:	ba 2f       	mov	r27, r26
     382:	81 70       	andi	r24, 0x01	; 1
     384:	90 70       	andi	r25, 0x00	; 0
     386:	a0 70       	andi	r26, 0x00	; 0
     388:	b0 70       	andi	r27, 0x00	; 0
     38a:	56 95       	lsr	r21
     38c:	47 95       	ror	r20
     38e:	37 95       	ror	r19
     390:	27 95       	ror	r18
     392:	82 2b       	or	r24, r18
     394:	93 2b       	or	r25, r19
     396:	a4 2b       	or	r26, r20
     398:	b5 2b       	or	r27, r21
     39a:	84 83       	std	Z+4, r24	; 0x04
     39c:	95 83       	std	Z+5, r25	; 0x05
     39e:	a6 83       	std	Z+6, r26	; 0x06
     3a0:	b7 83       	std	Z+7, r27	; 0x07
     3a2:	82 81       	ldd	r24, Z+2	; 0x02
     3a4:	93 81       	ldd	r25, Z+3	; 0x03
     3a6:	01 96       	adiw	r24, 0x01	; 1
     3a8:	93 83       	std	Z+3, r25	; 0x03
     3aa:	82 83       	std	Z+2, r24	; 0x02
     3ac:	df 01       	movw	r26, r30
     3ae:	01 c0       	rjmp	.+2      	; 0x3b2 <_fpadd_parts+0x28c>
     3b0:	d2 01       	movw	r26, r4
     3b2:	cd 01       	movw	r24, r26
     3b4:	cd b7       	in	r28, 0x3d	; 61
     3b6:	de b7       	in	r29, 0x3e	; 62
     3b8:	e2 e1       	ldi	r30, 0x12	; 18
     3ba:	0c 94 6b 4d 	jmp	0x9ad6	; 0x9ad6 <__epilogue_restores__>

000003be <__subsf3>:
     3be:	a0 e2       	ldi	r26, 0x20	; 32
     3c0:	b0 e0       	ldi	r27, 0x00	; 0
     3c2:	e5 ee       	ldi	r30, 0xE5	; 229
     3c4:	f1 e0       	ldi	r31, 0x01	; 1
     3c6:	0c 94 5b 4d 	jmp	0x9ab6	; 0x9ab6 <__prologue_saves__+0x18>
     3ca:	69 83       	std	Y+1, r22	; 0x01
     3cc:	7a 83       	std	Y+2, r23	; 0x02
     3ce:	8b 83       	std	Y+3, r24	; 0x03
     3d0:	9c 83       	std	Y+4, r25	; 0x04
     3d2:	2d 83       	std	Y+5, r18	; 0x05
     3d4:	3e 83       	std	Y+6, r19	; 0x06
     3d6:	4f 83       	std	Y+7, r20	; 0x07
     3d8:	58 87       	std	Y+8, r21	; 0x08
     3da:	e9 e0       	ldi	r30, 0x09	; 9
     3dc:	ee 2e       	mov	r14, r30
     3de:	f1 2c       	mov	r15, r1
     3e0:	ec 0e       	add	r14, r28
     3e2:	fd 1e       	adc	r15, r29
     3e4:	ce 01       	movw	r24, r28
     3e6:	01 96       	adiw	r24, 0x01	; 1
     3e8:	b7 01       	movw	r22, r14
     3ea:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     3ee:	8e 01       	movw	r16, r28
     3f0:	0f 5e       	subi	r16, 0xEF	; 239
     3f2:	1f 4f       	sbci	r17, 0xFF	; 255
     3f4:	ce 01       	movw	r24, r28
     3f6:	05 96       	adiw	r24, 0x05	; 5
     3f8:	b8 01       	movw	r22, r16
     3fa:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     3fe:	8a 89       	ldd	r24, Y+18	; 0x12
     400:	91 e0       	ldi	r25, 0x01	; 1
     402:	89 27       	eor	r24, r25
     404:	8a 8b       	std	Y+18, r24	; 0x12
     406:	c7 01       	movw	r24, r14
     408:	b8 01       	movw	r22, r16
     40a:	ae 01       	movw	r20, r28
     40c:	47 5e       	subi	r20, 0xE7	; 231
     40e:	5f 4f       	sbci	r21, 0xFF	; 255
     410:	0e 94 93 00 	call	0x126	; 0x126 <_fpadd_parts>
     414:	0e 94 1b 04 	call	0x836	; 0x836 <__pack_f>
     418:	a0 96       	adiw	r28, 0x20	; 32
     41a:	e6 e0       	ldi	r30, 0x06	; 6
     41c:	0c 94 77 4d 	jmp	0x9aee	; 0x9aee <__epilogue_restores__+0x18>

00000420 <__addsf3>:
     420:	a0 e2       	ldi	r26, 0x20	; 32
     422:	b0 e0       	ldi	r27, 0x00	; 0
     424:	e6 e1       	ldi	r30, 0x16	; 22
     426:	f2 e0       	ldi	r31, 0x02	; 2
     428:	0c 94 5b 4d 	jmp	0x9ab6	; 0x9ab6 <__prologue_saves__+0x18>
     42c:	69 83       	std	Y+1, r22	; 0x01
     42e:	7a 83       	std	Y+2, r23	; 0x02
     430:	8b 83       	std	Y+3, r24	; 0x03
     432:	9c 83       	std	Y+4, r25	; 0x04
     434:	2d 83       	std	Y+5, r18	; 0x05
     436:	3e 83       	std	Y+6, r19	; 0x06
     438:	4f 83       	std	Y+7, r20	; 0x07
     43a:	58 87       	std	Y+8, r21	; 0x08
     43c:	f9 e0       	ldi	r31, 0x09	; 9
     43e:	ef 2e       	mov	r14, r31
     440:	f1 2c       	mov	r15, r1
     442:	ec 0e       	add	r14, r28
     444:	fd 1e       	adc	r15, r29
     446:	ce 01       	movw	r24, r28
     448:	01 96       	adiw	r24, 0x01	; 1
     44a:	b7 01       	movw	r22, r14
     44c:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     450:	8e 01       	movw	r16, r28
     452:	0f 5e       	subi	r16, 0xEF	; 239
     454:	1f 4f       	sbci	r17, 0xFF	; 255
     456:	ce 01       	movw	r24, r28
     458:	05 96       	adiw	r24, 0x05	; 5
     45a:	b8 01       	movw	r22, r16
     45c:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     460:	c7 01       	movw	r24, r14
     462:	b8 01       	movw	r22, r16
     464:	ae 01       	movw	r20, r28
     466:	47 5e       	subi	r20, 0xE7	; 231
     468:	5f 4f       	sbci	r21, 0xFF	; 255
     46a:	0e 94 93 00 	call	0x126	; 0x126 <_fpadd_parts>
     46e:	0e 94 1b 04 	call	0x836	; 0x836 <__pack_f>
     472:	a0 96       	adiw	r28, 0x20	; 32
     474:	e6 e0       	ldi	r30, 0x06	; 6
     476:	0c 94 77 4d 	jmp	0x9aee	; 0x9aee <__epilogue_restores__+0x18>

0000047a <__mulsf3>:
     47a:	a0 e2       	ldi	r26, 0x20	; 32
     47c:	b0 e0       	ldi	r27, 0x00	; 0
     47e:	e3 e4       	ldi	r30, 0x43	; 67
     480:	f2 e0       	ldi	r31, 0x02	; 2
     482:	0c 94 4f 4d 	jmp	0x9a9e	; 0x9a9e <__prologue_saves__>
     486:	69 83       	std	Y+1, r22	; 0x01
     488:	7a 83       	std	Y+2, r23	; 0x02
     48a:	8b 83       	std	Y+3, r24	; 0x03
     48c:	9c 83       	std	Y+4, r25	; 0x04
     48e:	2d 83       	std	Y+5, r18	; 0x05
     490:	3e 83       	std	Y+6, r19	; 0x06
     492:	4f 83       	std	Y+7, r20	; 0x07
     494:	58 87       	std	Y+8, r21	; 0x08
     496:	ce 01       	movw	r24, r28
     498:	01 96       	adiw	r24, 0x01	; 1
     49a:	be 01       	movw	r22, r28
     49c:	67 5f       	subi	r22, 0xF7	; 247
     49e:	7f 4f       	sbci	r23, 0xFF	; 255
     4a0:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     4a4:	ce 01       	movw	r24, r28
     4a6:	05 96       	adiw	r24, 0x05	; 5
     4a8:	be 01       	movw	r22, r28
     4aa:	6f 5e       	subi	r22, 0xEF	; 239
     4ac:	7f 4f       	sbci	r23, 0xFF	; 255
     4ae:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     4b2:	99 85       	ldd	r25, Y+9	; 0x09
     4b4:	92 30       	cpi	r25, 0x02	; 2
     4b6:	88 f0       	brcs	.+34     	; 0x4da <__mulsf3+0x60>
     4b8:	89 89       	ldd	r24, Y+17	; 0x11
     4ba:	82 30       	cpi	r24, 0x02	; 2
     4bc:	c8 f0       	brcs	.+50     	; 0x4f0 <__mulsf3+0x76>
     4be:	94 30       	cpi	r25, 0x04	; 4
     4c0:	19 f4       	brne	.+6      	; 0x4c8 <__mulsf3+0x4e>
     4c2:	82 30       	cpi	r24, 0x02	; 2
     4c4:	51 f4       	brne	.+20     	; 0x4da <__mulsf3+0x60>
     4c6:	04 c0       	rjmp	.+8      	; 0x4d0 <__mulsf3+0x56>
     4c8:	84 30       	cpi	r24, 0x04	; 4
     4ca:	29 f4       	brne	.+10     	; 0x4d6 <__mulsf3+0x5c>
     4cc:	92 30       	cpi	r25, 0x02	; 2
     4ce:	81 f4       	brne	.+32     	; 0x4f0 <__mulsf3+0x76>
     4d0:	86 e5       	ldi	r24, 0x56	; 86
     4d2:	91 e0       	ldi	r25, 0x01	; 1
     4d4:	c6 c0       	rjmp	.+396    	; 0x662 <__mulsf3+0x1e8>
     4d6:	92 30       	cpi	r25, 0x02	; 2
     4d8:	49 f4       	brne	.+18     	; 0x4ec <__mulsf3+0x72>
     4da:	20 e0       	ldi	r18, 0x00	; 0
     4dc:	9a 85       	ldd	r25, Y+10	; 0x0a
     4de:	8a 89       	ldd	r24, Y+18	; 0x12
     4e0:	98 13       	cpse	r25, r24
     4e2:	21 e0       	ldi	r18, 0x01	; 1
     4e4:	2a 87       	std	Y+10, r18	; 0x0a
     4e6:	ce 01       	movw	r24, r28
     4e8:	09 96       	adiw	r24, 0x09	; 9
     4ea:	bb c0       	rjmp	.+374    	; 0x662 <__mulsf3+0x1e8>
     4ec:	82 30       	cpi	r24, 0x02	; 2
     4ee:	49 f4       	brne	.+18     	; 0x502 <__mulsf3+0x88>
     4f0:	20 e0       	ldi	r18, 0x00	; 0
     4f2:	9a 85       	ldd	r25, Y+10	; 0x0a
     4f4:	8a 89       	ldd	r24, Y+18	; 0x12
     4f6:	98 13       	cpse	r25, r24
     4f8:	21 e0       	ldi	r18, 0x01	; 1
     4fa:	2a 8b       	std	Y+18, r18	; 0x12
     4fc:	ce 01       	movw	r24, r28
     4fe:	41 96       	adiw	r24, 0x11	; 17
     500:	b0 c0       	rjmp	.+352    	; 0x662 <__mulsf3+0x1e8>
     502:	2d 84       	ldd	r2, Y+13	; 0x0d
     504:	3e 84       	ldd	r3, Y+14	; 0x0e
     506:	4f 84       	ldd	r4, Y+15	; 0x0f
     508:	58 88       	ldd	r5, Y+16	; 0x10
     50a:	6d 88       	ldd	r6, Y+21	; 0x15
     50c:	7e 88       	ldd	r7, Y+22	; 0x16
     50e:	8f 88       	ldd	r8, Y+23	; 0x17
     510:	98 8c       	ldd	r9, Y+24	; 0x18
     512:	ee 24       	eor	r14, r14
     514:	ff 24       	eor	r15, r15
     516:	87 01       	movw	r16, r14
     518:	aa 24       	eor	r10, r10
     51a:	bb 24       	eor	r11, r11
     51c:	65 01       	movw	r12, r10
     51e:	40 e0       	ldi	r20, 0x00	; 0
     520:	50 e0       	ldi	r21, 0x00	; 0
     522:	60 e0       	ldi	r22, 0x00	; 0
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	e0 e0       	ldi	r30, 0x00	; 0
     528:	f0 e0       	ldi	r31, 0x00	; 0
     52a:	c1 01       	movw	r24, r2
     52c:	81 70       	andi	r24, 0x01	; 1
     52e:	90 70       	andi	r25, 0x00	; 0
     530:	89 2b       	or	r24, r25
     532:	e9 f0       	breq	.+58     	; 0x56e <__mulsf3+0xf4>
     534:	e6 0c       	add	r14, r6
     536:	f7 1c       	adc	r15, r7
     538:	08 1d       	adc	r16, r8
     53a:	19 1d       	adc	r17, r9
     53c:	9a 01       	movw	r18, r20
     53e:	ab 01       	movw	r20, r22
     540:	2a 0d       	add	r18, r10
     542:	3b 1d       	adc	r19, r11
     544:	4c 1d       	adc	r20, r12
     546:	5d 1d       	adc	r21, r13
     548:	80 e0       	ldi	r24, 0x00	; 0
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	a0 e0       	ldi	r26, 0x00	; 0
     54e:	b0 e0       	ldi	r27, 0x00	; 0
     550:	e6 14       	cp	r14, r6
     552:	f7 04       	cpc	r15, r7
     554:	08 05       	cpc	r16, r8
     556:	19 05       	cpc	r17, r9
     558:	20 f4       	brcc	.+8      	; 0x562 <__mulsf3+0xe8>
     55a:	81 e0       	ldi	r24, 0x01	; 1
     55c:	90 e0       	ldi	r25, 0x00	; 0
     55e:	a0 e0       	ldi	r26, 0x00	; 0
     560:	b0 e0       	ldi	r27, 0x00	; 0
     562:	ba 01       	movw	r22, r20
     564:	a9 01       	movw	r20, r18
     566:	48 0f       	add	r20, r24
     568:	59 1f       	adc	r21, r25
     56a:	6a 1f       	adc	r22, r26
     56c:	7b 1f       	adc	r23, r27
     56e:	aa 0c       	add	r10, r10
     570:	bb 1c       	adc	r11, r11
     572:	cc 1c       	adc	r12, r12
     574:	dd 1c       	adc	r13, r13
     576:	97 fe       	sbrs	r9, 7
     578:	08 c0       	rjmp	.+16     	; 0x58a <__mulsf3+0x110>
     57a:	81 e0       	ldi	r24, 0x01	; 1
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	a0 e0       	ldi	r26, 0x00	; 0
     580:	b0 e0       	ldi	r27, 0x00	; 0
     582:	a8 2a       	or	r10, r24
     584:	b9 2a       	or	r11, r25
     586:	ca 2a       	or	r12, r26
     588:	db 2a       	or	r13, r27
     58a:	31 96       	adiw	r30, 0x01	; 1
     58c:	e0 32       	cpi	r30, 0x20	; 32
     58e:	f1 05       	cpc	r31, r1
     590:	49 f0       	breq	.+18     	; 0x5a4 <__mulsf3+0x12a>
     592:	66 0c       	add	r6, r6
     594:	77 1c       	adc	r7, r7
     596:	88 1c       	adc	r8, r8
     598:	99 1c       	adc	r9, r9
     59a:	56 94       	lsr	r5
     59c:	47 94       	ror	r4
     59e:	37 94       	ror	r3
     5a0:	27 94       	ror	r2
     5a2:	c3 cf       	rjmp	.-122    	; 0x52a <__mulsf3+0xb0>
     5a4:	fa 85       	ldd	r31, Y+10	; 0x0a
     5a6:	ea 89       	ldd	r30, Y+18	; 0x12
     5a8:	2b 89       	ldd	r18, Y+19	; 0x13
     5aa:	3c 89       	ldd	r19, Y+20	; 0x14
     5ac:	8b 85       	ldd	r24, Y+11	; 0x0b
     5ae:	9c 85       	ldd	r25, Y+12	; 0x0c
     5b0:	28 0f       	add	r18, r24
     5b2:	39 1f       	adc	r19, r25
     5b4:	2e 5f       	subi	r18, 0xFE	; 254
     5b6:	3f 4f       	sbci	r19, 0xFF	; 255
     5b8:	17 c0       	rjmp	.+46     	; 0x5e8 <__mulsf3+0x16e>
     5ba:	ca 01       	movw	r24, r20
     5bc:	81 70       	andi	r24, 0x01	; 1
     5be:	90 70       	andi	r25, 0x00	; 0
     5c0:	89 2b       	or	r24, r25
     5c2:	61 f0       	breq	.+24     	; 0x5dc <__mulsf3+0x162>
     5c4:	16 95       	lsr	r17
     5c6:	07 95       	ror	r16
     5c8:	f7 94       	ror	r15
     5ca:	e7 94       	ror	r14
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	a0 e0       	ldi	r26, 0x00	; 0
     5d2:	b0 e8       	ldi	r27, 0x80	; 128
     5d4:	e8 2a       	or	r14, r24
     5d6:	f9 2a       	or	r15, r25
     5d8:	0a 2b       	or	r16, r26
     5da:	1b 2b       	or	r17, r27
     5dc:	76 95       	lsr	r23
     5de:	67 95       	ror	r22
     5e0:	57 95       	ror	r21
     5e2:	47 95       	ror	r20
     5e4:	2f 5f       	subi	r18, 0xFF	; 255
     5e6:	3f 4f       	sbci	r19, 0xFF	; 255
     5e8:	77 fd       	sbrc	r23, 7
     5ea:	e7 cf       	rjmp	.-50     	; 0x5ba <__mulsf3+0x140>
     5ec:	0c c0       	rjmp	.+24     	; 0x606 <__mulsf3+0x18c>
     5ee:	44 0f       	add	r20, r20
     5f0:	55 1f       	adc	r21, r21
     5f2:	66 1f       	adc	r22, r22
     5f4:	77 1f       	adc	r23, r23
     5f6:	17 fd       	sbrc	r17, 7
     5f8:	41 60       	ori	r20, 0x01	; 1
     5fa:	ee 0c       	add	r14, r14
     5fc:	ff 1c       	adc	r15, r15
     5fe:	00 1f       	adc	r16, r16
     600:	11 1f       	adc	r17, r17
     602:	21 50       	subi	r18, 0x01	; 1
     604:	30 40       	sbci	r19, 0x00	; 0
     606:	40 30       	cpi	r20, 0x00	; 0
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	59 07       	cpc	r21, r25
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	69 07       	cpc	r22, r25
     610:	90 e4       	ldi	r25, 0x40	; 64
     612:	79 07       	cpc	r23, r25
     614:	60 f3       	brcs	.-40     	; 0x5ee <__mulsf3+0x174>
     616:	2b 8f       	std	Y+27, r18	; 0x1b
     618:	3c 8f       	std	Y+28, r19	; 0x1c
     61a:	db 01       	movw	r26, r22
     61c:	ca 01       	movw	r24, r20
     61e:	8f 77       	andi	r24, 0x7F	; 127
     620:	90 70       	andi	r25, 0x00	; 0
     622:	a0 70       	andi	r26, 0x00	; 0
     624:	b0 70       	andi	r27, 0x00	; 0
     626:	80 34       	cpi	r24, 0x40	; 64
     628:	91 05       	cpc	r25, r1
     62a:	a1 05       	cpc	r26, r1
     62c:	b1 05       	cpc	r27, r1
     62e:	61 f4       	brne	.+24     	; 0x648 <__mulsf3+0x1ce>
     630:	47 fd       	sbrc	r20, 7
     632:	0a c0       	rjmp	.+20     	; 0x648 <__mulsf3+0x1ce>
     634:	e1 14       	cp	r14, r1
     636:	f1 04       	cpc	r15, r1
     638:	01 05       	cpc	r16, r1
     63a:	11 05       	cpc	r17, r1
     63c:	29 f0       	breq	.+10     	; 0x648 <__mulsf3+0x1ce>
     63e:	40 5c       	subi	r20, 0xC0	; 192
     640:	5f 4f       	sbci	r21, 0xFF	; 255
     642:	6f 4f       	sbci	r22, 0xFF	; 255
     644:	7f 4f       	sbci	r23, 0xFF	; 255
     646:	40 78       	andi	r20, 0x80	; 128
     648:	1a 8e       	std	Y+26, r1	; 0x1a
     64a:	fe 17       	cp	r31, r30
     64c:	11 f0       	breq	.+4      	; 0x652 <__mulsf3+0x1d8>
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	8a 8f       	std	Y+26, r24	; 0x1a
     652:	4d 8f       	std	Y+29, r20	; 0x1d
     654:	5e 8f       	std	Y+30, r21	; 0x1e
     656:	6f 8f       	std	Y+31, r22	; 0x1f
     658:	78 a3       	std	Y+32, r23	; 0x20
     65a:	83 e0       	ldi	r24, 0x03	; 3
     65c:	89 8f       	std	Y+25, r24	; 0x19
     65e:	ce 01       	movw	r24, r28
     660:	49 96       	adiw	r24, 0x19	; 25
     662:	0e 94 1b 04 	call	0x836	; 0x836 <__pack_f>
     666:	a0 96       	adiw	r28, 0x20	; 32
     668:	e2 e1       	ldi	r30, 0x12	; 18
     66a:	0c 94 6b 4d 	jmp	0x9ad6	; 0x9ad6 <__epilogue_restores__>

0000066e <__gtsf2>:
     66e:	a8 e1       	ldi	r26, 0x18	; 24
     670:	b0 e0       	ldi	r27, 0x00	; 0
     672:	ed e3       	ldi	r30, 0x3D	; 61
     674:	f3 e0       	ldi	r31, 0x03	; 3
     676:	0c 94 5b 4d 	jmp	0x9ab6	; 0x9ab6 <__prologue_saves__+0x18>
     67a:	69 83       	std	Y+1, r22	; 0x01
     67c:	7a 83       	std	Y+2, r23	; 0x02
     67e:	8b 83       	std	Y+3, r24	; 0x03
     680:	9c 83       	std	Y+4, r25	; 0x04
     682:	2d 83       	std	Y+5, r18	; 0x05
     684:	3e 83       	std	Y+6, r19	; 0x06
     686:	4f 83       	std	Y+7, r20	; 0x07
     688:	58 87       	std	Y+8, r21	; 0x08
     68a:	89 e0       	ldi	r24, 0x09	; 9
     68c:	e8 2e       	mov	r14, r24
     68e:	f1 2c       	mov	r15, r1
     690:	ec 0e       	add	r14, r28
     692:	fd 1e       	adc	r15, r29
     694:	ce 01       	movw	r24, r28
     696:	01 96       	adiw	r24, 0x01	; 1
     698:	b7 01       	movw	r22, r14
     69a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     69e:	8e 01       	movw	r16, r28
     6a0:	0f 5e       	subi	r16, 0xEF	; 239
     6a2:	1f 4f       	sbci	r17, 0xFF	; 255
     6a4:	ce 01       	movw	r24, r28
     6a6:	05 96       	adiw	r24, 0x05	; 5
     6a8:	b8 01       	movw	r22, r16
     6aa:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     6ae:	89 85       	ldd	r24, Y+9	; 0x09
     6b0:	82 30       	cpi	r24, 0x02	; 2
     6b2:	40 f0       	brcs	.+16     	; 0x6c4 <__gtsf2+0x56>
     6b4:	89 89       	ldd	r24, Y+17	; 0x11
     6b6:	82 30       	cpi	r24, 0x02	; 2
     6b8:	28 f0       	brcs	.+10     	; 0x6c4 <__gtsf2+0x56>
     6ba:	c7 01       	movw	r24, r14
     6bc:	b8 01       	movw	r22, r16
     6be:	0e 94 68 05 	call	0xad0	; 0xad0 <__fpcmp_parts_f>
     6c2:	01 c0       	rjmp	.+2      	; 0x6c6 <__gtsf2+0x58>
     6c4:	8f ef       	ldi	r24, 0xFF	; 255
     6c6:	68 96       	adiw	r28, 0x18	; 24
     6c8:	e6 e0       	ldi	r30, 0x06	; 6
     6ca:	0c 94 77 4d 	jmp	0x9aee	; 0x9aee <__epilogue_restores__+0x18>

000006ce <__gesf2>:
     6ce:	a8 e1       	ldi	r26, 0x18	; 24
     6d0:	b0 e0       	ldi	r27, 0x00	; 0
     6d2:	ed e6       	ldi	r30, 0x6D	; 109
     6d4:	f3 e0       	ldi	r31, 0x03	; 3
     6d6:	0c 94 5b 4d 	jmp	0x9ab6	; 0x9ab6 <__prologue_saves__+0x18>
     6da:	69 83       	std	Y+1, r22	; 0x01
     6dc:	7a 83       	std	Y+2, r23	; 0x02
     6de:	8b 83       	std	Y+3, r24	; 0x03
     6e0:	9c 83       	std	Y+4, r25	; 0x04
     6e2:	2d 83       	std	Y+5, r18	; 0x05
     6e4:	3e 83       	std	Y+6, r19	; 0x06
     6e6:	4f 83       	std	Y+7, r20	; 0x07
     6e8:	58 87       	std	Y+8, r21	; 0x08
     6ea:	89 e0       	ldi	r24, 0x09	; 9
     6ec:	e8 2e       	mov	r14, r24
     6ee:	f1 2c       	mov	r15, r1
     6f0:	ec 0e       	add	r14, r28
     6f2:	fd 1e       	adc	r15, r29
     6f4:	ce 01       	movw	r24, r28
     6f6:	01 96       	adiw	r24, 0x01	; 1
     6f8:	b7 01       	movw	r22, r14
     6fa:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     6fe:	8e 01       	movw	r16, r28
     700:	0f 5e       	subi	r16, 0xEF	; 239
     702:	1f 4f       	sbci	r17, 0xFF	; 255
     704:	ce 01       	movw	r24, r28
     706:	05 96       	adiw	r24, 0x05	; 5
     708:	b8 01       	movw	r22, r16
     70a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     70e:	89 85       	ldd	r24, Y+9	; 0x09
     710:	82 30       	cpi	r24, 0x02	; 2
     712:	40 f0       	brcs	.+16     	; 0x724 <__gesf2+0x56>
     714:	89 89       	ldd	r24, Y+17	; 0x11
     716:	82 30       	cpi	r24, 0x02	; 2
     718:	28 f0       	brcs	.+10     	; 0x724 <__gesf2+0x56>
     71a:	c7 01       	movw	r24, r14
     71c:	b8 01       	movw	r22, r16
     71e:	0e 94 68 05 	call	0xad0	; 0xad0 <__fpcmp_parts_f>
     722:	01 c0       	rjmp	.+2      	; 0x726 <__gesf2+0x58>
     724:	8f ef       	ldi	r24, 0xFF	; 255
     726:	68 96       	adiw	r28, 0x18	; 24
     728:	e6 e0       	ldi	r30, 0x06	; 6
     72a:	0c 94 77 4d 	jmp	0x9aee	; 0x9aee <__epilogue_restores__+0x18>

0000072e <__ltsf2>:
     72e:	a8 e1       	ldi	r26, 0x18	; 24
     730:	b0 e0       	ldi	r27, 0x00	; 0
     732:	ed e9       	ldi	r30, 0x9D	; 157
     734:	f3 e0       	ldi	r31, 0x03	; 3
     736:	0c 94 5b 4d 	jmp	0x9ab6	; 0x9ab6 <__prologue_saves__+0x18>
     73a:	69 83       	std	Y+1, r22	; 0x01
     73c:	7a 83       	std	Y+2, r23	; 0x02
     73e:	8b 83       	std	Y+3, r24	; 0x03
     740:	9c 83       	std	Y+4, r25	; 0x04
     742:	2d 83       	std	Y+5, r18	; 0x05
     744:	3e 83       	std	Y+6, r19	; 0x06
     746:	4f 83       	std	Y+7, r20	; 0x07
     748:	58 87       	std	Y+8, r21	; 0x08
     74a:	89 e0       	ldi	r24, 0x09	; 9
     74c:	e8 2e       	mov	r14, r24
     74e:	f1 2c       	mov	r15, r1
     750:	ec 0e       	add	r14, r28
     752:	fd 1e       	adc	r15, r29
     754:	ce 01       	movw	r24, r28
     756:	01 96       	adiw	r24, 0x01	; 1
     758:	b7 01       	movw	r22, r14
     75a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     75e:	8e 01       	movw	r16, r28
     760:	0f 5e       	subi	r16, 0xEF	; 239
     762:	1f 4f       	sbci	r17, 0xFF	; 255
     764:	ce 01       	movw	r24, r28
     766:	05 96       	adiw	r24, 0x05	; 5
     768:	b8 01       	movw	r22, r16
     76a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     76e:	89 85       	ldd	r24, Y+9	; 0x09
     770:	82 30       	cpi	r24, 0x02	; 2
     772:	40 f0       	brcs	.+16     	; 0x784 <__ltsf2+0x56>
     774:	89 89       	ldd	r24, Y+17	; 0x11
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	28 f0       	brcs	.+10     	; 0x784 <__ltsf2+0x56>
     77a:	c7 01       	movw	r24, r14
     77c:	b8 01       	movw	r22, r16
     77e:	0e 94 68 05 	call	0xad0	; 0xad0 <__fpcmp_parts_f>
     782:	01 c0       	rjmp	.+2      	; 0x786 <__ltsf2+0x58>
     784:	81 e0       	ldi	r24, 0x01	; 1
     786:	68 96       	adiw	r28, 0x18	; 24
     788:	e6 e0       	ldi	r30, 0x06	; 6
     78a:	0c 94 77 4d 	jmp	0x9aee	; 0x9aee <__epilogue_restores__+0x18>

0000078e <__fixsfsi>:
     78e:	ac e0       	ldi	r26, 0x0C	; 12
     790:	b0 e0       	ldi	r27, 0x00	; 0
     792:	ed ec       	ldi	r30, 0xCD	; 205
     794:	f3 e0       	ldi	r31, 0x03	; 3
     796:	0c 94 5f 4d 	jmp	0x9abe	; 0x9abe <__prologue_saves__+0x20>
     79a:	69 83       	std	Y+1, r22	; 0x01
     79c:	7a 83       	std	Y+2, r23	; 0x02
     79e:	8b 83       	std	Y+3, r24	; 0x03
     7a0:	9c 83       	std	Y+4, r25	; 0x04
     7a2:	ce 01       	movw	r24, r28
     7a4:	01 96       	adiw	r24, 0x01	; 1
     7a6:	be 01       	movw	r22, r28
     7a8:	6b 5f       	subi	r22, 0xFB	; 251
     7aa:	7f 4f       	sbci	r23, 0xFF	; 255
     7ac:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <__unpack_f>
     7b0:	8d 81       	ldd	r24, Y+5	; 0x05
     7b2:	82 30       	cpi	r24, 0x02	; 2
     7b4:	61 f1       	breq	.+88     	; 0x80e <__fixsfsi+0x80>
     7b6:	82 30       	cpi	r24, 0x02	; 2
     7b8:	50 f1       	brcs	.+84     	; 0x80e <__fixsfsi+0x80>
     7ba:	84 30       	cpi	r24, 0x04	; 4
     7bc:	21 f4       	brne	.+8      	; 0x7c6 <__fixsfsi+0x38>
     7be:	8e 81       	ldd	r24, Y+6	; 0x06
     7c0:	88 23       	and	r24, r24
     7c2:	51 f1       	breq	.+84     	; 0x818 <__fixsfsi+0x8a>
     7c4:	2e c0       	rjmp	.+92     	; 0x822 <__fixsfsi+0x94>
     7c6:	2f 81       	ldd	r18, Y+7	; 0x07
     7c8:	38 85       	ldd	r19, Y+8	; 0x08
     7ca:	37 fd       	sbrc	r19, 7
     7cc:	20 c0       	rjmp	.+64     	; 0x80e <__fixsfsi+0x80>
     7ce:	6e 81       	ldd	r22, Y+6	; 0x06
     7d0:	2f 31       	cpi	r18, 0x1F	; 31
     7d2:	31 05       	cpc	r19, r1
     7d4:	1c f0       	brlt	.+6      	; 0x7dc <__fixsfsi+0x4e>
     7d6:	66 23       	and	r22, r22
     7d8:	f9 f0       	breq	.+62     	; 0x818 <__fixsfsi+0x8a>
     7da:	23 c0       	rjmp	.+70     	; 0x822 <__fixsfsi+0x94>
     7dc:	8e e1       	ldi	r24, 0x1E	; 30
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	82 1b       	sub	r24, r18
     7e2:	93 0b       	sbc	r25, r19
     7e4:	29 85       	ldd	r18, Y+9	; 0x09
     7e6:	3a 85       	ldd	r19, Y+10	; 0x0a
     7e8:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ea:	5c 85       	ldd	r21, Y+12	; 0x0c
     7ec:	04 c0       	rjmp	.+8      	; 0x7f6 <__fixsfsi+0x68>
     7ee:	56 95       	lsr	r21
     7f0:	47 95       	ror	r20
     7f2:	37 95       	ror	r19
     7f4:	27 95       	ror	r18
     7f6:	8a 95       	dec	r24
     7f8:	d2 f7       	brpl	.-12     	; 0x7ee <__fixsfsi+0x60>
     7fa:	66 23       	and	r22, r22
     7fc:	b1 f0       	breq	.+44     	; 0x82a <__fixsfsi+0x9c>
     7fe:	50 95       	com	r21
     800:	40 95       	com	r20
     802:	30 95       	com	r19
     804:	21 95       	neg	r18
     806:	3f 4f       	sbci	r19, 0xFF	; 255
     808:	4f 4f       	sbci	r20, 0xFF	; 255
     80a:	5f 4f       	sbci	r21, 0xFF	; 255
     80c:	0e c0       	rjmp	.+28     	; 0x82a <__fixsfsi+0x9c>
     80e:	20 e0       	ldi	r18, 0x00	; 0
     810:	30 e0       	ldi	r19, 0x00	; 0
     812:	40 e0       	ldi	r20, 0x00	; 0
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	09 c0       	rjmp	.+18     	; 0x82a <__fixsfsi+0x9c>
     818:	2f ef       	ldi	r18, 0xFF	; 255
     81a:	3f ef       	ldi	r19, 0xFF	; 255
     81c:	4f ef       	ldi	r20, 0xFF	; 255
     81e:	5f e7       	ldi	r21, 0x7F	; 127
     820:	04 c0       	rjmp	.+8      	; 0x82a <__fixsfsi+0x9c>
     822:	20 e0       	ldi	r18, 0x00	; 0
     824:	30 e0       	ldi	r19, 0x00	; 0
     826:	40 e0       	ldi	r20, 0x00	; 0
     828:	50 e8       	ldi	r21, 0x80	; 128
     82a:	b9 01       	movw	r22, r18
     82c:	ca 01       	movw	r24, r20
     82e:	2c 96       	adiw	r28, 0x0c	; 12
     830:	e2 e0       	ldi	r30, 0x02	; 2
     832:	0c 94 7b 4d 	jmp	0x9af6	; 0x9af6 <__epilogue_restores__+0x20>

00000836 <__pack_f>:
     836:	df 92       	push	r13
     838:	ef 92       	push	r14
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	fc 01       	movw	r30, r24
     842:	e4 80       	ldd	r14, Z+4	; 0x04
     844:	f5 80       	ldd	r15, Z+5	; 0x05
     846:	06 81       	ldd	r16, Z+6	; 0x06
     848:	17 81       	ldd	r17, Z+7	; 0x07
     84a:	d1 80       	ldd	r13, Z+1	; 0x01
     84c:	80 81       	ld	r24, Z
     84e:	82 30       	cpi	r24, 0x02	; 2
     850:	48 f4       	brcc	.+18     	; 0x864 <__pack_f+0x2e>
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	a0 e1       	ldi	r26, 0x10	; 16
     858:	b0 e0       	ldi	r27, 0x00	; 0
     85a:	e8 2a       	or	r14, r24
     85c:	f9 2a       	or	r15, r25
     85e:	0a 2b       	or	r16, r26
     860:	1b 2b       	or	r17, r27
     862:	a5 c0       	rjmp	.+330    	; 0x9ae <__pack_f+0x178>
     864:	84 30       	cpi	r24, 0x04	; 4
     866:	09 f4       	brne	.+2      	; 0x86a <__pack_f+0x34>
     868:	9f c0       	rjmp	.+318    	; 0x9a8 <__pack_f+0x172>
     86a:	82 30       	cpi	r24, 0x02	; 2
     86c:	21 f4       	brne	.+8      	; 0x876 <__pack_f+0x40>
     86e:	ee 24       	eor	r14, r14
     870:	ff 24       	eor	r15, r15
     872:	87 01       	movw	r16, r14
     874:	05 c0       	rjmp	.+10     	; 0x880 <__pack_f+0x4a>
     876:	e1 14       	cp	r14, r1
     878:	f1 04       	cpc	r15, r1
     87a:	01 05       	cpc	r16, r1
     87c:	11 05       	cpc	r17, r1
     87e:	19 f4       	brne	.+6      	; 0x886 <__pack_f+0x50>
     880:	e0 e0       	ldi	r30, 0x00	; 0
     882:	f0 e0       	ldi	r31, 0x00	; 0
     884:	96 c0       	rjmp	.+300    	; 0x9b2 <__pack_f+0x17c>
     886:	62 81       	ldd	r22, Z+2	; 0x02
     888:	73 81       	ldd	r23, Z+3	; 0x03
     88a:	9f ef       	ldi	r25, 0xFF	; 255
     88c:	62 38       	cpi	r22, 0x82	; 130
     88e:	79 07       	cpc	r23, r25
     890:	0c f0       	brlt	.+2      	; 0x894 <__pack_f+0x5e>
     892:	5b c0       	rjmp	.+182    	; 0x94a <__pack_f+0x114>
     894:	22 e8       	ldi	r18, 0x82	; 130
     896:	3f ef       	ldi	r19, 0xFF	; 255
     898:	26 1b       	sub	r18, r22
     89a:	37 0b       	sbc	r19, r23
     89c:	2a 31       	cpi	r18, 0x1A	; 26
     89e:	31 05       	cpc	r19, r1
     8a0:	2c f0       	brlt	.+10     	; 0x8ac <__pack_f+0x76>
     8a2:	20 e0       	ldi	r18, 0x00	; 0
     8a4:	30 e0       	ldi	r19, 0x00	; 0
     8a6:	40 e0       	ldi	r20, 0x00	; 0
     8a8:	50 e0       	ldi	r21, 0x00	; 0
     8aa:	2a c0       	rjmp	.+84     	; 0x900 <__pack_f+0xca>
     8ac:	b8 01       	movw	r22, r16
     8ae:	a7 01       	movw	r20, r14
     8b0:	02 2e       	mov	r0, r18
     8b2:	04 c0       	rjmp	.+8      	; 0x8bc <__pack_f+0x86>
     8b4:	76 95       	lsr	r23
     8b6:	67 95       	ror	r22
     8b8:	57 95       	ror	r21
     8ba:	47 95       	ror	r20
     8bc:	0a 94       	dec	r0
     8be:	d2 f7       	brpl	.-12     	; 0x8b4 <__pack_f+0x7e>
     8c0:	81 e0       	ldi	r24, 0x01	; 1
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	a0 e0       	ldi	r26, 0x00	; 0
     8c6:	b0 e0       	ldi	r27, 0x00	; 0
     8c8:	04 c0       	rjmp	.+8      	; 0x8d2 <__pack_f+0x9c>
     8ca:	88 0f       	add	r24, r24
     8cc:	99 1f       	adc	r25, r25
     8ce:	aa 1f       	adc	r26, r26
     8d0:	bb 1f       	adc	r27, r27
     8d2:	2a 95       	dec	r18
     8d4:	d2 f7       	brpl	.-12     	; 0x8ca <__pack_f+0x94>
     8d6:	01 97       	sbiw	r24, 0x01	; 1
     8d8:	a1 09       	sbc	r26, r1
     8da:	b1 09       	sbc	r27, r1
     8dc:	8e 21       	and	r24, r14
     8de:	9f 21       	and	r25, r15
     8e0:	a0 23       	and	r26, r16
     8e2:	b1 23       	and	r27, r17
     8e4:	00 97       	sbiw	r24, 0x00	; 0
     8e6:	a1 05       	cpc	r26, r1
     8e8:	b1 05       	cpc	r27, r1
     8ea:	21 f0       	breq	.+8      	; 0x8f4 <__pack_f+0xbe>
     8ec:	81 e0       	ldi	r24, 0x01	; 1
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	a0 e0       	ldi	r26, 0x00	; 0
     8f2:	b0 e0       	ldi	r27, 0x00	; 0
     8f4:	9a 01       	movw	r18, r20
     8f6:	ab 01       	movw	r20, r22
     8f8:	28 2b       	or	r18, r24
     8fa:	39 2b       	or	r19, r25
     8fc:	4a 2b       	or	r20, r26
     8fe:	5b 2b       	or	r21, r27
     900:	da 01       	movw	r26, r20
     902:	c9 01       	movw	r24, r18
     904:	8f 77       	andi	r24, 0x7F	; 127
     906:	90 70       	andi	r25, 0x00	; 0
     908:	a0 70       	andi	r26, 0x00	; 0
     90a:	b0 70       	andi	r27, 0x00	; 0
     90c:	80 34       	cpi	r24, 0x40	; 64
     90e:	91 05       	cpc	r25, r1
     910:	a1 05       	cpc	r26, r1
     912:	b1 05       	cpc	r27, r1
     914:	39 f4       	brne	.+14     	; 0x924 <__pack_f+0xee>
     916:	27 ff       	sbrs	r18, 7
     918:	09 c0       	rjmp	.+18     	; 0x92c <__pack_f+0xf6>
     91a:	20 5c       	subi	r18, 0xC0	; 192
     91c:	3f 4f       	sbci	r19, 0xFF	; 255
     91e:	4f 4f       	sbci	r20, 0xFF	; 255
     920:	5f 4f       	sbci	r21, 0xFF	; 255
     922:	04 c0       	rjmp	.+8      	; 0x92c <__pack_f+0xf6>
     924:	21 5c       	subi	r18, 0xC1	; 193
     926:	3f 4f       	sbci	r19, 0xFF	; 255
     928:	4f 4f       	sbci	r20, 0xFF	; 255
     92a:	5f 4f       	sbci	r21, 0xFF	; 255
     92c:	e0 e0       	ldi	r30, 0x00	; 0
     92e:	f0 e0       	ldi	r31, 0x00	; 0
     930:	20 30       	cpi	r18, 0x00	; 0
     932:	a0 e0       	ldi	r26, 0x00	; 0
     934:	3a 07       	cpc	r19, r26
     936:	a0 e0       	ldi	r26, 0x00	; 0
     938:	4a 07       	cpc	r20, r26
     93a:	a0 e4       	ldi	r26, 0x40	; 64
     93c:	5a 07       	cpc	r21, r26
     93e:	10 f0       	brcs	.+4      	; 0x944 <__pack_f+0x10e>
     940:	e1 e0       	ldi	r30, 0x01	; 1
     942:	f0 e0       	ldi	r31, 0x00	; 0
     944:	79 01       	movw	r14, r18
     946:	8a 01       	movw	r16, r20
     948:	27 c0       	rjmp	.+78     	; 0x998 <__pack_f+0x162>
     94a:	60 38       	cpi	r22, 0x80	; 128
     94c:	71 05       	cpc	r23, r1
     94e:	64 f5       	brge	.+88     	; 0x9a8 <__pack_f+0x172>
     950:	fb 01       	movw	r30, r22
     952:	e1 58       	subi	r30, 0x81	; 129
     954:	ff 4f       	sbci	r31, 0xFF	; 255
     956:	d8 01       	movw	r26, r16
     958:	c7 01       	movw	r24, r14
     95a:	8f 77       	andi	r24, 0x7F	; 127
     95c:	90 70       	andi	r25, 0x00	; 0
     95e:	a0 70       	andi	r26, 0x00	; 0
     960:	b0 70       	andi	r27, 0x00	; 0
     962:	80 34       	cpi	r24, 0x40	; 64
     964:	91 05       	cpc	r25, r1
     966:	a1 05       	cpc	r26, r1
     968:	b1 05       	cpc	r27, r1
     96a:	39 f4       	brne	.+14     	; 0x97a <__pack_f+0x144>
     96c:	e7 fe       	sbrs	r14, 7
     96e:	0d c0       	rjmp	.+26     	; 0x98a <__pack_f+0x154>
     970:	80 e4       	ldi	r24, 0x40	; 64
     972:	90 e0       	ldi	r25, 0x00	; 0
     974:	a0 e0       	ldi	r26, 0x00	; 0
     976:	b0 e0       	ldi	r27, 0x00	; 0
     978:	04 c0       	rjmp	.+8      	; 0x982 <__pack_f+0x14c>
     97a:	8f e3       	ldi	r24, 0x3F	; 63
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	a0 e0       	ldi	r26, 0x00	; 0
     980:	b0 e0       	ldi	r27, 0x00	; 0
     982:	e8 0e       	add	r14, r24
     984:	f9 1e       	adc	r15, r25
     986:	0a 1f       	adc	r16, r26
     988:	1b 1f       	adc	r17, r27
     98a:	17 ff       	sbrs	r17, 7
     98c:	05 c0       	rjmp	.+10     	; 0x998 <__pack_f+0x162>
     98e:	16 95       	lsr	r17
     990:	07 95       	ror	r16
     992:	f7 94       	ror	r15
     994:	e7 94       	ror	r14
     996:	31 96       	adiw	r30, 0x01	; 1
     998:	87 e0       	ldi	r24, 0x07	; 7
     99a:	16 95       	lsr	r17
     99c:	07 95       	ror	r16
     99e:	f7 94       	ror	r15
     9a0:	e7 94       	ror	r14
     9a2:	8a 95       	dec	r24
     9a4:	d1 f7       	brne	.-12     	; 0x99a <__pack_f+0x164>
     9a6:	05 c0       	rjmp	.+10     	; 0x9b2 <__pack_f+0x17c>
     9a8:	ee 24       	eor	r14, r14
     9aa:	ff 24       	eor	r15, r15
     9ac:	87 01       	movw	r16, r14
     9ae:	ef ef       	ldi	r30, 0xFF	; 255
     9b0:	f0 e0       	ldi	r31, 0x00	; 0
     9b2:	6e 2f       	mov	r22, r30
     9b4:	67 95       	ror	r22
     9b6:	66 27       	eor	r22, r22
     9b8:	67 95       	ror	r22
     9ba:	90 2f       	mov	r25, r16
     9bc:	9f 77       	andi	r25, 0x7F	; 127
     9be:	d7 94       	ror	r13
     9c0:	dd 24       	eor	r13, r13
     9c2:	d7 94       	ror	r13
     9c4:	8e 2f       	mov	r24, r30
     9c6:	86 95       	lsr	r24
     9c8:	49 2f       	mov	r20, r25
     9ca:	46 2b       	or	r20, r22
     9cc:	58 2f       	mov	r21, r24
     9ce:	5d 29       	or	r21, r13
     9d0:	b7 01       	movw	r22, r14
     9d2:	ca 01       	movw	r24, r20
     9d4:	1f 91       	pop	r17
     9d6:	0f 91       	pop	r16
     9d8:	ff 90       	pop	r15
     9da:	ef 90       	pop	r14
     9dc:	df 90       	pop	r13
     9de:	08 95       	ret

000009e0 <__unpack_f>:
     9e0:	fc 01       	movw	r30, r24
     9e2:	db 01       	movw	r26, r22
     9e4:	40 81       	ld	r20, Z
     9e6:	51 81       	ldd	r21, Z+1	; 0x01
     9e8:	22 81       	ldd	r18, Z+2	; 0x02
     9ea:	62 2f       	mov	r22, r18
     9ec:	6f 77       	andi	r22, 0x7F	; 127
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	22 1f       	adc	r18, r18
     9f2:	22 27       	eor	r18, r18
     9f4:	22 1f       	adc	r18, r18
     9f6:	93 81       	ldd	r25, Z+3	; 0x03
     9f8:	89 2f       	mov	r24, r25
     9fa:	88 0f       	add	r24, r24
     9fc:	82 2b       	or	r24, r18
     9fe:	28 2f       	mov	r18, r24
     a00:	30 e0       	ldi	r19, 0x00	; 0
     a02:	99 1f       	adc	r25, r25
     a04:	99 27       	eor	r25, r25
     a06:	99 1f       	adc	r25, r25
     a08:	11 96       	adiw	r26, 0x01	; 1
     a0a:	9c 93       	st	X, r25
     a0c:	11 97       	sbiw	r26, 0x01	; 1
     a0e:	21 15       	cp	r18, r1
     a10:	31 05       	cpc	r19, r1
     a12:	a9 f5       	brne	.+106    	; 0xa7e <__unpack_f+0x9e>
     a14:	41 15       	cp	r20, r1
     a16:	51 05       	cpc	r21, r1
     a18:	61 05       	cpc	r22, r1
     a1a:	71 05       	cpc	r23, r1
     a1c:	11 f4       	brne	.+4      	; 0xa22 <__unpack_f+0x42>
     a1e:	82 e0       	ldi	r24, 0x02	; 2
     a20:	37 c0       	rjmp	.+110    	; 0xa90 <__unpack_f+0xb0>
     a22:	82 e8       	ldi	r24, 0x82	; 130
     a24:	9f ef       	ldi	r25, 0xFF	; 255
     a26:	13 96       	adiw	r26, 0x03	; 3
     a28:	9c 93       	st	X, r25
     a2a:	8e 93       	st	-X, r24
     a2c:	12 97       	sbiw	r26, 0x02	; 2
     a2e:	9a 01       	movw	r18, r20
     a30:	ab 01       	movw	r20, r22
     a32:	67 e0       	ldi	r22, 0x07	; 7
     a34:	22 0f       	add	r18, r18
     a36:	33 1f       	adc	r19, r19
     a38:	44 1f       	adc	r20, r20
     a3a:	55 1f       	adc	r21, r21
     a3c:	6a 95       	dec	r22
     a3e:	d1 f7       	brne	.-12     	; 0xa34 <__unpack_f+0x54>
     a40:	83 e0       	ldi	r24, 0x03	; 3
     a42:	8c 93       	st	X, r24
     a44:	0d c0       	rjmp	.+26     	; 0xa60 <__unpack_f+0x80>
     a46:	22 0f       	add	r18, r18
     a48:	33 1f       	adc	r19, r19
     a4a:	44 1f       	adc	r20, r20
     a4c:	55 1f       	adc	r21, r21
     a4e:	12 96       	adiw	r26, 0x02	; 2
     a50:	8d 91       	ld	r24, X+
     a52:	9c 91       	ld	r25, X
     a54:	13 97       	sbiw	r26, 0x03	; 3
     a56:	01 97       	sbiw	r24, 0x01	; 1
     a58:	13 96       	adiw	r26, 0x03	; 3
     a5a:	9c 93       	st	X, r25
     a5c:	8e 93       	st	-X, r24
     a5e:	12 97       	sbiw	r26, 0x02	; 2
     a60:	20 30       	cpi	r18, 0x00	; 0
     a62:	80 e0       	ldi	r24, 0x00	; 0
     a64:	38 07       	cpc	r19, r24
     a66:	80 e0       	ldi	r24, 0x00	; 0
     a68:	48 07       	cpc	r20, r24
     a6a:	80 e4       	ldi	r24, 0x40	; 64
     a6c:	58 07       	cpc	r21, r24
     a6e:	58 f3       	brcs	.-42     	; 0xa46 <__unpack_f+0x66>
     a70:	14 96       	adiw	r26, 0x04	; 4
     a72:	2d 93       	st	X+, r18
     a74:	3d 93       	st	X+, r19
     a76:	4d 93       	st	X+, r20
     a78:	5c 93       	st	X, r21
     a7a:	17 97       	sbiw	r26, 0x07	; 7
     a7c:	08 95       	ret
     a7e:	2f 3f       	cpi	r18, 0xFF	; 255
     a80:	31 05       	cpc	r19, r1
     a82:	79 f4       	brne	.+30     	; 0xaa2 <__unpack_f+0xc2>
     a84:	41 15       	cp	r20, r1
     a86:	51 05       	cpc	r21, r1
     a88:	61 05       	cpc	r22, r1
     a8a:	71 05       	cpc	r23, r1
     a8c:	19 f4       	brne	.+6      	; 0xa94 <__unpack_f+0xb4>
     a8e:	84 e0       	ldi	r24, 0x04	; 4
     a90:	8c 93       	st	X, r24
     a92:	08 95       	ret
     a94:	64 ff       	sbrs	r22, 4
     a96:	03 c0       	rjmp	.+6      	; 0xa9e <__unpack_f+0xbe>
     a98:	81 e0       	ldi	r24, 0x01	; 1
     a9a:	8c 93       	st	X, r24
     a9c:	12 c0       	rjmp	.+36     	; 0xac2 <__unpack_f+0xe2>
     a9e:	1c 92       	st	X, r1
     aa0:	10 c0       	rjmp	.+32     	; 0xac2 <__unpack_f+0xe2>
     aa2:	2f 57       	subi	r18, 0x7F	; 127
     aa4:	30 40       	sbci	r19, 0x00	; 0
     aa6:	13 96       	adiw	r26, 0x03	; 3
     aa8:	3c 93       	st	X, r19
     aaa:	2e 93       	st	-X, r18
     aac:	12 97       	sbiw	r26, 0x02	; 2
     aae:	83 e0       	ldi	r24, 0x03	; 3
     ab0:	8c 93       	st	X, r24
     ab2:	87 e0       	ldi	r24, 0x07	; 7
     ab4:	44 0f       	add	r20, r20
     ab6:	55 1f       	adc	r21, r21
     ab8:	66 1f       	adc	r22, r22
     aba:	77 1f       	adc	r23, r23
     abc:	8a 95       	dec	r24
     abe:	d1 f7       	brne	.-12     	; 0xab4 <__unpack_f+0xd4>
     ac0:	70 64       	ori	r23, 0x40	; 64
     ac2:	14 96       	adiw	r26, 0x04	; 4
     ac4:	4d 93       	st	X+, r20
     ac6:	5d 93       	st	X+, r21
     ac8:	6d 93       	st	X+, r22
     aca:	7c 93       	st	X, r23
     acc:	17 97       	sbiw	r26, 0x07	; 7
     ace:	08 95       	ret

00000ad0 <__fpcmp_parts_f>:
     ad0:	1f 93       	push	r17
     ad2:	dc 01       	movw	r26, r24
     ad4:	fb 01       	movw	r30, r22
     ad6:	9c 91       	ld	r25, X
     ad8:	92 30       	cpi	r25, 0x02	; 2
     ada:	08 f4       	brcc	.+2      	; 0xade <__fpcmp_parts_f+0xe>
     adc:	47 c0       	rjmp	.+142    	; 0xb6c <__fpcmp_parts_f+0x9c>
     ade:	80 81       	ld	r24, Z
     ae0:	82 30       	cpi	r24, 0x02	; 2
     ae2:	08 f4       	brcc	.+2      	; 0xae6 <__fpcmp_parts_f+0x16>
     ae4:	43 c0       	rjmp	.+134    	; 0xb6c <__fpcmp_parts_f+0x9c>
     ae6:	94 30       	cpi	r25, 0x04	; 4
     ae8:	51 f4       	brne	.+20     	; 0xafe <__fpcmp_parts_f+0x2e>
     aea:	11 96       	adiw	r26, 0x01	; 1
     aec:	1c 91       	ld	r17, X
     aee:	84 30       	cpi	r24, 0x04	; 4
     af0:	99 f5       	brne	.+102    	; 0xb58 <__fpcmp_parts_f+0x88>
     af2:	81 81       	ldd	r24, Z+1	; 0x01
     af4:	68 2f       	mov	r22, r24
     af6:	70 e0       	ldi	r23, 0x00	; 0
     af8:	61 1b       	sub	r22, r17
     afa:	71 09       	sbc	r23, r1
     afc:	3f c0       	rjmp	.+126    	; 0xb7c <__fpcmp_parts_f+0xac>
     afe:	84 30       	cpi	r24, 0x04	; 4
     b00:	21 f0       	breq	.+8      	; 0xb0a <__fpcmp_parts_f+0x3a>
     b02:	92 30       	cpi	r25, 0x02	; 2
     b04:	31 f4       	brne	.+12     	; 0xb12 <__fpcmp_parts_f+0x42>
     b06:	82 30       	cpi	r24, 0x02	; 2
     b08:	b9 f1       	breq	.+110    	; 0xb78 <__fpcmp_parts_f+0xa8>
     b0a:	81 81       	ldd	r24, Z+1	; 0x01
     b0c:	88 23       	and	r24, r24
     b0e:	89 f1       	breq	.+98     	; 0xb72 <__fpcmp_parts_f+0xa2>
     b10:	2d c0       	rjmp	.+90     	; 0xb6c <__fpcmp_parts_f+0x9c>
     b12:	11 96       	adiw	r26, 0x01	; 1
     b14:	1c 91       	ld	r17, X
     b16:	11 97       	sbiw	r26, 0x01	; 1
     b18:	82 30       	cpi	r24, 0x02	; 2
     b1a:	f1 f0       	breq	.+60     	; 0xb58 <__fpcmp_parts_f+0x88>
     b1c:	81 81       	ldd	r24, Z+1	; 0x01
     b1e:	18 17       	cp	r17, r24
     b20:	d9 f4       	brne	.+54     	; 0xb58 <__fpcmp_parts_f+0x88>
     b22:	12 96       	adiw	r26, 0x02	; 2
     b24:	2d 91       	ld	r18, X+
     b26:	3c 91       	ld	r19, X
     b28:	13 97       	sbiw	r26, 0x03	; 3
     b2a:	82 81       	ldd	r24, Z+2	; 0x02
     b2c:	93 81       	ldd	r25, Z+3	; 0x03
     b2e:	82 17       	cp	r24, r18
     b30:	93 07       	cpc	r25, r19
     b32:	94 f0       	brlt	.+36     	; 0xb58 <__fpcmp_parts_f+0x88>
     b34:	28 17       	cp	r18, r24
     b36:	39 07       	cpc	r19, r25
     b38:	bc f0       	brlt	.+46     	; 0xb68 <__fpcmp_parts_f+0x98>
     b3a:	14 96       	adiw	r26, 0x04	; 4
     b3c:	8d 91       	ld	r24, X+
     b3e:	9d 91       	ld	r25, X+
     b40:	0d 90       	ld	r0, X+
     b42:	bc 91       	ld	r27, X
     b44:	a0 2d       	mov	r26, r0
     b46:	24 81       	ldd	r18, Z+4	; 0x04
     b48:	35 81       	ldd	r19, Z+5	; 0x05
     b4a:	46 81       	ldd	r20, Z+6	; 0x06
     b4c:	57 81       	ldd	r21, Z+7	; 0x07
     b4e:	28 17       	cp	r18, r24
     b50:	39 07       	cpc	r19, r25
     b52:	4a 07       	cpc	r20, r26
     b54:	5b 07       	cpc	r21, r27
     b56:	18 f4       	brcc	.+6      	; 0xb5e <__fpcmp_parts_f+0x8e>
     b58:	11 23       	and	r17, r17
     b5a:	41 f0       	breq	.+16     	; 0xb6c <__fpcmp_parts_f+0x9c>
     b5c:	0a c0       	rjmp	.+20     	; 0xb72 <__fpcmp_parts_f+0xa2>
     b5e:	82 17       	cp	r24, r18
     b60:	93 07       	cpc	r25, r19
     b62:	a4 07       	cpc	r26, r20
     b64:	b5 07       	cpc	r27, r21
     b66:	40 f4       	brcc	.+16     	; 0xb78 <__fpcmp_parts_f+0xa8>
     b68:	11 23       	and	r17, r17
     b6a:	19 f0       	breq	.+6      	; 0xb72 <__fpcmp_parts_f+0xa2>
     b6c:	61 e0       	ldi	r22, 0x01	; 1
     b6e:	70 e0       	ldi	r23, 0x00	; 0
     b70:	05 c0       	rjmp	.+10     	; 0xb7c <__fpcmp_parts_f+0xac>
     b72:	6f ef       	ldi	r22, 0xFF	; 255
     b74:	7f ef       	ldi	r23, 0xFF	; 255
     b76:	02 c0       	rjmp	.+4      	; 0xb7c <__fpcmp_parts_f+0xac>
     b78:	60 e0       	ldi	r22, 0x00	; 0
     b7a:	70 e0       	ldi	r23, 0x00	; 0
     b7c:	cb 01       	movw	r24, r22
     b7e:	1f 91       	pop	r17
     b80:	08 95       	ret

00000b82 <ADC_Init>:
#include "BIT_MATH.h"
#include "ADC_interface.h"
#include "ADC_register.h"

void ADC_Init (void)
{
     b82:	df 93       	push	r29
     b84:	cf 93       	push	r28
     b86:	cd b7       	in	r28, 0x3d	; 61
     b88:	de b7       	in	r29, 0x3e	; 62
	//enable adc
	SET_BIT(ADCSRA_Reg,7);
     b8a:	a6 e2       	ldi	r26, 0x26	; 38
     b8c:	b0 e0       	ldi	r27, 0x00	; 0
     b8e:	e6 e2       	ldi	r30, 0x26	; 38
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	80 81       	ld	r24, Z
     b94:	80 68       	ori	r24, 0x80	; 128
     b96:	8c 93       	st	X, r24

	// ADC Clock
	// Prescaler Configuration as 128
	SET_BIT(ADCSRA_Reg,2);
     b98:	a6 e2       	ldi	r26, 0x26	; 38
     b9a:	b0 e0       	ldi	r27, 0x00	; 0
     b9c:	e6 e2       	ldi	r30, 0x26	; 38
     b9e:	f0 e0       	ldi	r31, 0x00	; 0
     ba0:	80 81       	ld	r24, Z
     ba2:	84 60       	ori	r24, 0x04	; 4
     ba4:	8c 93       	st	X, r24
	SET_BIT(ADCSRA_Reg,1);
     ba6:	a6 e2       	ldi	r26, 0x26	; 38
     ba8:	b0 e0       	ldi	r27, 0x00	; 0
     baa:	e6 e2       	ldi	r30, 0x26	; 38
     bac:	f0 e0       	ldi	r31, 0x00	; 0
     bae:	80 81       	ld	r24, Z
     bb0:	82 60       	ori	r24, 0x02	; 2
     bb2:	8c 93       	st	X, r24
	SET_BIT(ADCSRA_Reg,0);
     bb4:	a6 e2       	ldi	r26, 0x26	; 38
     bb6:	b0 e0       	ldi	r27, 0x00	; 0
     bb8:	e6 e2       	ldi	r30, 0x26	; 38
     bba:	f0 e0       	ldi	r31, 0x00	; 0
     bbc:	80 81       	ld	r24, Z
     bbe:	81 60       	ori	r24, 0x01	; 1
     bc0:	8c 93       	st	X, r24

	//V refrence
	SET_BIT(ADMUX_Reg,6);
     bc2:	a7 e2       	ldi	r26, 0x27	; 39
     bc4:	b0 e0       	ldi	r27, 0x00	; 0
     bc6:	e7 e2       	ldi	r30, 0x27	; 39
     bc8:	f0 e0       	ldi	r31, 0x00	; 0
     bca:	80 81       	ld	r24, Z
     bcc:	80 64       	ori	r24, 0x40	; 64
     bce:	8c 93       	st	X, r24
	CLR_BIT(ADMUX_Reg,7);
     bd0:	a7 e2       	ldi	r26, 0x27	; 39
     bd2:	b0 e0       	ldi	r27, 0x00	; 0
     bd4:	e7 e2       	ldi	r30, 0x27	; 39
     bd6:	f0 e0       	ldi	r31, 0x00	; 0
     bd8:	80 81       	ld	r24, Z
     bda:	8f 77       	andi	r24, 0x7F	; 127
     bdc:	8c 93       	st	X, r24

	//Adjustment
	CLR_BIT(ADMUX_Reg,5);
     bde:	a7 e2       	ldi	r26, 0x27	; 39
     be0:	b0 e0       	ldi	r27, 0x00	; 0
     be2:	e7 e2       	ldi	r30, 0x27	; 39
     be4:	f0 e0       	ldi	r31, 0x00	; 0
     be6:	80 81       	ld	r24, Z
     be8:	8f 7d       	andi	r24, 0xDF	; 223
     bea:	8c 93       	st	X, r24

}
     bec:	cf 91       	pop	r28
     bee:	df 91       	pop	r29
     bf0:	08 95       	ret

00000bf2 <ADC_Read>:

u16 ADC_Read (u8 Channel)
{
     bf2:	df 93       	push	r29
     bf4:	cf 93       	push	r28
     bf6:	0f 92       	push	r0
     bf8:	cd b7       	in	r28, 0x3d	; 61
     bfa:	de b7       	in	r29, 0x3e	; 62
     bfc:	89 83       	std	Y+1, r24	; 0x01
	//u16 ADCH;
	//u16 ADCL;
	//u16 ADC;

	//channel select
	ADMUX_Reg &= (~(0x1F));
     bfe:	a7 e2       	ldi	r26, 0x27	; 39
     c00:	b0 e0       	ldi	r27, 0x00	; 0
     c02:	e7 e2       	ldi	r30, 0x27	; 39
     c04:	f0 e0       	ldi	r31, 0x00	; 0
     c06:	80 81       	ld	r24, Z
     c08:	80 7e       	andi	r24, 0xE0	; 224
     c0a:	8c 93       	st	X, r24
	ADMUX_Reg |= Channel;
     c0c:	a7 e2       	ldi	r26, 0x27	; 39
     c0e:	b0 e0       	ldi	r27, 0x00	; 0
     c10:	e7 e2       	ldi	r30, 0x27	; 39
     c12:	f0 e0       	ldi	r31, 0x00	; 0
     c14:	90 81       	ld	r25, Z
     c16:	89 81       	ldd	r24, Y+1	; 0x01
     c18:	89 2b       	or	r24, r25
     c1a:	8c 93       	st	X, r24

	//start conversion
	SET_BIT(ADCSRA_Reg,6);
     c1c:	a6 e2       	ldi	r26, 0x26	; 38
     c1e:	b0 e0       	ldi	r27, 0x00	; 0
     c20:	e6 e2       	ldi	r30, 0x26	; 38
     c22:	f0 e0       	ldi	r31, 0x00	; 0
     c24:	80 81       	ld	r24, Z
     c26:	80 64       	ori	r24, 0x40	; 64
     c28:	8c 93       	st	X, r24

	//wait till flag is raised
	while(!GET_BIT(ADCSRA_Reg,4));
     c2a:	e6 e2       	ldi	r30, 0x26	; 38
     c2c:	f0 e0       	ldi	r31, 0x00	; 0
     c2e:	80 81       	ld	r24, Z
     c30:	82 95       	swap	r24
     c32:	8f 70       	andi	r24, 0x0F	; 15
     c34:	88 2f       	mov	r24, r24
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	81 70       	andi	r24, 0x01	; 1
     c3a:	90 70       	andi	r25, 0x00	; 0
     c3c:	00 97       	sbiw	r24, 0x00	; 0
     c3e:	a9 f3       	breq	.-22     	; 0xc2a <ADC_Read+0x38>
	//ADCL=ADCL_Reg;
	//ADCH=ADCH_Reg;
	//ADC = ADCH<<8 | ADCL;

	//CLEAR ACDIF flag
	SET_BIT(ADCSRA_Reg,4);
     c40:	a6 e2       	ldi	r26, 0x26	; 38
     c42:	b0 e0       	ldi	r27, 0x00	; 0
     c44:	e6 e2       	ldi	r30, 0x26	; 38
     c46:	f0 e0       	ldi	r31, 0x00	; 0
     c48:	80 81       	ld	r24, Z
     c4a:	80 61       	ori	r24, 0x10	; 16
     c4c:	8c 93       	st	X, r24

	//return ADC reading
	return ADC_Reg;
     c4e:	e4 e2       	ldi	r30, 0x24	; 36
     c50:	f0 e0       	ldi	r31, 0x00	; 0
     c52:	80 81       	ld	r24, Z
     c54:	91 81       	ldd	r25, Z+1	; 0x01

}
     c56:	0f 90       	pop	r0
     c58:	cf 91       	pop	r28
     c5a:	df 91       	pop	r29
     c5c:	08 95       	ret

00000c5e <Mappping>:

u32 Mappping (u32 Range1_min,u32 Range1_max,u32 Range1_input,u32 Range2_min,u32 Range2_max){
     c5e:	af 92       	push	r10
     c60:	bf 92       	push	r11
     c62:	cf 92       	push	r12
     c64:	df 92       	push	r13
     c66:	ef 92       	push	r14
     c68:	ff 92       	push	r15
     c6a:	0f 93       	push	r16
     c6c:	1f 93       	push	r17
     c6e:	df 93       	push	r29
     c70:	cf 93       	push	r28
     c72:	cd b7       	in	r28, 0x3d	; 61
     c74:	de b7       	in	r29, 0x3e	; 62
     c76:	64 97       	sbiw	r28, 0x14	; 20
     c78:	0f b6       	in	r0, 0x3f	; 63
     c7a:	f8 94       	cli
     c7c:	de bf       	out	0x3e, r29	; 62
     c7e:	0f be       	out	0x3f, r0	; 63
     c80:	cd bf       	out	0x3d, r28	; 61
     c82:	6d 83       	std	Y+5, r22	; 0x05
     c84:	7e 83       	std	Y+6, r23	; 0x06
     c86:	8f 83       	std	Y+7, r24	; 0x07
     c88:	98 87       	std	Y+8, r25	; 0x08
     c8a:	29 87       	std	Y+9, r18	; 0x09
     c8c:	3a 87       	std	Y+10, r19	; 0x0a
     c8e:	4b 87       	std	Y+11, r20	; 0x0b
     c90:	5c 87       	std	Y+12, r21	; 0x0c
     c92:	ed 86       	std	Y+13, r14	; 0x0d
     c94:	fe 86       	std	Y+14, r15	; 0x0e
     c96:	0f 87       	std	Y+15, r16	; 0x0f
     c98:	18 8b       	std	Y+16, r17	; 0x10
     c9a:	a9 8a       	std	Y+17, r10	; 0x11
     c9c:	ba 8a       	std	Y+18, r11	; 0x12
     c9e:	cb 8a       	std	Y+19, r12	; 0x13
     ca0:	dc 8a       	std	Y+20, r13	; 0x14

	u32 Range2_output=Range2_max-(((Range1_max-Range1_input)*(Range2_max-Range2_min))/(Range1_max-Range1_min));
     ca2:	29 85       	ldd	r18, Y+9	; 0x09
     ca4:	3a 85       	ldd	r19, Y+10	; 0x0a
     ca6:	4b 85       	ldd	r20, Y+11	; 0x0b
     ca8:	5c 85       	ldd	r21, Y+12	; 0x0c
     caa:	8d 85       	ldd	r24, Y+13	; 0x0d
     cac:	9e 85       	ldd	r25, Y+14	; 0x0e
     cae:	af 85       	ldd	r26, Y+15	; 0x0f
     cb0:	b8 89       	ldd	r27, Y+16	; 0x10
     cb2:	79 01       	movw	r14, r18
     cb4:	8a 01       	movw	r16, r20
     cb6:	e8 1a       	sub	r14, r24
     cb8:	f9 0a       	sbc	r15, r25
     cba:	0a 0b       	sbc	r16, r26
     cbc:	1b 0b       	sbc	r17, r27
     cbe:	29 a1       	ldd	r18, Y+33	; 0x21
     cc0:	3a a1       	ldd	r19, Y+34	; 0x22
     cc2:	4b a1       	ldd	r20, Y+35	; 0x23
     cc4:	5c a1       	ldd	r21, Y+36	; 0x24
     cc6:	89 89       	ldd	r24, Y+17	; 0x11
     cc8:	9a 89       	ldd	r25, Y+18	; 0x12
     cca:	ab 89       	ldd	r26, Y+19	; 0x13
     ccc:	bc 89       	ldd	r27, Y+20	; 0x14
     cce:	28 1b       	sub	r18, r24
     cd0:	39 0b       	sbc	r19, r25
     cd2:	4a 0b       	sbc	r20, r26
     cd4:	5b 0b       	sbc	r21, r27
     cd6:	c8 01       	movw	r24, r16
     cd8:	b7 01       	movw	r22, r14
     cda:	0e 94 cc 4c 	call	0x9998	; 0x9998 <__mulsi3>
     cde:	7b 01       	movw	r14, r22
     ce0:	8c 01       	movw	r16, r24
     ce2:	29 85       	ldd	r18, Y+9	; 0x09
     ce4:	3a 85       	ldd	r19, Y+10	; 0x0a
     ce6:	4b 85       	ldd	r20, Y+11	; 0x0b
     ce8:	5c 85       	ldd	r21, Y+12	; 0x0c
     cea:	8d 81       	ldd	r24, Y+5	; 0x05
     cec:	9e 81       	ldd	r25, Y+6	; 0x06
     cee:	af 81       	ldd	r26, Y+7	; 0x07
     cf0:	b8 85       	ldd	r27, Y+8	; 0x08
     cf2:	28 1b       	sub	r18, r24
     cf4:	39 0b       	sbc	r19, r25
     cf6:	4a 0b       	sbc	r20, r26
     cf8:	5b 0b       	sbc	r21, r27
     cfa:	c8 01       	movw	r24, r16
     cfc:	b7 01       	movw	r22, r14
     cfe:	0e 94 12 4d 	call	0x9a24	; 0x9a24 <__udivmodsi4>
     d02:	da 01       	movw	r26, r20
     d04:	c9 01       	movw	r24, r18
     d06:	9c 01       	movw	r18, r24
     d08:	ad 01       	movw	r20, r26
     d0a:	89 a1       	ldd	r24, Y+33	; 0x21
     d0c:	9a a1       	ldd	r25, Y+34	; 0x22
     d0e:	ab a1       	ldd	r26, Y+35	; 0x23
     d10:	bc a1       	ldd	r27, Y+36	; 0x24
     d12:	82 1b       	sub	r24, r18
     d14:	93 0b       	sbc	r25, r19
     d16:	a4 0b       	sbc	r26, r20
     d18:	b5 0b       	sbc	r27, r21
     d1a:	89 83       	std	Y+1, r24	; 0x01
     d1c:	9a 83       	std	Y+2, r25	; 0x02
     d1e:	ab 83       	std	Y+3, r26	; 0x03
     d20:	bc 83       	std	Y+4, r27	; 0x04

	return Range2_output;
     d22:	89 81       	ldd	r24, Y+1	; 0x01
     d24:	9a 81       	ldd	r25, Y+2	; 0x02
     d26:	ab 81       	ldd	r26, Y+3	; 0x03
     d28:	bc 81       	ldd	r27, Y+4	; 0x04


}
     d2a:	bc 01       	movw	r22, r24
     d2c:	cd 01       	movw	r24, r26
     d2e:	64 96       	adiw	r28, 0x14	; 20
     d30:	0f b6       	in	r0, 0x3f	; 63
     d32:	f8 94       	cli
     d34:	de bf       	out	0x3e, r29	; 62
     d36:	0f be       	out	0x3f, r0	; 63
     d38:	cd bf       	out	0x3d, r28	; 61
     d3a:	cf 91       	pop	r28
     d3c:	df 91       	pop	r29
     d3e:	1f 91       	pop	r17
     d40:	0f 91       	pop	r16
     d42:	ff 90       	pop	r15
     d44:	ef 90       	pop	r14
     d46:	df 90       	pop	r13
     d48:	cf 90       	pop	r12
     d4a:	bf 90       	pop	r11
     d4c:	af 90       	pop	r10
     d4e:	08 95       	ret

00000d50 <DIO_voidSetPinValue>:
#include "BIT_MATH.h"
#include "DIO_register.h"
#include "DIO_interface.h"

void DIO_voidSetPinValue(u8 u8PortIdCopy,u8 u8PinIdCopy,u8 u8PinValCopy)
{
     d50:	df 93       	push	r29
     d52:	cf 93       	push	r28
     d54:	cd b7       	in	r28, 0x3d	; 61
     d56:	de b7       	in	r29, 0x3e	; 62
     d58:	27 97       	sbiw	r28, 0x07	; 7
     d5a:	0f b6       	in	r0, 0x3f	; 63
     d5c:	f8 94       	cli
     d5e:	de bf       	out	0x3e, r29	; 62
     d60:	0f be       	out	0x3f, r0	; 63
     d62:	cd bf       	out	0x3d, r28	; 61
     d64:	89 83       	std	Y+1, r24	; 0x01
     d66:	6a 83       	std	Y+2, r22	; 0x02
     d68:	4b 83       	std	Y+3, r20	; 0x03
	if ((u8PortIdCopy <= PORTD) && (u8PinIdCopy <= PIN7))
     d6a:	89 81       	ldd	r24, Y+1	; 0x01
     d6c:	84 30       	cpi	r24, 0x04	; 4
     d6e:	08 f0       	brcs	.+2      	; 0xd72 <DIO_voidSetPinValue+0x22>
     d70:	ee c0       	rjmp	.+476    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
     d72:	8a 81       	ldd	r24, Y+2	; 0x02
     d74:	88 30       	cpi	r24, 0x08	; 8
     d76:	08 f0       	brcs	.+2      	; 0xd7a <DIO_voidSetPinValue+0x2a>
     d78:	ea c0       	rjmp	.+468    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
	{
		if ( u8PinValCopy == PIN_HIGH )
     d7a:	8b 81       	ldd	r24, Y+3	; 0x03
     d7c:	81 30       	cpi	r24, 0x01	; 1
     d7e:	09 f0       	breq	.+2      	; 0xd82 <DIO_voidSetPinValue+0x32>
     d80:	6f c0       	rjmp	.+222    	; 0xe60 <DIO_voidSetPinValue+0x110>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
     d82:	89 81       	ldd	r24, Y+1	; 0x01
     d84:	28 2f       	mov	r18, r24
     d86:	30 e0       	ldi	r19, 0x00	; 0
     d88:	3f 83       	std	Y+7, r19	; 0x07
     d8a:	2e 83       	std	Y+6, r18	; 0x06
     d8c:	8e 81       	ldd	r24, Y+6	; 0x06
     d8e:	9f 81       	ldd	r25, Y+7	; 0x07
     d90:	81 30       	cpi	r24, 0x01	; 1
     d92:	91 05       	cpc	r25, r1
     d94:	49 f1       	breq	.+82     	; 0xde8 <DIO_voidSetPinValue+0x98>
     d96:	2e 81       	ldd	r18, Y+6	; 0x06
     d98:	3f 81       	ldd	r19, Y+7	; 0x07
     d9a:	22 30       	cpi	r18, 0x02	; 2
     d9c:	31 05       	cpc	r19, r1
     d9e:	2c f4       	brge	.+10     	; 0xdaa <DIO_voidSetPinValue+0x5a>
     da0:	8e 81       	ldd	r24, Y+6	; 0x06
     da2:	9f 81       	ldd	r25, Y+7	; 0x07
     da4:	00 97       	sbiw	r24, 0x00	; 0
     da6:	61 f0       	breq	.+24     	; 0xdc0 <DIO_voidSetPinValue+0x70>
     da8:	d2 c0       	rjmp	.+420    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
     daa:	2e 81       	ldd	r18, Y+6	; 0x06
     dac:	3f 81       	ldd	r19, Y+7	; 0x07
     dae:	22 30       	cpi	r18, 0x02	; 2
     db0:	31 05       	cpc	r19, r1
     db2:	71 f1       	breq	.+92     	; 0xe10 <DIO_voidSetPinValue+0xc0>
     db4:	8e 81       	ldd	r24, Y+6	; 0x06
     db6:	9f 81       	ldd	r25, Y+7	; 0x07
     db8:	83 30       	cpi	r24, 0x03	; 3
     dba:	91 05       	cpc	r25, r1
     dbc:	e9 f1       	breq	.+122    	; 0xe38 <DIO_voidSetPinValue+0xe8>
     dbe:	c7 c0       	rjmp	.+398    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
			{
			case PORTA: SET_BIT(PORTA_Register,u8PinIdCopy); break;
     dc0:	ab e3       	ldi	r26, 0x3B	; 59
     dc2:	b0 e0       	ldi	r27, 0x00	; 0
     dc4:	eb e3       	ldi	r30, 0x3B	; 59
     dc6:	f0 e0       	ldi	r31, 0x00	; 0
     dc8:	80 81       	ld	r24, Z
     dca:	48 2f       	mov	r20, r24
     dcc:	8a 81       	ldd	r24, Y+2	; 0x02
     dce:	28 2f       	mov	r18, r24
     dd0:	30 e0       	ldi	r19, 0x00	; 0
     dd2:	81 e0       	ldi	r24, 0x01	; 1
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	02 2e       	mov	r0, r18
     dd8:	02 c0       	rjmp	.+4      	; 0xdde <DIO_voidSetPinValue+0x8e>
     dda:	88 0f       	add	r24, r24
     ddc:	99 1f       	adc	r25, r25
     dde:	0a 94       	dec	r0
     de0:	e2 f7       	brpl	.-8      	; 0xdda <DIO_voidSetPinValue+0x8a>
     de2:	84 2b       	or	r24, r20
     de4:	8c 93       	st	X, r24
     de6:	b3 c0       	rjmp	.+358    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
			case PORTB: SET_BIT(PORTB_Register,u8PinIdCopy); break;
     de8:	a8 e3       	ldi	r26, 0x38	; 56
     dea:	b0 e0       	ldi	r27, 0x00	; 0
     dec:	e8 e3       	ldi	r30, 0x38	; 56
     dee:	f0 e0       	ldi	r31, 0x00	; 0
     df0:	80 81       	ld	r24, Z
     df2:	48 2f       	mov	r20, r24
     df4:	8a 81       	ldd	r24, Y+2	; 0x02
     df6:	28 2f       	mov	r18, r24
     df8:	30 e0       	ldi	r19, 0x00	; 0
     dfa:	81 e0       	ldi	r24, 0x01	; 1
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	02 2e       	mov	r0, r18
     e00:	02 c0       	rjmp	.+4      	; 0xe06 <DIO_voidSetPinValue+0xb6>
     e02:	88 0f       	add	r24, r24
     e04:	99 1f       	adc	r25, r25
     e06:	0a 94       	dec	r0
     e08:	e2 f7       	brpl	.-8      	; 0xe02 <DIO_voidSetPinValue+0xb2>
     e0a:	84 2b       	or	r24, r20
     e0c:	8c 93       	st	X, r24
     e0e:	9f c0       	rjmp	.+318    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
			case PORTC: SET_BIT(PORTC_Register,u8PinIdCopy); break;
     e10:	a5 e3       	ldi	r26, 0x35	; 53
     e12:	b0 e0       	ldi	r27, 0x00	; 0
     e14:	e5 e3       	ldi	r30, 0x35	; 53
     e16:	f0 e0       	ldi	r31, 0x00	; 0
     e18:	80 81       	ld	r24, Z
     e1a:	48 2f       	mov	r20, r24
     e1c:	8a 81       	ldd	r24, Y+2	; 0x02
     e1e:	28 2f       	mov	r18, r24
     e20:	30 e0       	ldi	r19, 0x00	; 0
     e22:	81 e0       	ldi	r24, 0x01	; 1
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	02 2e       	mov	r0, r18
     e28:	02 c0       	rjmp	.+4      	; 0xe2e <DIO_voidSetPinValue+0xde>
     e2a:	88 0f       	add	r24, r24
     e2c:	99 1f       	adc	r25, r25
     e2e:	0a 94       	dec	r0
     e30:	e2 f7       	brpl	.-8      	; 0xe2a <DIO_voidSetPinValue+0xda>
     e32:	84 2b       	or	r24, r20
     e34:	8c 93       	st	X, r24
     e36:	8b c0       	rjmp	.+278    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
			case PORTD: SET_BIT(PORTD_Register,u8PinIdCopy); break;
     e38:	a2 e3       	ldi	r26, 0x32	; 50
     e3a:	b0 e0       	ldi	r27, 0x00	; 0
     e3c:	e2 e3       	ldi	r30, 0x32	; 50
     e3e:	f0 e0       	ldi	r31, 0x00	; 0
     e40:	80 81       	ld	r24, Z
     e42:	48 2f       	mov	r20, r24
     e44:	8a 81       	ldd	r24, Y+2	; 0x02
     e46:	28 2f       	mov	r18, r24
     e48:	30 e0       	ldi	r19, 0x00	; 0
     e4a:	81 e0       	ldi	r24, 0x01	; 1
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	02 2e       	mov	r0, r18
     e50:	02 c0       	rjmp	.+4      	; 0xe56 <DIO_voidSetPinValue+0x106>
     e52:	88 0f       	add	r24, r24
     e54:	99 1f       	adc	r25, r25
     e56:	0a 94       	dec	r0
     e58:	e2 f7       	brpl	.-8      	; 0xe52 <DIO_voidSetPinValue+0x102>
     e5a:	84 2b       	or	r24, r20
     e5c:	8c 93       	st	X, r24
     e5e:	77 c0       	rjmp	.+238    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
		    default : break;
			}
		}

		else if ( u8PinValCopy == PIN_LOW )
     e60:	8b 81       	ldd	r24, Y+3	; 0x03
     e62:	88 23       	and	r24, r24
     e64:	09 f0       	breq	.+2      	; 0xe68 <DIO_voidSetPinValue+0x118>
     e66:	73 c0       	rjmp	.+230    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
     e68:	89 81       	ldd	r24, Y+1	; 0x01
     e6a:	28 2f       	mov	r18, r24
     e6c:	30 e0       	ldi	r19, 0x00	; 0
     e6e:	3d 83       	std	Y+5, r19	; 0x05
     e70:	2c 83       	std	Y+4, r18	; 0x04
     e72:	8c 81       	ldd	r24, Y+4	; 0x04
     e74:	9d 81       	ldd	r25, Y+5	; 0x05
     e76:	81 30       	cpi	r24, 0x01	; 1
     e78:	91 05       	cpc	r25, r1
     e7a:	59 f1       	breq	.+86     	; 0xed2 <DIO_voidSetPinValue+0x182>
     e7c:	2c 81       	ldd	r18, Y+4	; 0x04
     e7e:	3d 81       	ldd	r19, Y+5	; 0x05
     e80:	22 30       	cpi	r18, 0x02	; 2
     e82:	31 05       	cpc	r19, r1
     e84:	2c f4       	brge	.+10     	; 0xe90 <DIO_voidSetPinValue+0x140>
     e86:	8c 81       	ldd	r24, Y+4	; 0x04
     e88:	9d 81       	ldd	r25, Y+5	; 0x05
     e8a:	00 97       	sbiw	r24, 0x00	; 0
     e8c:	69 f0       	breq	.+26     	; 0xea8 <DIO_voidSetPinValue+0x158>
     e8e:	5f c0       	rjmp	.+190    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
     e90:	2c 81       	ldd	r18, Y+4	; 0x04
     e92:	3d 81       	ldd	r19, Y+5	; 0x05
     e94:	22 30       	cpi	r18, 0x02	; 2
     e96:	31 05       	cpc	r19, r1
     e98:	89 f1       	breq	.+98     	; 0xefc <DIO_voidSetPinValue+0x1ac>
     e9a:	8c 81       	ldd	r24, Y+4	; 0x04
     e9c:	9d 81       	ldd	r25, Y+5	; 0x05
     e9e:	83 30       	cpi	r24, 0x03	; 3
     ea0:	91 05       	cpc	r25, r1
     ea2:	09 f4       	brne	.+2      	; 0xea6 <DIO_voidSetPinValue+0x156>
     ea4:	40 c0       	rjmp	.+128    	; 0xf26 <DIO_voidSetPinValue+0x1d6>
     ea6:	53 c0       	rjmp	.+166    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
			{
			case PORTA: CLR_BIT(PORTA_Register,u8PinIdCopy); break;
     ea8:	ab e3       	ldi	r26, 0x3B	; 59
     eaa:	b0 e0       	ldi	r27, 0x00	; 0
     eac:	eb e3       	ldi	r30, 0x3B	; 59
     eae:	f0 e0       	ldi	r31, 0x00	; 0
     eb0:	80 81       	ld	r24, Z
     eb2:	48 2f       	mov	r20, r24
     eb4:	8a 81       	ldd	r24, Y+2	; 0x02
     eb6:	28 2f       	mov	r18, r24
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	81 e0       	ldi	r24, 0x01	; 1
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	02 2e       	mov	r0, r18
     ec0:	02 c0       	rjmp	.+4      	; 0xec6 <DIO_voidSetPinValue+0x176>
     ec2:	88 0f       	add	r24, r24
     ec4:	99 1f       	adc	r25, r25
     ec6:	0a 94       	dec	r0
     ec8:	e2 f7       	brpl	.-8      	; 0xec2 <DIO_voidSetPinValue+0x172>
     eca:	80 95       	com	r24
     ecc:	84 23       	and	r24, r20
     ece:	8c 93       	st	X, r24
     ed0:	3e c0       	rjmp	.+124    	; 0xf4e <DIO_voidSetPinValue+0x1fe>
			case PORTB: CLR_BIT(PORTB_Register,u8PinIdCopy); break;
     ed2:	a8 e3       	ldi	r26, 0x38	; 56
     ed4:	b0 e0       	ldi	r27, 0x00	; 0
     ed6:	e8 e3       	ldi	r30, 0x38	; 56
     ed8:	f0 e0       	ldi	r31, 0x00	; 0
     eda:	80 81       	ld	r24, Z
     edc:	48 2f       	mov	r20, r24
     ede:	8a 81       	ldd	r24, Y+2	; 0x02
     ee0:	28 2f       	mov	r18, r24
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	81 e0       	ldi	r24, 0x01	; 1
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	02 2e       	mov	r0, r18
     eea:	02 c0       	rjmp	.+4      	; 0xef0 <DIO_voidSetPinValue+0x1a0>
     eec:	88 0f       	add	r24, r24
     eee:	99 1f       	adc	r25, r25
     ef0:	0a 94       	dec	r0
     ef2:	e2 f7       	brpl	.-8      	; 0xeec <DIO_voidSetPinValue+0x19c>
     ef4:	80 95       	com	r24
     ef6:	84 23       	and	r24, r20
     ef8:	8c 93       	st	X, r24
     efa:	29 c0       	rjmp	.+82     	; 0xf4e <DIO_voidSetPinValue+0x1fe>
			case PORTC: CLR_BIT(PORTC_Register,u8PinIdCopy); break;
     efc:	a5 e3       	ldi	r26, 0x35	; 53
     efe:	b0 e0       	ldi	r27, 0x00	; 0
     f00:	e5 e3       	ldi	r30, 0x35	; 53
     f02:	f0 e0       	ldi	r31, 0x00	; 0
     f04:	80 81       	ld	r24, Z
     f06:	48 2f       	mov	r20, r24
     f08:	8a 81       	ldd	r24, Y+2	; 0x02
     f0a:	28 2f       	mov	r18, r24
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	81 e0       	ldi	r24, 0x01	; 1
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	02 2e       	mov	r0, r18
     f14:	02 c0       	rjmp	.+4      	; 0xf1a <DIO_voidSetPinValue+0x1ca>
     f16:	88 0f       	add	r24, r24
     f18:	99 1f       	adc	r25, r25
     f1a:	0a 94       	dec	r0
     f1c:	e2 f7       	brpl	.-8      	; 0xf16 <DIO_voidSetPinValue+0x1c6>
     f1e:	80 95       	com	r24
     f20:	84 23       	and	r24, r20
     f22:	8c 93       	st	X, r24
     f24:	14 c0       	rjmp	.+40     	; 0xf4e <DIO_voidSetPinValue+0x1fe>
			case PORTD: CLR_BIT(PORTD_Register,u8PinIdCopy); break;
     f26:	a2 e3       	ldi	r26, 0x32	; 50
     f28:	b0 e0       	ldi	r27, 0x00	; 0
     f2a:	e2 e3       	ldi	r30, 0x32	; 50
     f2c:	f0 e0       	ldi	r31, 0x00	; 0
     f2e:	80 81       	ld	r24, Z
     f30:	48 2f       	mov	r20, r24
     f32:	8a 81       	ldd	r24, Y+2	; 0x02
     f34:	28 2f       	mov	r18, r24
     f36:	30 e0       	ldi	r19, 0x00	; 0
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	90 e0       	ldi	r25, 0x00	; 0
     f3c:	02 2e       	mov	r0, r18
     f3e:	02 c0       	rjmp	.+4      	; 0xf44 <DIO_voidSetPinValue+0x1f4>
     f40:	88 0f       	add	r24, r24
     f42:	99 1f       	adc	r25, r25
     f44:	0a 94       	dec	r0
     f46:	e2 f7       	brpl	.-8      	; 0xf40 <DIO_voidSetPinValue+0x1f0>
     f48:	80 95       	com	r24
     f4a:	84 23       	and	r24, r20
     f4c:	8c 93       	st	X, r24
		{
			/* Do nothing, Wrong Direction Required */
		}
	}

}
     f4e:	27 96       	adiw	r28, 0x07	; 7
     f50:	0f b6       	in	r0, 0x3f	; 63
     f52:	f8 94       	cli
     f54:	de bf       	out	0x3e, r29	; 62
     f56:	0f be       	out	0x3f, r0	; 63
     f58:	cd bf       	out	0x3d, r28	; 61
     f5a:	cf 91       	pop	r28
     f5c:	df 91       	pop	r29
     f5e:	08 95       	ret

00000f60 <DIO_u8GetPinValue>:
u8 DIO_u8GetPinValue(u8 u8PortIdCopy,u8 u8PinIdCopy)
{
     f60:	df 93       	push	r29
     f62:	cf 93       	push	r28
     f64:	00 d0       	rcall	.+0      	; 0xf66 <DIO_u8GetPinValue+0x6>
     f66:	00 d0       	rcall	.+0      	; 0xf68 <DIO_u8GetPinValue+0x8>
     f68:	0f 92       	push	r0
     f6a:	cd b7       	in	r28, 0x3d	; 61
     f6c:	de b7       	in	r29, 0x3e	; 62
     f6e:	8a 83       	std	Y+2, r24	; 0x02
     f70:	6b 83       	std	Y+3, r22	; 0x03
	u8 u8Valuecopy;

	if ((u8PortIdCopy <= PORTD) && (u8PinIdCopy <= PIN7))
     f72:	8a 81       	ldd	r24, Y+2	; 0x02
     f74:	84 30       	cpi	r24, 0x04	; 4
     f76:	08 f0       	brcs	.+2      	; 0xf7a <DIO_u8GetPinValue+0x1a>
     f78:	6b c0       	rjmp	.+214    	; 0x1050 <DIO_u8GetPinValue+0xf0>
     f7a:	8b 81       	ldd	r24, Y+3	; 0x03
     f7c:	88 30       	cpi	r24, 0x08	; 8
     f7e:	08 f0       	brcs	.+2      	; 0xf82 <DIO_u8GetPinValue+0x22>
     f80:	67 c0       	rjmp	.+206    	; 0x1050 <DIO_u8GetPinValue+0xf0>
	{
		/* Check on the Required PORT Number */
		switch (u8PortIdCopy)
     f82:	8a 81       	ldd	r24, Y+2	; 0x02
     f84:	28 2f       	mov	r18, r24
     f86:	30 e0       	ldi	r19, 0x00	; 0
     f88:	3d 83       	std	Y+5, r19	; 0x05
     f8a:	2c 83       	std	Y+4, r18	; 0x04
     f8c:	4c 81       	ldd	r20, Y+4	; 0x04
     f8e:	5d 81       	ldd	r21, Y+5	; 0x05
     f90:	41 30       	cpi	r20, 0x01	; 1
     f92:	51 05       	cpc	r21, r1
     f94:	41 f1       	breq	.+80     	; 0xfe6 <DIO_u8GetPinValue+0x86>
     f96:	8c 81       	ldd	r24, Y+4	; 0x04
     f98:	9d 81       	ldd	r25, Y+5	; 0x05
     f9a:	82 30       	cpi	r24, 0x02	; 2
     f9c:	91 05       	cpc	r25, r1
     f9e:	34 f4       	brge	.+12     	; 0xfac <DIO_u8GetPinValue+0x4c>
     fa0:	2c 81       	ldd	r18, Y+4	; 0x04
     fa2:	3d 81       	ldd	r19, Y+5	; 0x05
     fa4:	21 15       	cp	r18, r1
     fa6:	31 05       	cpc	r19, r1
     fa8:	61 f0       	breq	.+24     	; 0xfc2 <DIO_u8GetPinValue+0x62>
     faa:	52 c0       	rjmp	.+164    	; 0x1050 <DIO_u8GetPinValue+0xf0>
     fac:	4c 81       	ldd	r20, Y+4	; 0x04
     fae:	5d 81       	ldd	r21, Y+5	; 0x05
     fb0:	42 30       	cpi	r20, 0x02	; 2
     fb2:	51 05       	cpc	r21, r1
     fb4:	51 f1       	breq	.+84     	; 0x100a <DIO_u8GetPinValue+0xaa>
     fb6:	8c 81       	ldd	r24, Y+4	; 0x04
     fb8:	9d 81       	ldd	r25, Y+5	; 0x05
     fba:	83 30       	cpi	r24, 0x03	; 3
     fbc:	91 05       	cpc	r25, r1
     fbe:	b9 f1       	breq	.+110    	; 0x102e <DIO_u8GetPinValue+0xce>
     fc0:	47 c0       	rjmp	.+142    	; 0x1050 <DIO_u8GetPinValue+0xf0>
		{
		case PORTA: u8Valuecopy = GET_BIT(PINA_Register,u8PinIdCopy); break;
     fc2:	e9 e3       	ldi	r30, 0x39	; 57
     fc4:	f0 e0       	ldi	r31, 0x00	; 0
     fc6:	80 81       	ld	r24, Z
     fc8:	28 2f       	mov	r18, r24
     fca:	30 e0       	ldi	r19, 0x00	; 0
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	88 2f       	mov	r24, r24
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	a9 01       	movw	r20, r18
     fd4:	02 c0       	rjmp	.+4      	; 0xfda <DIO_u8GetPinValue+0x7a>
     fd6:	55 95       	asr	r21
     fd8:	47 95       	ror	r20
     fda:	8a 95       	dec	r24
     fdc:	e2 f7       	brpl	.-8      	; 0xfd6 <DIO_u8GetPinValue+0x76>
     fde:	ca 01       	movw	r24, r20
     fe0:	81 70       	andi	r24, 0x01	; 1
     fe2:	89 83       	std	Y+1, r24	; 0x01
     fe4:	35 c0       	rjmp	.+106    	; 0x1050 <DIO_u8GetPinValue+0xf0>
		case PORTB: u8Valuecopy = GET_BIT(PINB_Register,u8PinIdCopy); break;
     fe6:	e6 e3       	ldi	r30, 0x36	; 54
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	80 81       	ld	r24, Z
     fec:	28 2f       	mov	r18, r24
     fee:	30 e0       	ldi	r19, 0x00	; 0
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	88 2f       	mov	r24, r24
     ff4:	90 e0       	ldi	r25, 0x00	; 0
     ff6:	a9 01       	movw	r20, r18
     ff8:	02 c0       	rjmp	.+4      	; 0xffe <DIO_u8GetPinValue+0x9e>
     ffa:	55 95       	asr	r21
     ffc:	47 95       	ror	r20
     ffe:	8a 95       	dec	r24
    1000:	e2 f7       	brpl	.-8      	; 0xffa <DIO_u8GetPinValue+0x9a>
    1002:	ca 01       	movw	r24, r20
    1004:	81 70       	andi	r24, 0x01	; 1
    1006:	89 83       	std	Y+1, r24	; 0x01
    1008:	23 c0       	rjmp	.+70     	; 0x1050 <DIO_u8GetPinValue+0xf0>
		case PORTC: u8Valuecopy = GET_BIT(PINC_Register,u8PinIdCopy); break;
    100a:	e3 e3       	ldi	r30, 0x33	; 51
    100c:	f0 e0       	ldi	r31, 0x00	; 0
    100e:	80 81       	ld	r24, Z
    1010:	28 2f       	mov	r18, r24
    1012:	30 e0       	ldi	r19, 0x00	; 0
    1014:	8b 81       	ldd	r24, Y+3	; 0x03
    1016:	88 2f       	mov	r24, r24
    1018:	90 e0       	ldi	r25, 0x00	; 0
    101a:	a9 01       	movw	r20, r18
    101c:	02 c0       	rjmp	.+4      	; 0x1022 <DIO_u8GetPinValue+0xc2>
    101e:	55 95       	asr	r21
    1020:	47 95       	ror	r20
    1022:	8a 95       	dec	r24
    1024:	e2 f7       	brpl	.-8      	; 0x101e <DIO_u8GetPinValue+0xbe>
    1026:	ca 01       	movw	r24, r20
    1028:	81 70       	andi	r24, 0x01	; 1
    102a:	89 83       	std	Y+1, r24	; 0x01
    102c:	11 c0       	rjmp	.+34     	; 0x1050 <DIO_u8GetPinValue+0xf0>
		case PORTD: u8Valuecopy = GET_BIT(PIND_Register,u8PinIdCopy); break;
    102e:	e0 e3       	ldi	r30, 0x30	; 48
    1030:	f0 e0       	ldi	r31, 0x00	; 0
    1032:	80 81       	ld	r24, Z
    1034:	28 2f       	mov	r18, r24
    1036:	30 e0       	ldi	r19, 0x00	; 0
    1038:	8b 81       	ldd	r24, Y+3	; 0x03
    103a:	88 2f       	mov	r24, r24
    103c:	90 e0       	ldi	r25, 0x00	; 0
    103e:	a9 01       	movw	r20, r18
    1040:	02 c0       	rjmp	.+4      	; 0x1046 <DIO_u8GetPinValue+0xe6>
    1042:	55 95       	asr	r21
    1044:	47 95       	ror	r20
    1046:	8a 95       	dec	r24
    1048:	e2 f7       	brpl	.-8      	; 0x1042 <DIO_u8GetPinValue+0xe2>
    104a:	ca 01       	movw	r24, r20
    104c:	81 70       	andi	r24, 0x01	; 1
    104e:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		/* Do nothing, Wrong Direction Required */
	}

	return u8Valuecopy;
    1050:	89 81       	ldd	r24, Y+1	; 0x01

}
    1052:	0f 90       	pop	r0
    1054:	0f 90       	pop	r0
    1056:	0f 90       	pop	r0
    1058:	0f 90       	pop	r0
    105a:	0f 90       	pop	r0
    105c:	cf 91       	pop	r28
    105e:	df 91       	pop	r29
    1060:	08 95       	ret

00001062 <DIO_voidSetPinDirection>:
void DIO_voidSetPinDirection(u8 u8PortIdCopy,u8 u8PinIdCopy,u8 u8PinDirCopy)
{
    1062:	df 93       	push	r29
    1064:	cf 93       	push	r28
    1066:	cd b7       	in	r28, 0x3d	; 61
    1068:	de b7       	in	r29, 0x3e	; 62
    106a:	27 97       	sbiw	r28, 0x07	; 7
    106c:	0f b6       	in	r0, 0x3f	; 63
    106e:	f8 94       	cli
    1070:	de bf       	out	0x3e, r29	; 62
    1072:	0f be       	out	0x3f, r0	; 63
    1074:	cd bf       	out	0x3d, r28	; 61
    1076:	89 83       	std	Y+1, r24	; 0x01
    1078:	6a 83       	std	Y+2, r22	; 0x02
    107a:	4b 83       	std	Y+3, r20	; 0x03
	if ((u8PortIdCopy <= PORTD) && (u8PinIdCopy <= PIN7))
    107c:	89 81       	ldd	r24, Y+1	; 0x01
    107e:	84 30       	cpi	r24, 0x04	; 4
    1080:	08 f0       	brcs	.+2      	; 0x1084 <DIO_voidSetPinDirection+0x22>
    1082:	ee c0       	rjmp	.+476    	; 0x1260 <__stack+0x161>
    1084:	8a 81       	ldd	r24, Y+2	; 0x02
    1086:	88 30       	cpi	r24, 0x08	; 8
    1088:	08 f0       	brcs	.+2      	; 0x108c <DIO_voidSetPinDirection+0x2a>
    108a:	ea c0       	rjmp	.+468    	; 0x1260 <__stack+0x161>
	{
		if ( u8PinDirCopy == PIN_OUTPUT )
    108c:	8b 81       	ldd	r24, Y+3	; 0x03
    108e:	81 30       	cpi	r24, 0x01	; 1
    1090:	09 f0       	breq	.+2      	; 0x1094 <DIO_voidSetPinDirection+0x32>
    1092:	6f c0       	rjmp	.+222    	; 0x1172 <__stack+0x73>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    1094:	89 81       	ldd	r24, Y+1	; 0x01
    1096:	28 2f       	mov	r18, r24
    1098:	30 e0       	ldi	r19, 0x00	; 0
    109a:	3f 83       	std	Y+7, r19	; 0x07
    109c:	2e 83       	std	Y+6, r18	; 0x06
    109e:	8e 81       	ldd	r24, Y+6	; 0x06
    10a0:	9f 81       	ldd	r25, Y+7	; 0x07
    10a2:	81 30       	cpi	r24, 0x01	; 1
    10a4:	91 05       	cpc	r25, r1
    10a6:	49 f1       	breq	.+82     	; 0x10fa <DIO_voidSetPinDirection+0x98>
    10a8:	2e 81       	ldd	r18, Y+6	; 0x06
    10aa:	3f 81       	ldd	r19, Y+7	; 0x07
    10ac:	22 30       	cpi	r18, 0x02	; 2
    10ae:	31 05       	cpc	r19, r1
    10b0:	2c f4       	brge	.+10     	; 0x10bc <DIO_voidSetPinDirection+0x5a>
    10b2:	8e 81       	ldd	r24, Y+6	; 0x06
    10b4:	9f 81       	ldd	r25, Y+7	; 0x07
    10b6:	00 97       	sbiw	r24, 0x00	; 0
    10b8:	61 f0       	breq	.+24     	; 0x10d2 <DIO_voidSetPinDirection+0x70>
    10ba:	d2 c0       	rjmp	.+420    	; 0x1260 <__stack+0x161>
    10bc:	2e 81       	ldd	r18, Y+6	; 0x06
    10be:	3f 81       	ldd	r19, Y+7	; 0x07
    10c0:	22 30       	cpi	r18, 0x02	; 2
    10c2:	31 05       	cpc	r19, r1
    10c4:	71 f1       	breq	.+92     	; 0x1122 <__stack+0x23>
    10c6:	8e 81       	ldd	r24, Y+6	; 0x06
    10c8:	9f 81       	ldd	r25, Y+7	; 0x07
    10ca:	83 30       	cpi	r24, 0x03	; 3
    10cc:	91 05       	cpc	r25, r1
    10ce:	e9 f1       	breq	.+122    	; 0x114a <__stack+0x4b>
    10d0:	c7 c0       	rjmp	.+398    	; 0x1260 <__stack+0x161>
			{
			case PORTA: SET_BIT(DDRA_Register,u8PinIdCopy); break;
    10d2:	aa e3       	ldi	r26, 0x3A	; 58
    10d4:	b0 e0       	ldi	r27, 0x00	; 0
    10d6:	ea e3       	ldi	r30, 0x3A	; 58
    10d8:	f0 e0       	ldi	r31, 0x00	; 0
    10da:	80 81       	ld	r24, Z
    10dc:	48 2f       	mov	r20, r24
    10de:	8a 81       	ldd	r24, Y+2	; 0x02
    10e0:	28 2f       	mov	r18, r24
    10e2:	30 e0       	ldi	r19, 0x00	; 0
    10e4:	81 e0       	ldi	r24, 0x01	; 1
    10e6:	90 e0       	ldi	r25, 0x00	; 0
    10e8:	02 2e       	mov	r0, r18
    10ea:	02 c0       	rjmp	.+4      	; 0x10f0 <DIO_voidSetPinDirection+0x8e>
    10ec:	88 0f       	add	r24, r24
    10ee:	99 1f       	adc	r25, r25
    10f0:	0a 94       	dec	r0
    10f2:	e2 f7       	brpl	.-8      	; 0x10ec <DIO_voidSetPinDirection+0x8a>
    10f4:	84 2b       	or	r24, r20
    10f6:	8c 93       	st	X, r24
    10f8:	b3 c0       	rjmp	.+358    	; 0x1260 <__stack+0x161>
			case PORTB: SET_BIT(DDRB_Register,u8PinIdCopy); break;
    10fa:	a7 e3       	ldi	r26, 0x37	; 55
    10fc:	b0 e0       	ldi	r27, 0x00	; 0
    10fe:	e7 e3       	ldi	r30, 0x37	; 55
    1100:	f0 e0       	ldi	r31, 0x00	; 0
    1102:	80 81       	ld	r24, Z
    1104:	48 2f       	mov	r20, r24
    1106:	8a 81       	ldd	r24, Y+2	; 0x02
    1108:	28 2f       	mov	r18, r24
    110a:	30 e0       	ldi	r19, 0x00	; 0
    110c:	81 e0       	ldi	r24, 0x01	; 1
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	02 2e       	mov	r0, r18
    1112:	02 c0       	rjmp	.+4      	; 0x1118 <__stack+0x19>
    1114:	88 0f       	add	r24, r24
    1116:	99 1f       	adc	r25, r25
    1118:	0a 94       	dec	r0
    111a:	e2 f7       	brpl	.-8      	; 0x1114 <__stack+0x15>
    111c:	84 2b       	or	r24, r20
    111e:	8c 93       	st	X, r24
    1120:	9f c0       	rjmp	.+318    	; 0x1260 <__stack+0x161>
			case PORTC: SET_BIT(DDRC_Register,u8PinIdCopy); break;
    1122:	a4 e3       	ldi	r26, 0x34	; 52
    1124:	b0 e0       	ldi	r27, 0x00	; 0
    1126:	e4 e3       	ldi	r30, 0x34	; 52
    1128:	f0 e0       	ldi	r31, 0x00	; 0
    112a:	80 81       	ld	r24, Z
    112c:	48 2f       	mov	r20, r24
    112e:	8a 81       	ldd	r24, Y+2	; 0x02
    1130:	28 2f       	mov	r18, r24
    1132:	30 e0       	ldi	r19, 0x00	; 0
    1134:	81 e0       	ldi	r24, 0x01	; 1
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	02 2e       	mov	r0, r18
    113a:	02 c0       	rjmp	.+4      	; 0x1140 <__stack+0x41>
    113c:	88 0f       	add	r24, r24
    113e:	99 1f       	adc	r25, r25
    1140:	0a 94       	dec	r0
    1142:	e2 f7       	brpl	.-8      	; 0x113c <__stack+0x3d>
    1144:	84 2b       	or	r24, r20
    1146:	8c 93       	st	X, r24
    1148:	8b c0       	rjmp	.+278    	; 0x1260 <__stack+0x161>
			case PORTD: SET_BIT(DDRD_Register,u8PinIdCopy); break;
    114a:	a1 e3       	ldi	r26, 0x31	; 49
    114c:	b0 e0       	ldi	r27, 0x00	; 0
    114e:	e1 e3       	ldi	r30, 0x31	; 49
    1150:	f0 e0       	ldi	r31, 0x00	; 0
    1152:	80 81       	ld	r24, Z
    1154:	48 2f       	mov	r20, r24
    1156:	8a 81       	ldd	r24, Y+2	; 0x02
    1158:	28 2f       	mov	r18, r24
    115a:	30 e0       	ldi	r19, 0x00	; 0
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	90 e0       	ldi	r25, 0x00	; 0
    1160:	02 2e       	mov	r0, r18
    1162:	02 c0       	rjmp	.+4      	; 0x1168 <__stack+0x69>
    1164:	88 0f       	add	r24, r24
    1166:	99 1f       	adc	r25, r25
    1168:	0a 94       	dec	r0
    116a:	e2 f7       	brpl	.-8      	; 0x1164 <__stack+0x65>
    116c:	84 2b       	or	r24, r20
    116e:	8c 93       	st	X, r24
    1170:	77 c0       	rjmp	.+238    	; 0x1260 <__stack+0x161>
			default : break;
			}
		}

		else if ( u8PinDirCopy == PIN_INPUT )
    1172:	8b 81       	ldd	r24, Y+3	; 0x03
    1174:	88 23       	and	r24, r24
    1176:	09 f0       	breq	.+2      	; 0x117a <__stack+0x7b>
    1178:	73 c0       	rjmp	.+230    	; 0x1260 <__stack+0x161>
		{
			/* Check on the Required PORT Number */
			switch (u8PortIdCopy)
    117a:	89 81       	ldd	r24, Y+1	; 0x01
    117c:	28 2f       	mov	r18, r24
    117e:	30 e0       	ldi	r19, 0x00	; 0
    1180:	3d 83       	std	Y+5, r19	; 0x05
    1182:	2c 83       	std	Y+4, r18	; 0x04
    1184:	8c 81       	ldd	r24, Y+4	; 0x04
    1186:	9d 81       	ldd	r25, Y+5	; 0x05
    1188:	81 30       	cpi	r24, 0x01	; 1
    118a:	91 05       	cpc	r25, r1
    118c:	59 f1       	breq	.+86     	; 0x11e4 <__stack+0xe5>
    118e:	2c 81       	ldd	r18, Y+4	; 0x04
    1190:	3d 81       	ldd	r19, Y+5	; 0x05
    1192:	22 30       	cpi	r18, 0x02	; 2
    1194:	31 05       	cpc	r19, r1
    1196:	2c f4       	brge	.+10     	; 0x11a2 <__stack+0xa3>
    1198:	8c 81       	ldd	r24, Y+4	; 0x04
    119a:	9d 81       	ldd	r25, Y+5	; 0x05
    119c:	00 97       	sbiw	r24, 0x00	; 0
    119e:	69 f0       	breq	.+26     	; 0x11ba <__stack+0xbb>
    11a0:	5f c0       	rjmp	.+190    	; 0x1260 <__stack+0x161>
    11a2:	2c 81       	ldd	r18, Y+4	; 0x04
    11a4:	3d 81       	ldd	r19, Y+5	; 0x05
    11a6:	22 30       	cpi	r18, 0x02	; 2
    11a8:	31 05       	cpc	r19, r1
    11aa:	89 f1       	breq	.+98     	; 0x120e <__stack+0x10f>
    11ac:	8c 81       	ldd	r24, Y+4	; 0x04
    11ae:	9d 81       	ldd	r25, Y+5	; 0x05
    11b0:	83 30       	cpi	r24, 0x03	; 3
    11b2:	91 05       	cpc	r25, r1
    11b4:	09 f4       	brne	.+2      	; 0x11b8 <__stack+0xb9>
    11b6:	40 c0       	rjmp	.+128    	; 0x1238 <__stack+0x139>
    11b8:	53 c0       	rjmp	.+166    	; 0x1260 <__stack+0x161>
			{
			case PORTA: CLR_BIT(DDRA_Register,u8PinIdCopy); break;
    11ba:	aa e3       	ldi	r26, 0x3A	; 58
    11bc:	b0 e0       	ldi	r27, 0x00	; 0
    11be:	ea e3       	ldi	r30, 0x3A	; 58
    11c0:	f0 e0       	ldi	r31, 0x00	; 0
    11c2:	80 81       	ld	r24, Z
    11c4:	48 2f       	mov	r20, r24
    11c6:	8a 81       	ldd	r24, Y+2	; 0x02
    11c8:	28 2f       	mov	r18, r24
    11ca:	30 e0       	ldi	r19, 0x00	; 0
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	02 2e       	mov	r0, r18
    11d2:	02 c0       	rjmp	.+4      	; 0x11d8 <__stack+0xd9>
    11d4:	88 0f       	add	r24, r24
    11d6:	99 1f       	adc	r25, r25
    11d8:	0a 94       	dec	r0
    11da:	e2 f7       	brpl	.-8      	; 0x11d4 <__stack+0xd5>
    11dc:	80 95       	com	r24
    11de:	84 23       	and	r24, r20
    11e0:	8c 93       	st	X, r24
    11e2:	3e c0       	rjmp	.+124    	; 0x1260 <__stack+0x161>
			case PORTB: CLR_BIT(DDRB_Register,u8PinIdCopy); break;
    11e4:	a7 e3       	ldi	r26, 0x37	; 55
    11e6:	b0 e0       	ldi	r27, 0x00	; 0
    11e8:	e7 e3       	ldi	r30, 0x37	; 55
    11ea:	f0 e0       	ldi	r31, 0x00	; 0
    11ec:	80 81       	ld	r24, Z
    11ee:	48 2f       	mov	r20, r24
    11f0:	8a 81       	ldd	r24, Y+2	; 0x02
    11f2:	28 2f       	mov	r18, r24
    11f4:	30 e0       	ldi	r19, 0x00	; 0
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	90 e0       	ldi	r25, 0x00	; 0
    11fa:	02 2e       	mov	r0, r18
    11fc:	02 c0       	rjmp	.+4      	; 0x1202 <__stack+0x103>
    11fe:	88 0f       	add	r24, r24
    1200:	99 1f       	adc	r25, r25
    1202:	0a 94       	dec	r0
    1204:	e2 f7       	brpl	.-8      	; 0x11fe <__stack+0xff>
    1206:	80 95       	com	r24
    1208:	84 23       	and	r24, r20
    120a:	8c 93       	st	X, r24
    120c:	29 c0       	rjmp	.+82     	; 0x1260 <__stack+0x161>
			case PORTC: CLR_BIT(DDRC_Register,u8PinIdCopy); break;
    120e:	a4 e3       	ldi	r26, 0x34	; 52
    1210:	b0 e0       	ldi	r27, 0x00	; 0
    1212:	e4 e3       	ldi	r30, 0x34	; 52
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	80 81       	ld	r24, Z
    1218:	48 2f       	mov	r20, r24
    121a:	8a 81       	ldd	r24, Y+2	; 0x02
    121c:	28 2f       	mov	r18, r24
    121e:	30 e0       	ldi	r19, 0x00	; 0
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	02 2e       	mov	r0, r18
    1226:	02 c0       	rjmp	.+4      	; 0x122c <__stack+0x12d>
    1228:	88 0f       	add	r24, r24
    122a:	99 1f       	adc	r25, r25
    122c:	0a 94       	dec	r0
    122e:	e2 f7       	brpl	.-8      	; 0x1228 <__stack+0x129>
    1230:	80 95       	com	r24
    1232:	84 23       	and	r24, r20
    1234:	8c 93       	st	X, r24
    1236:	14 c0       	rjmp	.+40     	; 0x1260 <__stack+0x161>
			case PORTD: CLR_BIT(DDRD_Register,u8PinIdCopy); break;
    1238:	a1 e3       	ldi	r26, 0x31	; 49
    123a:	b0 e0       	ldi	r27, 0x00	; 0
    123c:	e1 e3       	ldi	r30, 0x31	; 49
    123e:	f0 e0       	ldi	r31, 0x00	; 0
    1240:	80 81       	ld	r24, Z
    1242:	48 2f       	mov	r20, r24
    1244:	8a 81       	ldd	r24, Y+2	; 0x02
    1246:	28 2f       	mov	r18, r24
    1248:	30 e0       	ldi	r19, 0x00	; 0
    124a:	81 e0       	ldi	r24, 0x01	; 1
    124c:	90 e0       	ldi	r25, 0x00	; 0
    124e:	02 2e       	mov	r0, r18
    1250:	02 c0       	rjmp	.+4      	; 0x1256 <__stack+0x157>
    1252:	88 0f       	add	r24, r24
    1254:	99 1f       	adc	r25, r25
    1256:	0a 94       	dec	r0
    1258:	e2 f7       	brpl	.-8      	; 0x1252 <__stack+0x153>
    125a:	80 95       	com	r24
    125c:	84 23       	and	r24, r20
    125e:	8c 93       	st	X, r24
		{
			/* Do nothing, Wrong Direction Required */
		}
	}

}
    1260:	27 96       	adiw	r28, 0x07	; 7
    1262:	0f b6       	in	r0, 0x3f	; 63
    1264:	f8 94       	cli
    1266:	de bf       	out	0x3e, r29	; 62
    1268:	0f be       	out	0x3f, r0	; 63
    126a:	cd bf       	out	0x3d, r28	; 61
    126c:	cf 91       	pop	r28
    126e:	df 91       	pop	r29
    1270:	08 95       	ret

00001272 <DIO_TogglePinValue>:
void DIO_TogglePinValue(u8 u8PortIdCopy,u8 u8PinIdCopy)
{
    1272:	df 93       	push	r29
    1274:	cf 93       	push	r28
    1276:	00 d0       	rcall	.+0      	; 0x1278 <DIO_TogglePinValue+0x6>
    1278:	00 d0       	rcall	.+0      	; 0x127a <DIO_TogglePinValue+0x8>
    127a:	cd b7       	in	r28, 0x3d	; 61
    127c:	de b7       	in	r29, 0x3e	; 62
    127e:	89 83       	std	Y+1, r24	; 0x01
    1280:	6a 83       	std	Y+2, r22	; 0x02
	if ((u8PortIdCopy <= PORTD) && (u8PinIdCopy <= PIN7))
    1282:	89 81       	ldd	r24, Y+1	; 0x01
    1284:	84 30       	cpi	r24, 0x04	; 4
    1286:	08 f0       	brcs	.+2      	; 0x128a <DIO_TogglePinValue+0x18>
    1288:	72 c0       	rjmp	.+228    	; 0x136e <DIO_TogglePinValue+0xfc>
    128a:	8a 81       	ldd	r24, Y+2	; 0x02
    128c:	88 30       	cpi	r24, 0x08	; 8
    128e:	08 f0       	brcs	.+2      	; 0x1292 <DIO_TogglePinValue+0x20>
    1290:	6e c0       	rjmp	.+220    	; 0x136e <DIO_TogglePinValue+0xfc>
	{
		/* Check on the Required PORT Number */
		switch (u8PortIdCopy)
    1292:	89 81       	ldd	r24, Y+1	; 0x01
    1294:	28 2f       	mov	r18, r24
    1296:	30 e0       	ldi	r19, 0x00	; 0
    1298:	3c 83       	std	Y+4, r19	; 0x04
    129a:	2b 83       	std	Y+3, r18	; 0x03
    129c:	8b 81       	ldd	r24, Y+3	; 0x03
    129e:	9c 81       	ldd	r25, Y+4	; 0x04
    12a0:	81 30       	cpi	r24, 0x01	; 1
    12a2:	91 05       	cpc	r25, r1
    12a4:	49 f1       	breq	.+82     	; 0x12f8 <DIO_TogglePinValue+0x86>
    12a6:	2b 81       	ldd	r18, Y+3	; 0x03
    12a8:	3c 81       	ldd	r19, Y+4	; 0x04
    12aa:	22 30       	cpi	r18, 0x02	; 2
    12ac:	31 05       	cpc	r19, r1
    12ae:	2c f4       	brge	.+10     	; 0x12ba <DIO_TogglePinValue+0x48>
    12b0:	8b 81       	ldd	r24, Y+3	; 0x03
    12b2:	9c 81       	ldd	r25, Y+4	; 0x04
    12b4:	00 97       	sbiw	r24, 0x00	; 0
    12b6:	61 f0       	breq	.+24     	; 0x12d0 <DIO_TogglePinValue+0x5e>
    12b8:	5a c0       	rjmp	.+180    	; 0x136e <DIO_TogglePinValue+0xfc>
    12ba:	2b 81       	ldd	r18, Y+3	; 0x03
    12bc:	3c 81       	ldd	r19, Y+4	; 0x04
    12be:	22 30       	cpi	r18, 0x02	; 2
    12c0:	31 05       	cpc	r19, r1
    12c2:	71 f1       	breq	.+92     	; 0x1320 <DIO_TogglePinValue+0xae>
    12c4:	8b 81       	ldd	r24, Y+3	; 0x03
    12c6:	9c 81       	ldd	r25, Y+4	; 0x04
    12c8:	83 30       	cpi	r24, 0x03	; 3
    12ca:	91 05       	cpc	r25, r1
    12cc:	e9 f1       	breq	.+122    	; 0x1348 <DIO_TogglePinValue+0xd6>
    12ce:	4f c0       	rjmp	.+158    	; 0x136e <DIO_TogglePinValue+0xfc>
		{
		case PORTA: TOG_BIT(PORTA_Register,u8PinIdCopy); break;
    12d0:	ab e3       	ldi	r26, 0x3B	; 59
    12d2:	b0 e0       	ldi	r27, 0x00	; 0
    12d4:	eb e3       	ldi	r30, 0x3B	; 59
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	80 81       	ld	r24, Z
    12da:	48 2f       	mov	r20, r24
    12dc:	8a 81       	ldd	r24, Y+2	; 0x02
    12de:	28 2f       	mov	r18, r24
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	02 2e       	mov	r0, r18
    12e8:	02 c0       	rjmp	.+4      	; 0x12ee <DIO_TogglePinValue+0x7c>
    12ea:	88 0f       	add	r24, r24
    12ec:	99 1f       	adc	r25, r25
    12ee:	0a 94       	dec	r0
    12f0:	e2 f7       	brpl	.-8      	; 0x12ea <DIO_TogglePinValue+0x78>
    12f2:	84 27       	eor	r24, r20
    12f4:	8c 93       	st	X, r24
    12f6:	3b c0       	rjmp	.+118    	; 0x136e <DIO_TogglePinValue+0xfc>
		case PORTB: TOG_BIT(PORTB_Register,u8PinIdCopy); break;
    12f8:	a8 e3       	ldi	r26, 0x38	; 56
    12fa:	b0 e0       	ldi	r27, 0x00	; 0
    12fc:	e8 e3       	ldi	r30, 0x38	; 56
    12fe:	f0 e0       	ldi	r31, 0x00	; 0
    1300:	80 81       	ld	r24, Z
    1302:	48 2f       	mov	r20, r24
    1304:	8a 81       	ldd	r24, Y+2	; 0x02
    1306:	28 2f       	mov	r18, r24
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	90 e0       	ldi	r25, 0x00	; 0
    130e:	02 2e       	mov	r0, r18
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <DIO_TogglePinValue+0xa4>
    1312:	88 0f       	add	r24, r24
    1314:	99 1f       	adc	r25, r25
    1316:	0a 94       	dec	r0
    1318:	e2 f7       	brpl	.-8      	; 0x1312 <DIO_TogglePinValue+0xa0>
    131a:	84 27       	eor	r24, r20
    131c:	8c 93       	st	X, r24
    131e:	27 c0       	rjmp	.+78     	; 0x136e <DIO_TogglePinValue+0xfc>
		case PORTC: TOG_BIT(PORTC_Register,u8PinIdCopy); break;
    1320:	a5 e3       	ldi	r26, 0x35	; 53
    1322:	b0 e0       	ldi	r27, 0x00	; 0
    1324:	e5 e3       	ldi	r30, 0x35	; 53
    1326:	f0 e0       	ldi	r31, 0x00	; 0
    1328:	80 81       	ld	r24, Z
    132a:	48 2f       	mov	r20, r24
    132c:	8a 81       	ldd	r24, Y+2	; 0x02
    132e:	28 2f       	mov	r18, r24
    1330:	30 e0       	ldi	r19, 0x00	; 0
    1332:	81 e0       	ldi	r24, 0x01	; 1
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	02 2e       	mov	r0, r18
    1338:	02 c0       	rjmp	.+4      	; 0x133e <DIO_TogglePinValue+0xcc>
    133a:	88 0f       	add	r24, r24
    133c:	99 1f       	adc	r25, r25
    133e:	0a 94       	dec	r0
    1340:	e2 f7       	brpl	.-8      	; 0x133a <DIO_TogglePinValue+0xc8>
    1342:	84 27       	eor	r24, r20
    1344:	8c 93       	st	X, r24
    1346:	13 c0       	rjmp	.+38     	; 0x136e <DIO_TogglePinValue+0xfc>
		case PORTD: TOG_BIT(PORTD_Register,u8PinIdCopy); break;
    1348:	a2 e3       	ldi	r26, 0x32	; 50
    134a:	b0 e0       	ldi	r27, 0x00	; 0
    134c:	e2 e3       	ldi	r30, 0x32	; 50
    134e:	f0 e0       	ldi	r31, 0x00	; 0
    1350:	80 81       	ld	r24, Z
    1352:	48 2f       	mov	r20, r24
    1354:	8a 81       	ldd	r24, Y+2	; 0x02
    1356:	28 2f       	mov	r18, r24
    1358:	30 e0       	ldi	r19, 0x00	; 0
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	90 e0       	ldi	r25, 0x00	; 0
    135e:	02 2e       	mov	r0, r18
    1360:	02 c0       	rjmp	.+4      	; 0x1366 <DIO_TogglePinValue+0xf4>
    1362:	88 0f       	add	r24, r24
    1364:	99 1f       	adc	r25, r25
    1366:	0a 94       	dec	r0
    1368:	e2 f7       	brpl	.-8      	; 0x1362 <DIO_TogglePinValue+0xf0>
    136a:	84 27       	eor	r24, r20
    136c:	8c 93       	st	X, r24
	}
	else
	{
		/* Do nothing, Wrong Direction Required */
	}
}
    136e:	0f 90       	pop	r0
    1370:	0f 90       	pop	r0
    1372:	0f 90       	pop	r0
    1374:	0f 90       	pop	r0
    1376:	cf 91       	pop	r28
    1378:	df 91       	pop	r29
    137a:	08 95       	ret

0000137c <DIO_SetPortDirection>:

/* IO Ports */
void DIO_SetPortDirection(u8 u8PortIdCopy,u8 u8PortDirCopy)
{
    137c:	df 93       	push	r29
    137e:	cf 93       	push	r28
    1380:	00 d0       	rcall	.+0      	; 0x1382 <DIO_SetPortDirection+0x6>
    1382:	00 d0       	rcall	.+0      	; 0x1384 <DIO_SetPortDirection+0x8>
    1384:	cd b7       	in	r28, 0x3d	; 61
    1386:	de b7       	in	r29, 0x3e	; 62
    1388:	89 83       	std	Y+1, r24	; 0x01
    138a:	6a 83       	std	Y+2, r22	; 0x02
	switch(u8PortIdCopy)
    138c:	89 81       	ldd	r24, Y+1	; 0x01
    138e:	28 2f       	mov	r18, r24
    1390:	30 e0       	ldi	r19, 0x00	; 0
    1392:	3c 83       	std	Y+4, r19	; 0x04
    1394:	2b 83       	std	Y+3, r18	; 0x03
    1396:	8b 81       	ldd	r24, Y+3	; 0x03
    1398:	9c 81       	ldd	r25, Y+4	; 0x04
    139a:	81 30       	cpi	r24, 0x01	; 1
    139c:	91 05       	cpc	r25, r1
    139e:	d1 f0       	breq	.+52     	; 0x13d4 <DIO_SetPortDirection+0x58>
    13a0:	2b 81       	ldd	r18, Y+3	; 0x03
    13a2:	3c 81       	ldd	r19, Y+4	; 0x04
    13a4:	22 30       	cpi	r18, 0x02	; 2
    13a6:	31 05       	cpc	r19, r1
    13a8:	2c f4       	brge	.+10     	; 0x13b4 <DIO_SetPortDirection+0x38>
    13aa:	8b 81       	ldd	r24, Y+3	; 0x03
    13ac:	9c 81       	ldd	r25, Y+4	; 0x04
    13ae:	00 97       	sbiw	r24, 0x00	; 0
    13b0:	61 f0       	breq	.+24     	; 0x13ca <DIO_SetPortDirection+0x4e>
    13b2:	1e c0       	rjmp	.+60     	; 0x13f0 <DIO_SetPortDirection+0x74>
    13b4:	2b 81       	ldd	r18, Y+3	; 0x03
    13b6:	3c 81       	ldd	r19, Y+4	; 0x04
    13b8:	22 30       	cpi	r18, 0x02	; 2
    13ba:	31 05       	cpc	r19, r1
    13bc:	81 f0       	breq	.+32     	; 0x13de <DIO_SetPortDirection+0x62>
    13be:	8b 81       	ldd	r24, Y+3	; 0x03
    13c0:	9c 81       	ldd	r25, Y+4	; 0x04
    13c2:	83 30       	cpi	r24, 0x03	; 3
    13c4:	91 05       	cpc	r25, r1
    13c6:	81 f0       	breq	.+32     	; 0x13e8 <DIO_SetPortDirection+0x6c>
    13c8:	13 c0       	rjmp	.+38     	; 0x13f0 <DIO_SetPortDirection+0x74>
	{
	case PORTA : DDRA_Register = u8PortDirCopy; break;
    13ca:	ea e3       	ldi	r30, 0x3A	; 58
    13cc:	f0 e0       	ldi	r31, 0x00	; 0
    13ce:	8a 81       	ldd	r24, Y+2	; 0x02
    13d0:	80 83       	st	Z, r24
    13d2:	0e c0       	rjmp	.+28     	; 0x13f0 <DIO_SetPortDirection+0x74>
	case PORTB : DDRB_Register = u8PortDirCopy; break;
    13d4:	e7 e3       	ldi	r30, 0x37	; 55
    13d6:	f0 e0       	ldi	r31, 0x00	; 0
    13d8:	8a 81       	ldd	r24, Y+2	; 0x02
    13da:	80 83       	st	Z, r24
    13dc:	09 c0       	rjmp	.+18     	; 0x13f0 <DIO_SetPortDirection+0x74>
	case PORTC : DDRC_Register = u8PortDirCopy; break;
    13de:	e4 e3       	ldi	r30, 0x34	; 52
    13e0:	f0 e0       	ldi	r31, 0x00	; 0
    13e2:	8a 81       	ldd	r24, Y+2	; 0x02
    13e4:	80 83       	st	Z, r24
    13e6:	04 c0       	rjmp	.+8      	; 0x13f0 <DIO_SetPortDirection+0x74>
	case PORTD : DDRD_Register = u8PortDirCopy; break;
    13e8:	e1 e3       	ldi	r30, 0x31	; 49
    13ea:	f0 e0       	ldi	r31, 0x00	; 0
    13ec:	8a 81       	ldd	r24, Y+2	; 0x02
    13ee:	80 83       	st	Z, r24
	default: break;
	}

}
    13f0:	0f 90       	pop	r0
    13f2:	0f 90       	pop	r0
    13f4:	0f 90       	pop	r0
    13f6:	0f 90       	pop	r0
    13f8:	cf 91       	pop	r28
    13fa:	df 91       	pop	r29
    13fc:	08 95       	ret

000013fe <DIO_SetPortValue>:
void DIO_SetPortValue(u8 u8PortIdCopy,u8 u8PortValCopy)
{
    13fe:	df 93       	push	r29
    1400:	cf 93       	push	r28
    1402:	00 d0       	rcall	.+0      	; 0x1404 <DIO_SetPortValue+0x6>
    1404:	00 d0       	rcall	.+0      	; 0x1406 <DIO_SetPortValue+0x8>
    1406:	cd b7       	in	r28, 0x3d	; 61
    1408:	de b7       	in	r29, 0x3e	; 62
    140a:	89 83       	std	Y+1, r24	; 0x01
    140c:	6a 83       	std	Y+2, r22	; 0x02
	switch(u8PortIdCopy)
    140e:	89 81       	ldd	r24, Y+1	; 0x01
    1410:	28 2f       	mov	r18, r24
    1412:	30 e0       	ldi	r19, 0x00	; 0
    1414:	3c 83       	std	Y+4, r19	; 0x04
    1416:	2b 83       	std	Y+3, r18	; 0x03
    1418:	8b 81       	ldd	r24, Y+3	; 0x03
    141a:	9c 81       	ldd	r25, Y+4	; 0x04
    141c:	81 30       	cpi	r24, 0x01	; 1
    141e:	91 05       	cpc	r25, r1
    1420:	d1 f0       	breq	.+52     	; 0x1456 <DIO_SetPortValue+0x58>
    1422:	2b 81       	ldd	r18, Y+3	; 0x03
    1424:	3c 81       	ldd	r19, Y+4	; 0x04
    1426:	22 30       	cpi	r18, 0x02	; 2
    1428:	31 05       	cpc	r19, r1
    142a:	2c f4       	brge	.+10     	; 0x1436 <DIO_SetPortValue+0x38>
    142c:	8b 81       	ldd	r24, Y+3	; 0x03
    142e:	9c 81       	ldd	r25, Y+4	; 0x04
    1430:	00 97       	sbiw	r24, 0x00	; 0
    1432:	61 f0       	breq	.+24     	; 0x144c <DIO_SetPortValue+0x4e>
    1434:	1e c0       	rjmp	.+60     	; 0x1472 <DIO_SetPortValue+0x74>
    1436:	2b 81       	ldd	r18, Y+3	; 0x03
    1438:	3c 81       	ldd	r19, Y+4	; 0x04
    143a:	22 30       	cpi	r18, 0x02	; 2
    143c:	31 05       	cpc	r19, r1
    143e:	81 f0       	breq	.+32     	; 0x1460 <DIO_SetPortValue+0x62>
    1440:	8b 81       	ldd	r24, Y+3	; 0x03
    1442:	9c 81       	ldd	r25, Y+4	; 0x04
    1444:	83 30       	cpi	r24, 0x03	; 3
    1446:	91 05       	cpc	r25, r1
    1448:	81 f0       	breq	.+32     	; 0x146a <DIO_SetPortValue+0x6c>
    144a:	13 c0       	rjmp	.+38     	; 0x1472 <DIO_SetPortValue+0x74>
	{
	case PORTA : PORTA_Register = u8PortValCopy; break;
    144c:	eb e3       	ldi	r30, 0x3B	; 59
    144e:	f0 e0       	ldi	r31, 0x00	; 0
    1450:	8a 81       	ldd	r24, Y+2	; 0x02
    1452:	80 83       	st	Z, r24
    1454:	0e c0       	rjmp	.+28     	; 0x1472 <DIO_SetPortValue+0x74>
	case PORTB : PORTB_Register = u8PortValCopy; break;
    1456:	e8 e3       	ldi	r30, 0x38	; 56
    1458:	f0 e0       	ldi	r31, 0x00	; 0
    145a:	8a 81       	ldd	r24, Y+2	; 0x02
    145c:	80 83       	st	Z, r24
    145e:	09 c0       	rjmp	.+18     	; 0x1472 <DIO_SetPortValue+0x74>
	case PORTC : PORTC_Register = u8PortValCopy; break;
    1460:	e5 e3       	ldi	r30, 0x35	; 53
    1462:	f0 e0       	ldi	r31, 0x00	; 0
    1464:	8a 81       	ldd	r24, Y+2	; 0x02
    1466:	80 83       	st	Z, r24
    1468:	04 c0       	rjmp	.+8      	; 0x1472 <DIO_SetPortValue+0x74>
	case PORTD : PORTD_Register = u8PortValCopy; break;
    146a:	e2 e3       	ldi	r30, 0x32	; 50
    146c:	f0 e0       	ldi	r31, 0x00	; 0
    146e:	8a 81       	ldd	r24, Y+2	; 0x02
    1470:	80 83       	st	Z, r24
	default: break;
	}


}
    1472:	0f 90       	pop	r0
    1474:	0f 90       	pop	r0
    1476:	0f 90       	pop	r0
    1478:	0f 90       	pop	r0
    147a:	cf 91       	pop	r28
    147c:	df 91       	pop	r29
    147e:	08 95       	ret

00001480 <DIO_TogglePortValue>:
void DIO_TogglePortValue(u8 u8PortIdCopy)
{
    1480:	df 93       	push	r29
    1482:	cf 93       	push	r28
    1484:	00 d0       	rcall	.+0      	; 0x1486 <DIO_TogglePortValue+0x6>
    1486:	0f 92       	push	r0
    1488:	cd b7       	in	r28, 0x3d	; 61
    148a:	de b7       	in	r29, 0x3e	; 62
    148c:	89 83       	std	Y+1, r24	; 0x01
	switch(u8PortIdCopy)
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	28 2f       	mov	r18, r24
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	3b 83       	std	Y+3, r19	; 0x03
    1496:	2a 83       	std	Y+2, r18	; 0x02
    1498:	8a 81       	ldd	r24, Y+2	; 0x02
    149a:	9b 81       	ldd	r25, Y+3	; 0x03
    149c:	81 30       	cpi	r24, 0x01	; 1
    149e:	91 05       	cpc	r25, r1
    14a0:	e9 f0       	breq	.+58     	; 0x14dc <DIO_TogglePortValue+0x5c>
    14a2:	2a 81       	ldd	r18, Y+2	; 0x02
    14a4:	3b 81       	ldd	r19, Y+3	; 0x03
    14a6:	22 30       	cpi	r18, 0x02	; 2
    14a8:	31 05       	cpc	r19, r1
    14aa:	2c f4       	brge	.+10     	; 0x14b6 <DIO_TogglePortValue+0x36>
    14ac:	8a 81       	ldd	r24, Y+2	; 0x02
    14ae:	9b 81       	ldd	r25, Y+3	; 0x03
    14b0:	00 97       	sbiw	r24, 0x00	; 0
    14b2:	61 f0       	breq	.+24     	; 0x14cc <DIO_TogglePortValue+0x4c>
    14b4:	2a c0       	rjmp	.+84     	; 0x150a <DIO_TogglePortValue+0x8a>
    14b6:	2a 81       	ldd	r18, Y+2	; 0x02
    14b8:	3b 81       	ldd	r19, Y+3	; 0x03
    14ba:	22 30       	cpi	r18, 0x02	; 2
    14bc:	31 05       	cpc	r19, r1
    14be:	b1 f0       	breq	.+44     	; 0x14ec <DIO_TogglePortValue+0x6c>
    14c0:	8a 81       	ldd	r24, Y+2	; 0x02
    14c2:	9b 81       	ldd	r25, Y+3	; 0x03
    14c4:	83 30       	cpi	r24, 0x03	; 3
    14c6:	91 05       	cpc	r25, r1
    14c8:	c9 f0       	breq	.+50     	; 0x14fc <DIO_TogglePortValue+0x7c>
    14ca:	1f c0       	rjmp	.+62     	; 0x150a <DIO_TogglePortValue+0x8a>
	{
	case PORTA : PORTA_Register ^= 0xFF; break;
    14cc:	ab e3       	ldi	r26, 0x3B	; 59
    14ce:	b0 e0       	ldi	r27, 0x00	; 0
    14d0:	eb e3       	ldi	r30, 0x3B	; 59
    14d2:	f0 e0       	ldi	r31, 0x00	; 0
    14d4:	80 81       	ld	r24, Z
    14d6:	80 95       	com	r24
    14d8:	8c 93       	st	X, r24
    14da:	17 c0       	rjmp	.+46     	; 0x150a <DIO_TogglePortValue+0x8a>
	case PORTB : PORTB_Register ^= 0xFF; break;
    14dc:	a8 e3       	ldi	r26, 0x38	; 56
    14de:	b0 e0       	ldi	r27, 0x00	; 0
    14e0:	e8 e3       	ldi	r30, 0x38	; 56
    14e2:	f0 e0       	ldi	r31, 0x00	; 0
    14e4:	80 81       	ld	r24, Z
    14e6:	80 95       	com	r24
    14e8:	8c 93       	st	X, r24
    14ea:	0f c0       	rjmp	.+30     	; 0x150a <DIO_TogglePortValue+0x8a>
	case PORTC : PORTC_Register ^= 0xFF; break;
    14ec:	a5 e3       	ldi	r26, 0x35	; 53
    14ee:	b0 e0       	ldi	r27, 0x00	; 0
    14f0:	e5 e3       	ldi	r30, 0x35	; 53
    14f2:	f0 e0       	ldi	r31, 0x00	; 0
    14f4:	80 81       	ld	r24, Z
    14f6:	80 95       	com	r24
    14f8:	8c 93       	st	X, r24
    14fa:	07 c0       	rjmp	.+14     	; 0x150a <DIO_TogglePortValue+0x8a>
	case PORTD : PORTD_Register ^= 0xFF; break;
    14fc:	a2 e3       	ldi	r26, 0x32	; 50
    14fe:	b0 e0       	ldi	r27, 0x00	; 0
    1500:	e2 e3       	ldi	r30, 0x32	; 50
    1502:	f0 e0       	ldi	r31, 0x00	; 0
    1504:	80 81       	ld	r24, Z
    1506:	80 95       	com	r24
    1508:	8c 93       	st	X, r24
	default: break;
	}

}
    150a:	0f 90       	pop	r0
    150c:	0f 90       	pop	r0
    150e:	0f 90       	pop	r0
    1510:	cf 91       	pop	r28
    1512:	df 91       	pop	r29
    1514:	08 95       	ret

00001516 <DIO_GetPortValue>:
u8 DIO_GetPortValue(u8 u8PortIdCopy)
{
    1516:	df 93       	push	r29
    1518:	cf 93       	push	r28
    151a:	00 d0       	rcall	.+0      	; 0x151c <DIO_GetPortValue+0x6>
    151c:	00 d0       	rcall	.+0      	; 0x151e <DIO_GetPortValue+0x8>
    151e:	cd b7       	in	r28, 0x3d	; 61
    1520:	de b7       	in	r29, 0x3e	; 62
    1522:	8a 83       	std	Y+2, r24	; 0x02
	u8 u8Valuecopy;

	switch(u8PortIdCopy)
    1524:	8a 81       	ldd	r24, Y+2	; 0x02
    1526:	28 2f       	mov	r18, r24
    1528:	30 e0       	ldi	r19, 0x00	; 0
    152a:	3c 83       	std	Y+4, r19	; 0x04
    152c:	2b 83       	std	Y+3, r18	; 0x03
    152e:	8b 81       	ldd	r24, Y+3	; 0x03
    1530:	9c 81       	ldd	r25, Y+4	; 0x04
    1532:	81 30       	cpi	r24, 0x01	; 1
    1534:	91 05       	cpc	r25, r1
    1536:	d1 f0       	breq	.+52     	; 0x156c <DIO_GetPortValue+0x56>
    1538:	2b 81       	ldd	r18, Y+3	; 0x03
    153a:	3c 81       	ldd	r19, Y+4	; 0x04
    153c:	22 30       	cpi	r18, 0x02	; 2
    153e:	31 05       	cpc	r19, r1
    1540:	2c f4       	brge	.+10     	; 0x154c <DIO_GetPortValue+0x36>
    1542:	8b 81       	ldd	r24, Y+3	; 0x03
    1544:	9c 81       	ldd	r25, Y+4	; 0x04
    1546:	00 97       	sbiw	r24, 0x00	; 0
    1548:	61 f0       	breq	.+24     	; 0x1562 <DIO_GetPortValue+0x4c>
    154a:	1e c0       	rjmp	.+60     	; 0x1588 <DIO_GetPortValue+0x72>
    154c:	2b 81       	ldd	r18, Y+3	; 0x03
    154e:	3c 81       	ldd	r19, Y+4	; 0x04
    1550:	22 30       	cpi	r18, 0x02	; 2
    1552:	31 05       	cpc	r19, r1
    1554:	81 f0       	breq	.+32     	; 0x1576 <DIO_GetPortValue+0x60>
    1556:	8b 81       	ldd	r24, Y+3	; 0x03
    1558:	9c 81       	ldd	r25, Y+4	; 0x04
    155a:	83 30       	cpi	r24, 0x03	; 3
    155c:	91 05       	cpc	r25, r1
    155e:	81 f0       	breq	.+32     	; 0x1580 <DIO_GetPortValue+0x6a>
    1560:	13 c0       	rjmp	.+38     	; 0x1588 <DIO_GetPortValue+0x72>
	{
	case PORTA :u8Valuecopy = PINA_Register; break;
    1562:	e9 e3       	ldi	r30, 0x39	; 57
    1564:	f0 e0       	ldi	r31, 0x00	; 0
    1566:	80 81       	ld	r24, Z
    1568:	89 83       	std	Y+1, r24	; 0x01
    156a:	0e c0       	rjmp	.+28     	; 0x1588 <DIO_GetPortValue+0x72>
	case PORTB :u8Valuecopy = PINB_Register; break;
    156c:	e6 e3       	ldi	r30, 0x36	; 54
    156e:	f0 e0       	ldi	r31, 0x00	; 0
    1570:	80 81       	ld	r24, Z
    1572:	89 83       	std	Y+1, r24	; 0x01
    1574:	09 c0       	rjmp	.+18     	; 0x1588 <DIO_GetPortValue+0x72>
	case PORTC :u8Valuecopy = PINC_Register; break;
    1576:	e3 e3       	ldi	r30, 0x33	; 51
    1578:	f0 e0       	ldi	r31, 0x00	; 0
    157a:	80 81       	ld	r24, Z
    157c:	89 83       	std	Y+1, r24	; 0x01
    157e:	04 c0       	rjmp	.+8      	; 0x1588 <DIO_GetPortValue+0x72>
	case PORTD :u8Valuecopy = PIND_Register; break;
    1580:	e0 e3       	ldi	r30, 0x30	; 48
    1582:	f0 e0       	ldi	r31, 0x00	; 0
    1584:	80 81       	ld	r24, Z
    1586:	89 83       	std	Y+1, r24	; 0x01
	default: break;
	}

	return u8Valuecopy;
    1588:	89 81       	ldd	r24, Y+1	; 0x01

}
    158a:	0f 90       	pop	r0
    158c:	0f 90       	pop	r0
    158e:	0f 90       	pop	r0
    1590:	0f 90       	pop	r0
    1592:	cf 91       	pop	r28
    1594:	df 91       	pop	r29
    1596:	08 95       	ret

00001598 <Tim1Init>:
#include "Timer_interface.h"
#include "Tim1_register.h"

void (* Tim1_callback_PTR)(void)=NULL;

void Tim1Init(){
    1598:	df 93       	push	r29
    159a:	cf 93       	push	r28
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR1B_Register,0);
    15a0:	ae e4       	ldi	r26, 0x4E	; 78
    15a2:	b0 e0       	ldi	r27, 0x00	; 0
    15a4:	ee e4       	ldi	r30, 0x4E	; 78
    15a6:	f0 e0       	ldi	r31, 0x00	; 0
    15a8:	80 81       	ld	r24, Z
    15aa:	8e 7f       	andi	r24, 0xFE	; 254
    15ac:	8c 93       	st	X, r24
	SET_BIT(TCCR1B_Register,1);
    15ae:	ae e4       	ldi	r26, 0x4E	; 78
    15b0:	b0 e0       	ldi	r27, 0x00	; 0
    15b2:	ee e4       	ldi	r30, 0x4E	; 78
    15b4:	f0 e0       	ldi	r31, 0x00	; 0
    15b6:	80 81       	ld	r24, Z
    15b8:	82 60       	ori	r24, 0x02	; 2
    15ba:	8c 93       	st	X, r24
	CLR_BIT(TCCR1B_Register,2);
    15bc:	ae e4       	ldi	r26, 0x4E	; 78
    15be:	b0 e0       	ldi	r27, 0x00	; 0
    15c0:	ee e4       	ldi	r30, 0x4E	; 78
    15c2:	f0 e0       	ldi	r31, 0x00	; 0
    15c4:	80 81       	ld	r24, Z
    15c6:	8b 7f       	andi	r24, 0xFB	; 251
    15c8:	8c 93       	st	X, r24

	TCNT1_Register=0;
    15ca:	ec e4       	ldi	r30, 0x4C	; 76
    15cc:	f0 e0       	ldi	r31, 0x00	; 0
    15ce:	11 82       	std	Z+1, r1	; 0x01
    15d0:	10 82       	st	Z, r1
	ICR1_Register=0;
    15d2:	e6 e4       	ldi	r30, 0x46	; 70
    15d4:	f0 e0       	ldi	r31, 0x00	; 0
    15d6:	11 82       	std	Z+1, r1	; 0x01
    15d8:	10 82       	st	Z, r1

	SET_BIT(TCCR1B_Register,6); //SET RISING EDGE
    15da:	ae e4       	ldi	r26, 0x4E	; 78
    15dc:	b0 e0       	ldi	r27, 0x00	; 0
    15de:	ee e4       	ldi	r30, 0x4E	; 78
    15e0:	f0 e0       	ldi	r31, 0x00	; 0
    15e2:	80 81       	ld	r24, Z
    15e4:	80 64       	ori	r24, 0x40	; 64
    15e6:	8c 93       	st	X, r24



}
    15e8:	cf 91       	pop	r28
    15ea:	df 91       	pop	r29
    15ec:	08 95       	ret

000015ee <Tim1_SetRisingEdge>:

void Tim1_SetRisingEdge(){
    15ee:	df 93       	push	r29
    15f0:	cf 93       	push	r28
    15f2:	cd b7       	in	r28, 0x3d	; 61
    15f4:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR1B_Register,6);
    15f6:	ae e4       	ldi	r26, 0x4E	; 78
    15f8:	b0 e0       	ldi	r27, 0x00	; 0
    15fa:	ee e4       	ldi	r30, 0x4E	; 78
    15fc:	f0 e0       	ldi	r31, 0x00	; 0
    15fe:	80 81       	ld	r24, Z
    1600:	80 64       	ori	r24, 0x40	; 64
    1602:	8c 93       	st	X, r24
}
    1604:	cf 91       	pop	r28
    1606:	df 91       	pop	r29
    1608:	08 95       	ret

0000160a <Tim1_SetFailingEdge>:

void Tim1_SetFailingEdge(){
    160a:	df 93       	push	r29
    160c:	cf 93       	push	r28
    160e:	cd b7       	in	r28, 0x3d	; 61
    1610:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR1B_Register,6);
    1612:	ae e4       	ldi	r26, 0x4E	; 78
    1614:	b0 e0       	ldi	r27, 0x00	; 0
    1616:	ee e4       	ldi	r30, 0x4E	; 78
    1618:	f0 e0       	ldi	r31, 0x00	; 0
    161a:	80 81       	ld	r24, Z
    161c:	8f 7b       	andi	r24, 0xBF	; 191
    161e:	8c 93       	st	X, r24

}
    1620:	cf 91       	pop	r28
    1622:	df 91       	pop	r29
    1624:	08 95       	ret

00001626 <Tim1_GetValue>:

u16 Tim1_GetValue(){
    1626:	df 93       	push	r29
    1628:	cf 93       	push	r28
    162a:	cd b7       	in	r28, 0x3d	; 61
    162c:	de b7       	in	r29, 0x3e	; 62
	return ICR1_Register;
    162e:	e6 e4       	ldi	r30, 0x46	; 70
    1630:	f0 e0       	ldi	r31, 0x00	; 0
    1632:	80 81       	ld	r24, Z
    1634:	91 81       	ldd	r25, Z+1	; 0x01
}
    1636:	cf 91       	pop	r28
    1638:	df 91       	pop	r29
    163a:	08 95       	ret

0000163c <Tim1_VID_SET_CALL_BACK>:

void Tim1_VID_SET_CALL_BACK(void (*PTR)(void)){
    163c:	df 93       	push	r29
    163e:	cf 93       	push	r28
    1640:	00 d0       	rcall	.+0      	; 0x1642 <Tim1_VID_SET_CALL_BACK+0x6>
    1642:	cd b7       	in	r28, 0x3d	; 61
    1644:	de b7       	in	r29, 0x3e	; 62
    1646:	9a 83       	std	Y+2, r25	; 0x02
    1648:	89 83       	std	Y+1, r24	; 0x01
	Tim1_callback_PTR=PTR;
    164a:	89 81       	ldd	r24, Y+1	; 0x01
    164c:	9a 81       	ldd	r25, Y+2	; 0x02
    164e:	90 93 73 01 	sts	0x0173, r25
    1652:	80 93 72 01 	sts	0x0172, r24
}
    1656:	0f 90       	pop	r0
    1658:	0f 90       	pop	r0
    165a:	cf 91       	pop	r28
    165c:	df 91       	pop	r29
    165e:	08 95       	ret

00001660 <__vector_6>:

void __vector_6 (void) __attribute__ ((signal,used,externally_visible)); //to avoid optmization
void __vector_6 (void){
    1660:	1f 92       	push	r1
    1662:	0f 92       	push	r0
    1664:	0f b6       	in	r0, 0x3f	; 63
    1666:	0f 92       	push	r0
    1668:	00 90 5b 00 	lds	r0, 0x005B
    166c:	0f 92       	push	r0
    166e:	11 24       	eor	r1, r1
    1670:	2f 93       	push	r18
    1672:	3f 93       	push	r19
    1674:	4f 93       	push	r20
    1676:	5f 93       	push	r21
    1678:	6f 93       	push	r22
    167a:	7f 93       	push	r23
    167c:	8f 93       	push	r24
    167e:	9f 93       	push	r25
    1680:	af 93       	push	r26
    1682:	bf 93       	push	r27
    1684:	ef 93       	push	r30
    1686:	ff 93       	push	r31
    1688:	df 93       	push	r29
    168a:	cf 93       	push	r28
    168c:	cd b7       	in	r28, 0x3d	; 61
    168e:	de b7       	in	r29, 0x3e	; 62
	Tim1_callback_PTR();
    1690:	e0 91 72 01 	lds	r30, 0x0172
    1694:	f0 91 73 01 	lds	r31, 0x0173
    1698:	09 95       	icall
}
    169a:	cf 91       	pop	r28
    169c:	df 91       	pop	r29
    169e:	ff 91       	pop	r31
    16a0:	ef 91       	pop	r30
    16a2:	bf 91       	pop	r27
    16a4:	af 91       	pop	r26
    16a6:	9f 91       	pop	r25
    16a8:	8f 91       	pop	r24
    16aa:	7f 91       	pop	r23
    16ac:	6f 91       	pop	r22
    16ae:	5f 91       	pop	r21
    16b0:	4f 91       	pop	r20
    16b2:	3f 91       	pop	r19
    16b4:	2f 91       	pop	r18
    16b6:	0f 90       	pop	r0
    16b8:	00 92 5b 00 	sts	0x005B, r0
    16bc:	0f 90       	pop	r0
    16be:	0f be       	out	0x3f, r0	; 63
    16c0:	0f 90       	pop	r0
    16c2:	1f 90       	pop	r1
    16c4:	18 95       	reti

000016c6 <CounterInit>:
#include "Timer_config.h"

void (* callback_PTR)(void)=NULL;


void CounterInit(){
    16c6:	df 93       	push	r29
    16c8:	cf 93       	push	r28
    16ca:	cd b7       	in	r28, 0x3d	; 61
    16cc:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR0_Register,0); //External clock source on T0 pin. Clock on rising edge
    16ce:	a3 e5       	ldi	r26, 0x53	; 83
    16d0:	b0 e0       	ldi	r27, 0x00	; 0
    16d2:	e3 e5       	ldi	r30, 0x53	; 83
    16d4:	f0 e0       	ldi	r31, 0x00	; 0
    16d6:	80 81       	ld	r24, Z
    16d8:	81 60       	ori	r24, 0x01	; 1
    16da:	8c 93       	st	X, r24
	SET_BIT(TCCR0_Register,1);
    16dc:	a3 e5       	ldi	r26, 0x53	; 83
    16de:	b0 e0       	ldi	r27, 0x00	; 0
    16e0:	e3 e5       	ldi	r30, 0x53	; 83
    16e2:	f0 e0       	ldi	r31, 0x00	; 0
    16e4:	80 81       	ld	r24, Z
    16e6:	82 60       	ori	r24, 0x02	; 2
    16e8:	8c 93       	st	X, r24
	SET_BIT(TCCR0_Register,2);
    16ea:	a3 e5       	ldi	r26, 0x53	; 83
    16ec:	b0 e0       	ldi	r27, 0x00	; 0
    16ee:	e3 e5       	ldi	r30, 0x53	; 83
    16f0:	f0 e0       	ldi	r31, 0x00	; 0
    16f2:	80 81       	ld	r24, Z
    16f4:	84 60       	ori	r24, 0x04	; 4
    16f6:	8c 93       	st	X, r24

	TCNT0_Register=0x00;
    16f8:	e2 e5       	ldi	r30, 0x52	; 82
    16fa:	f0 e0       	ldi	r31, 0x00	; 0
    16fc:	10 82       	st	Z, r1

}
    16fe:	cf 91       	pop	r28
    1700:	df 91       	pop	r29
    1702:	08 95       	ret

00001704 <Tim0Init>:

void Tim0Init(){
    1704:	df 93       	push	r29
    1706:	cf 93       	push	r28
    1708:	cd b7       	in	r28, 0x3d	; 61
    170a:	de b7       	in	r29, 0x3e	; 62
    CLR_BIT(TCCR0_Register,6);
#elif Timer_MODE == CTC
	CLR_BIT(TCCR0_Register,3);
    SET_BIT(TCCR0_Register,6);
#elif Timer_MODE == FASTPWM
	SET_BIT(TCCR0_Register,3);
    170c:	a3 e5       	ldi	r26, 0x53	; 83
    170e:	b0 e0       	ldi	r27, 0x00	; 0
    1710:	e3 e5       	ldi	r30, 0x53	; 83
    1712:	f0 e0       	ldi	r31, 0x00	; 0
    1714:	80 81       	ld	r24, Z
    1716:	88 60       	ori	r24, 0x08	; 8
    1718:	8c 93       	st	X, r24
    SET_BIT(TCCR0_Register,6);
    171a:	a3 e5       	ldi	r26, 0x53	; 83
    171c:	b0 e0       	ldi	r27, 0x00	; 0
    171e:	e3 e5       	ldi	r30, 0x53	; 83
    1720:	f0 e0       	ldi	r31, 0x00	; 0
    1722:	80 81       	ld	r24, Z
    1724:	80 64       	ori	r24, 0x40	; 64
    1726:	8c 93       	st	X, r24
#endif



	//for PWM mode selection
	CLR_BIT(TCCR0_Register,4);
    1728:	a3 e5       	ldi	r26, 0x53	; 83
    172a:	b0 e0       	ldi	r27, 0x00	; 0
    172c:	e3 e5       	ldi	r30, 0x53	; 83
    172e:	f0 e0       	ldi	r31, 0x00	; 0
    1730:	80 81       	ld	r24, Z
    1732:	8f 7e       	andi	r24, 0xEF	; 239
    1734:	8c 93       	st	X, r24
	SET_BIT(TCCR0_Register,5);
    1736:	a3 e5       	ldi	r26, 0x53	; 83
    1738:	b0 e0       	ldi	r27, 0x00	; 0
    173a:	e3 e5       	ldi	r30, 0x53	; 83
    173c:	f0 e0       	ldi	r31, 0x00	; 0
    173e:	80 81       	ld	r24, Z
    1740:	80 62       	ori	r24, 0x20	; 32
    1742:	8c 93       	st	X, r24

	TCNT0_Register=0;
    1744:	e2 e5       	ldi	r30, 0x52	; 82
    1746:	f0 e0       	ldi	r31, 0x00	; 0
    1748:	10 82       	st	Z, r1

	SET_BIT(TCCR0_Register,1); //set prescaler to /8
    174a:	a3 e5       	ldi	r26, 0x53	; 83
    174c:	b0 e0       	ldi	r27, 0x00	; 0
    174e:	e3 e5       	ldi	r30, 0x53	; 83
    1750:	f0 e0       	ldi	r31, 0x00	; 0
    1752:	80 81       	ld	r24, Z
    1754:	82 60       	ori	r24, 0x02	; 2
    1756:	8c 93       	st	X, r24


}
    1758:	cf 91       	pop	r28
    175a:	df 91       	pop	r29
    175c:	08 95       	ret

0000175e <TIM0_voidSetTimerReg>:

void TIM0_voidSetTimerReg(u8 Copy_u8Value){
    175e:	df 93       	push	r29
    1760:	cf 93       	push	r28
    1762:	0f 92       	push	r0
    1764:	cd b7       	in	r28, 0x3d	; 61
    1766:	de b7       	in	r29, 0x3e	; 62
    1768:	89 83       	std	Y+1, r24	; 0x01
	TCNT0_Register=Copy_u8Value;
    176a:	e2 e5       	ldi	r30, 0x52	; 82
    176c:	f0 e0       	ldi	r31, 0x00	; 0
    176e:	89 81       	ldd	r24, Y+1	; 0x01
    1770:	80 83       	st	Z, r24
}
    1772:	0f 90       	pop	r0
    1774:	cf 91       	pop	r28
    1776:	df 91       	pop	r29
    1778:	08 95       	ret

0000177a <TIM0_voidSetCompareVal>:

void TIM0_voidSetCompareVal(u8 Copy_u8Value){
    177a:	df 93       	push	r29
    177c:	cf 93       	push	r28
    177e:	0f 92       	push	r0
    1780:	cd b7       	in	r28, 0x3d	; 61
    1782:	de b7       	in	r29, 0x3e	; 62
    1784:	89 83       	std	Y+1, r24	; 0x01
	OCR0_Register=Copy_u8Value;
    1786:	ec e5       	ldi	r30, 0x5C	; 92
    1788:	f0 e0       	ldi	r31, 0x00	; 0
    178a:	89 81       	ldd	r24, Y+1	; 0x01
    178c:	80 83       	st	Z, r24
}
    178e:	0f 90       	pop	r0
    1790:	cf 91       	pop	r28
    1792:	df 91       	pop	r29
    1794:	08 95       	ret

00001796 <CounterGetValue>:

u8 CounterGetValue(){
    1796:	df 93       	push	r29
    1798:	cf 93       	push	r28
    179a:	cd b7       	in	r28, 0x3d	; 61
    179c:	de b7       	in	r29, 0x3e	; 62
	return TCNT0_Register;
    179e:	e2 e5       	ldi	r30, 0x52	; 82
    17a0:	f0 e0       	ldi	r31, 0x00	; 0
    17a2:	80 81       	ld	r24, Z
}
    17a4:	cf 91       	pop	r28
    17a6:	df 91       	pop	r29
    17a8:	08 95       	ret

000017aa <Tim0_VID_SET_CALL_BACK>:

void Tim0_VID_SET_CALL_BACK(void (*PTR)(void)){
    17aa:	df 93       	push	r29
    17ac:	cf 93       	push	r28
    17ae:	00 d0       	rcall	.+0      	; 0x17b0 <Tim0_VID_SET_CALL_BACK+0x6>
    17b0:	cd b7       	in	r28, 0x3d	; 61
    17b2:	de b7       	in	r29, 0x3e	; 62
    17b4:	9a 83       	std	Y+2, r25	; 0x02
    17b6:	89 83       	std	Y+1, r24	; 0x01
	callback_PTR=PTR;
    17b8:	89 81       	ldd	r24, Y+1	; 0x01
    17ba:	9a 81       	ldd	r25, Y+2	; 0x02
    17bc:	90 93 75 01 	sts	0x0175, r25
    17c0:	80 93 74 01 	sts	0x0174, r24
}
    17c4:	0f 90       	pop	r0
    17c6:	0f 90       	pop	r0
    17c8:	cf 91       	pop	r28
    17ca:	df 91       	pop	r29
    17cc:	08 95       	ret

000017ce <__vector_11>:

void __vector_11 (void) __attribute__ ((signal,used,externally_visible)); //to avoid optmization
void __vector_11 (void){
    17ce:	1f 92       	push	r1
    17d0:	0f 92       	push	r0
    17d2:	0f b6       	in	r0, 0x3f	; 63
    17d4:	0f 92       	push	r0
    17d6:	00 90 5b 00 	lds	r0, 0x005B
    17da:	0f 92       	push	r0
    17dc:	11 24       	eor	r1, r1
    17de:	2f 93       	push	r18
    17e0:	3f 93       	push	r19
    17e2:	4f 93       	push	r20
    17e4:	5f 93       	push	r21
    17e6:	6f 93       	push	r22
    17e8:	7f 93       	push	r23
    17ea:	8f 93       	push	r24
    17ec:	9f 93       	push	r25
    17ee:	af 93       	push	r26
    17f0:	bf 93       	push	r27
    17f2:	ef 93       	push	r30
    17f4:	ff 93       	push	r31
    17f6:	df 93       	push	r29
    17f8:	cf 93       	push	r28
    17fa:	cd b7       	in	r28, 0x3d	; 61
    17fc:	de b7       	in	r29, 0x3e	; 62
callback_PTR();
    17fe:	e0 91 74 01 	lds	r30, 0x0174
    1802:	f0 91 75 01 	lds	r31, 0x0175
    1806:	09 95       	icall
}
    1808:	cf 91       	pop	r28
    180a:	df 91       	pop	r29
    180c:	ff 91       	pop	r31
    180e:	ef 91       	pop	r30
    1810:	bf 91       	pop	r27
    1812:	af 91       	pop	r26
    1814:	9f 91       	pop	r25
    1816:	8f 91       	pop	r24
    1818:	7f 91       	pop	r23
    181a:	6f 91       	pop	r22
    181c:	5f 91       	pop	r21
    181e:	4f 91       	pop	r20
    1820:	3f 91       	pop	r19
    1822:	2f 91       	pop	r18
    1824:	0f 90       	pop	r0
    1826:	00 92 5b 00 	sts	0x005B, r0
    182a:	0f 90       	pop	r0
    182c:	0f be       	out	0x3f, r0	; 63
    182e:	0f 90       	pop	r0
    1830:	1f 90       	pop	r1
    1832:	18 95       	reti

00001834 <WDG_On>:


void WDG_On(void){
    1834:	df 93       	push	r29
    1836:	cf 93       	push	r28
    1838:	cd b7       	in	r28, 0x3d	; 61
    183a:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(WDTCR,3);
    183c:	a1 e4       	ldi	r26, 0x41	; 65
    183e:	b0 e0       	ldi	r27, 0x00	; 0
    1840:	e1 e4       	ldi	r30, 0x41	; 65
    1842:	f0 e0       	ldi	r31, 0x00	; 0
    1844:	80 81       	ld	r24, Z
    1846:	88 60       	ori	r24, 0x08	; 8
    1848:	8c 93       	st	X, r24
#elif WDG_PRESCALE==WDG_TIME_OUT_52_S
	SET_BIT(WDTCR,0);
	CLR_BIT(WDTCR,1);
	SET_BIT(WDTCR,2);
#elif WDG_PRESCALE==WDG_TIME_OUT_1_S
	CLR_BIT(WDTCR,0);
    184a:	a1 e4       	ldi	r26, 0x41	; 65
    184c:	b0 e0       	ldi	r27, 0x00	; 0
    184e:	e1 e4       	ldi	r30, 0x41	; 65
    1850:	f0 e0       	ldi	r31, 0x00	; 0
    1852:	80 81       	ld	r24, Z
    1854:	8e 7f       	andi	r24, 0xFE	; 254
    1856:	8c 93       	st	X, r24
	SET_BIT(WDTCR,1);
    1858:	a1 e4       	ldi	r26, 0x41	; 65
    185a:	b0 e0       	ldi	r27, 0x00	; 0
    185c:	e1 e4       	ldi	r30, 0x41	; 65
    185e:	f0 e0       	ldi	r31, 0x00	; 0
    1860:	80 81       	ld	r24, Z
    1862:	82 60       	ori	r24, 0x02	; 2
    1864:	8c 93       	st	X, r24
	SET_BIT(WDTCR,2);
    1866:	a1 e4       	ldi	r26, 0x41	; 65
    1868:	b0 e0       	ldi	r27, 0x00	; 0
    186a:	e1 e4       	ldi	r30, 0x41	; 65
    186c:	f0 e0       	ldi	r31, 0x00	; 0
    186e:	80 81       	ld	r24, Z
    1870:	84 60       	ori	r24, 0x04	; 4
    1872:	8c 93       	st	X, r24
#elif WDG_PRESCALE==WDG_TIME_OUT_21_S
	SET_BIT(WDTCR,0);
	SETBIT(WDTCR,1);
	SET_BIT(WDTCR,2);
#endif
}
    1874:	cf 91       	pop	r28
    1876:	df 91       	pop	r29
    1878:	08 95       	ret

0000187a <WDG_Off>:

void WDG_Off(void){
    187a:	df 93       	push	r29
    187c:	cf 93       	push	r28
    187e:	cd b7       	in	r28, 0x3d	; 61
    1880:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(WDTCR,3);
    1882:	a1 e4       	ldi	r26, 0x41	; 65
    1884:	b0 e0       	ldi	r27, 0x00	; 0
    1886:	e1 e4       	ldi	r30, 0x41	; 65
    1888:	f0 e0       	ldi	r31, 0x00	; 0
    188a:	80 81       	ld	r24, Z
    188c:	87 7f       	andi	r24, 0xF7	; 247
    188e:	8c 93       	st	X, r24
	SET_BIT(WDTCR,4);
    1890:	a1 e4       	ldi	r26, 0x41	; 65
    1892:	b0 e0       	ldi	r27, 0x00	; 0
    1894:	e1 e4       	ldi	r30, 0x41	; 65
    1896:	f0 e0       	ldi	r31, 0x00	; 0
    1898:	80 81       	ld	r24, Z
    189a:	80 61       	ori	r24, 0x10	; 16
    189c:	8c 93       	st	X, r24
}
    189e:	cf 91       	pop	r28
    18a0:	df 91       	pop	r29
    18a2:	08 95       	ret

000018a4 <WDG_Refresh>:

void WDG_Refresh(void){
    18a4:	df 93       	push	r29
    18a6:	cf 93       	push	r28
    18a8:	cd b7       	in	r28, 0x3d	; 61
    18aa:	de b7       	in	r29, 0x3e	; 62
	asm("WDR");
    18ac:	a8 95       	wdr
}
    18ae:	cf 91       	pop	r28
    18b0:	df 91       	pop	r29
    18b2:	08 95       	ret

000018b4 <KPD_vidINIT>:
/*              pressed at the same time                               	     		   */
/* Input      ! Nothing                                                                */
/* Output     ! Nothing                                                                */
/***************************************************************************************/
void KPD_vidINIT(void)
{
    18b4:	df 93       	push	r29
    18b6:	cf 93       	push	r28
    18b8:	00 d0       	rcall	.+0      	; 0x18ba <KPD_vidINIT+0x6>
    18ba:	cd b7       	in	r28, 0x3d	; 61
    18bc:	de b7       	in	r29, 0x3e	; 62

	u8 LOC_u8Column;

	u8 LOC_u8Row;

	for (LOC_u8Column = 0 + COL_INIT; LOC_u8Column < COL_FIN; LOC_u8Column++) {
    18be:	1a 82       	std	Y+2, r1	; 0x02
    18c0:	08 c0       	rjmp	.+16     	; 0x18d2 <KPD_vidINIT+0x1e>
		/* DIRECTION of  the Column                                                                                           */
		DIO_voidSetPinDirection(PORT, LOC_u8Column, PIN_OUTPUT);
    18c2:	80 e0       	ldi	r24, 0x00	; 0
    18c4:	6a 81       	ldd	r22, Y+2	; 0x02
    18c6:	41 e0       	ldi	r20, 0x01	; 1
    18c8:	0e 94 31 08 	call	0x1062	; 0x1062 <DIO_voidSetPinDirection>

	u8 LOC_u8Column;

	u8 LOC_u8Row;

	for (LOC_u8Column = 0 + COL_INIT; LOC_u8Column < COL_FIN; LOC_u8Column++) {
    18cc:	8a 81       	ldd	r24, Y+2	; 0x02
    18ce:	8f 5f       	subi	r24, 0xFF	; 255
    18d0:	8a 83       	std	Y+2, r24	; 0x02
    18d2:	8a 81       	ldd	r24, Y+2	; 0x02
    18d4:	84 30       	cpi	r24, 0x04	; 4
    18d6:	a8 f3       	brcs	.-22     	; 0x18c2 <KPD_vidINIT+0xe>
		DIO_voidSetPinDirection(PORT, LOC_u8Column, PIN_OUTPUT);

	}

	/* SET rows to input PULLUP                                                                               */
	for (LOC_u8Row = 0 + ROW_INIT; LOC_u8Row < ROW_FIN; LOC_u8Row++) {
    18d8:	84 e0       	ldi	r24, 0x04	; 4
    18da:	89 83       	std	Y+1, r24	; 0x01
    18dc:	0d c0       	rjmp	.+26     	; 0x18f8 <KPD_vidINIT+0x44>
		DIO_voidSetPinDirection(PORT, LOC_u8Row, PIN_INPUT);
    18de:	80 e0       	ldi	r24, 0x00	; 0
    18e0:	69 81       	ldd	r22, Y+1	; 0x01
    18e2:	40 e0       	ldi	r20, 0x00	; 0
    18e4:	0e 94 31 08 	call	0x1062	; 0x1062 <DIO_voidSetPinDirection>
		DIO_voidSetPinValue(PORT, LOC_u8Row, PIN_HIGH);
    18e8:	80 e0       	ldi	r24, 0x00	; 0
    18ea:	69 81       	ldd	r22, Y+1	; 0x01
    18ec:	41 e0       	ldi	r20, 0x01	; 1
    18ee:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
		DIO_voidSetPinDirection(PORT, LOC_u8Column, PIN_OUTPUT);

	}

	/* SET rows to input PULLUP                                                                               */
	for (LOC_u8Row = 0 + ROW_INIT; LOC_u8Row < ROW_FIN; LOC_u8Row++) {
    18f2:	89 81       	ldd	r24, Y+1	; 0x01
    18f4:	8f 5f       	subi	r24, 0xFF	; 255
    18f6:	89 83       	std	Y+1, r24	; 0x01
    18f8:	89 81       	ldd	r24, Y+1	; 0x01
    18fa:	88 30       	cpi	r24, 0x08	; 8
    18fc:	80 f3       	brcs	.-32     	; 0x18de <KPD_vidINIT+0x2a>
		DIO_voidSetPinDirection(PORT, LOC_u8Row, PIN_INPUT);
		DIO_voidSetPinValue(PORT, LOC_u8Row, PIN_HIGH);
	}


}
    18fe:	0f 90       	pop	r0
    1900:	0f 90       	pop	r0
    1902:	cf 91       	pop	r28
    1904:	df 91       	pop	r29
    1906:	08 95       	ret

00001908 <KPD_u8GetPressedKey>:

u8 KPD_u8GetPressedKey(void)
{
    1908:	df 93       	push	r29
    190a:	cf 93       	push	r28
    190c:	cd b7       	in	r28, 0x3d	; 61
    190e:	de b7       	in	r29, 0x3e	; 62
    1910:	61 97       	sbiw	r28, 0x11	; 17
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	f8 94       	cli
    1916:	de bf       	out	0x3e, r29	; 62
    1918:	0f be       	out	0x3f, r0	; 63
    191a:	cd bf       	out	0x3d, r28	; 61
  u8 LOC_u8Column;

  u8 LOC_u8Row;

  /* Initialize the switch status to NOT Pressed                                                                     */
  u8 LOC_u8Retrun = NOT_PRESSED;
    191c:	1f 86       	std	Y+15, r1	; 0x0f

  /* Looping on columns of the Key Pad                                                                               */
  for (LOC_u8Column = 0 + COL_INIT; LOC_u8Column < COL_FIN; LOC_u8Column++)
    191e:	19 8a       	std	Y+17, r1	; 0x11
    1920:	ab c0       	rjmp	.+342    	; 0x1a78 <KPD_u8GetPressedKey+0x170>
  {
    /* Activate the Column                                                                                           */
	  DIO_voidSetPinValue(PORT, LOC_u8Column, PIN_LOW);
    1922:	80 e0       	ldi	r24, 0x00	; 0
    1924:	69 89       	ldd	r22, Y+17	; 0x11
    1926:	40 e0       	ldi	r20, 0x00	; 0
    1928:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>

    /* Loop on the rows of the Key Pad                                                                               */
    for (LOC_u8Row = 0 + ROW_INIT; LOC_u8Row < ROW_FIN; LOC_u8Row++)
    192c:	84 e0       	ldi	r24, 0x04	; 4
    192e:	88 8b       	std	Y+16, r24	; 0x10
    1930:	97 c0       	rjmp	.+302    	; 0x1a60 <KPD_u8GetPressedKey+0x158>
    {
      /* Check the status of the switch                                                                              */
      if (!DIO_u8GetPinValue(PORT, LOC_u8Row))
    1932:	80 e0       	ldi	r24, 0x00	; 0
    1934:	68 89       	ldd	r22, Y+16	; 0x10
    1936:	0e 94 b0 07 	call	0xf60	; 0xf60 <DIO_u8GetPinValue>
    193a:	88 23       	and	r24, r24
    193c:	09 f0       	breq	.+2      	; 0x1940 <KPD_u8GetPressedKey+0x38>
    193e:	8d c0       	rjmp	.+282    	; 0x1a5a <KPD_u8GetPressedKey+0x152>
      {
        /* Get the value of the currently pressed switch                                                             */
        LOC_u8Retrun = KPD_au8SwitchVal[LOC_u8Column - COL_INIT][LOC_u8Row - ROW_INIT];
    1940:	89 89       	ldd	r24, Y+17	; 0x11
    1942:	48 2f       	mov	r20, r24
    1944:	50 e0       	ldi	r21, 0x00	; 0
    1946:	88 89       	ldd	r24, Y+16	; 0x10
    1948:	88 2f       	mov	r24, r24
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	9c 01       	movw	r18, r24
    194e:	24 50       	subi	r18, 0x04	; 4
    1950:	30 40       	sbci	r19, 0x00	; 0
    1952:	ca 01       	movw	r24, r20
    1954:	88 0f       	add	r24, r24
    1956:	99 1f       	adc	r25, r25
    1958:	88 0f       	add	r24, r24
    195a:	99 1f       	adc	r25, r25
    195c:	82 0f       	add	r24, r18
    195e:	93 1f       	adc	r25, r19
    1960:	fc 01       	movw	r30, r24
    1962:	ef 59       	subi	r30, 0x9F	; 159
    1964:	fe 4f       	sbci	r31, 0xFE	; 254
    1966:	80 81       	ld	r24, Z
    1968:	8f 87       	std	Y+15, r24	; 0x0f

        /* Wait until the switch is released (Single Press)                                                          */
        while (!DIO_u8GetPinValue(PORT, LOC_u8Row))
    196a:	80 e0       	ldi	r24, 0x00	; 0
    196c:	68 89       	ldd	r22, Y+16	; 0x10
    196e:	0e 94 b0 07 	call	0xf60	; 0xf60 <DIO_u8GetPinValue>
    1972:	88 23       	and	r24, r24
    1974:	d1 f3       	breq	.-12     	; 0x196a <KPD_u8GetPressedKey+0x62>
    1976:	80 e0       	ldi	r24, 0x00	; 0
    1978:	90 e0       	ldi	r25, 0x00	; 0
    197a:	a0 e2       	ldi	r26, 0x20	; 32
    197c:	b1 e4       	ldi	r27, 0x41	; 65
    197e:	8b 87       	std	Y+11, r24	; 0x0b
    1980:	9c 87       	std	Y+12, r25	; 0x0c
    1982:	ad 87       	std	Y+13, r26	; 0x0d
    1984:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1986:	6b 85       	ldd	r22, Y+11	; 0x0b
    1988:	7c 85       	ldd	r23, Y+12	; 0x0c
    198a:	8d 85       	ldd	r24, Y+13	; 0x0d
    198c:	9e 85       	ldd	r25, Y+14	; 0x0e
    198e:	20 e0       	ldi	r18, 0x00	; 0
    1990:	30 e0       	ldi	r19, 0x00	; 0
    1992:	4a ef       	ldi	r20, 0xFA	; 250
    1994:	54 e4       	ldi	r21, 0x44	; 68
    1996:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    199a:	dc 01       	movw	r26, r24
    199c:	cb 01       	movw	r24, r22
    199e:	8f 83       	std	Y+7, r24	; 0x07
    19a0:	98 87       	std	Y+8, r25	; 0x08
    19a2:	a9 87       	std	Y+9, r26	; 0x09
    19a4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    19a6:	6f 81       	ldd	r22, Y+7	; 0x07
    19a8:	78 85       	ldd	r23, Y+8	; 0x08
    19aa:	89 85       	ldd	r24, Y+9	; 0x09
    19ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    19ae:	20 e0       	ldi	r18, 0x00	; 0
    19b0:	30 e0       	ldi	r19, 0x00	; 0
    19b2:	40 e8       	ldi	r20, 0x80	; 128
    19b4:	5f e3       	ldi	r21, 0x3F	; 63
    19b6:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    19ba:	88 23       	and	r24, r24
    19bc:	2c f4       	brge	.+10     	; 0x19c8 <KPD_u8GetPressedKey+0xc0>
		__ticks = 1;
    19be:	81 e0       	ldi	r24, 0x01	; 1
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	9e 83       	std	Y+6, r25	; 0x06
    19c4:	8d 83       	std	Y+5, r24	; 0x05
    19c6:	3f c0       	rjmp	.+126    	; 0x1a46 <KPD_u8GetPressedKey+0x13e>
	else if (__tmp > 65535)
    19c8:	6f 81       	ldd	r22, Y+7	; 0x07
    19ca:	78 85       	ldd	r23, Y+8	; 0x08
    19cc:	89 85       	ldd	r24, Y+9	; 0x09
    19ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    19d0:	20 e0       	ldi	r18, 0x00	; 0
    19d2:	3f ef       	ldi	r19, 0xFF	; 255
    19d4:	4f e7       	ldi	r20, 0x7F	; 127
    19d6:	57 e4       	ldi	r21, 0x47	; 71
    19d8:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    19dc:	18 16       	cp	r1, r24
    19de:	4c f5       	brge	.+82     	; 0x1a32 <KPD_u8GetPressedKey+0x12a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19e0:	6b 85       	ldd	r22, Y+11	; 0x0b
    19e2:	7c 85       	ldd	r23, Y+12	; 0x0c
    19e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    19e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    19e8:	20 e0       	ldi	r18, 0x00	; 0
    19ea:	30 e0       	ldi	r19, 0x00	; 0
    19ec:	40 e2       	ldi	r20, 0x20	; 32
    19ee:	51 e4       	ldi	r21, 0x41	; 65
    19f0:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    19f4:	dc 01       	movw	r26, r24
    19f6:	cb 01       	movw	r24, r22
    19f8:	bc 01       	movw	r22, r24
    19fa:	cd 01       	movw	r24, r26
    19fc:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1a00:	dc 01       	movw	r26, r24
    1a02:	cb 01       	movw	r24, r22
    1a04:	9e 83       	std	Y+6, r25	; 0x06
    1a06:	8d 83       	std	Y+5, r24	; 0x05
    1a08:	0f c0       	rjmp	.+30     	; 0x1a28 <KPD_u8GetPressedKey+0x120>
    1a0a:	88 ec       	ldi	r24, 0xC8	; 200
    1a0c:	90 e0       	ldi	r25, 0x00	; 0
    1a0e:	9c 83       	std	Y+4, r25	; 0x04
    1a10:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1a12:	8b 81       	ldd	r24, Y+3	; 0x03
    1a14:	9c 81       	ldd	r25, Y+4	; 0x04
    1a16:	01 97       	sbiw	r24, 0x01	; 1
    1a18:	f1 f7       	brne	.-4      	; 0x1a16 <KPD_u8GetPressedKey+0x10e>
    1a1a:	9c 83       	std	Y+4, r25	; 0x04
    1a1c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a1e:	8d 81       	ldd	r24, Y+5	; 0x05
    1a20:	9e 81       	ldd	r25, Y+6	; 0x06
    1a22:	01 97       	sbiw	r24, 0x01	; 1
    1a24:	9e 83       	std	Y+6, r25	; 0x06
    1a26:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a28:	8d 81       	ldd	r24, Y+5	; 0x05
    1a2a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a2c:	00 97       	sbiw	r24, 0x00	; 0
    1a2e:	69 f7       	brne	.-38     	; 0x1a0a <KPD_u8GetPressedKey+0x102>
    1a30:	14 c0       	rjmp	.+40     	; 0x1a5a <KPD_u8GetPressedKey+0x152>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a32:	6f 81       	ldd	r22, Y+7	; 0x07
    1a34:	78 85       	ldd	r23, Y+8	; 0x08
    1a36:	89 85       	ldd	r24, Y+9	; 0x09
    1a38:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a3a:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1a3e:	dc 01       	movw	r26, r24
    1a40:	cb 01       	movw	r24, r22
    1a42:	9e 83       	std	Y+6, r25	; 0x06
    1a44:	8d 83       	std	Y+5, r24	; 0x05
    1a46:	8d 81       	ldd	r24, Y+5	; 0x05
    1a48:	9e 81       	ldd	r25, Y+6	; 0x06
    1a4a:	9a 83       	std	Y+2, r25	; 0x02
    1a4c:	89 83       	std	Y+1, r24	; 0x01
    1a4e:	89 81       	ldd	r24, Y+1	; 0x01
    1a50:	9a 81       	ldd	r25, Y+2	; 0x02
    1a52:	01 97       	sbiw	r24, 0x01	; 1
    1a54:	f1 f7       	brne	.-4      	; 0x1a52 <KPD_u8GetPressedKey+0x14a>
    1a56:	9a 83       	std	Y+2, r25	; 0x02
    1a58:	89 83       	std	Y+1, r24	; 0x01
  {
    /* Activate the Column                                                                                           */
	  DIO_voidSetPinValue(PORT, LOC_u8Column, PIN_LOW);

    /* Loop on the rows of the Key Pad                                                                               */
    for (LOC_u8Row = 0 + ROW_INIT; LOC_u8Row < ROW_FIN; LOC_u8Row++)
    1a5a:	88 89       	ldd	r24, Y+16	; 0x10
    1a5c:	8f 5f       	subi	r24, 0xFF	; 255
    1a5e:	88 8b       	std	Y+16, r24	; 0x10
    1a60:	88 89       	ldd	r24, Y+16	; 0x10
    1a62:	88 30       	cpi	r24, 0x08	; 8
    1a64:	08 f4       	brcc	.+2      	; 0x1a68 <KPD_u8GetPressedKey+0x160>
    1a66:	65 cf       	rjmp	.-310    	; 0x1932 <KPD_u8GetPressedKey+0x2a>

      }
    }

    /* Deactivate the Column                                                                                         */
    DIO_voidSetPinValue(PORT, LOC_u8Column, PIN_HIGH);
    1a68:	80 e0       	ldi	r24, 0x00	; 0
    1a6a:	69 89       	ldd	r22, Y+17	; 0x11
    1a6c:	41 e0       	ldi	r20, 0x01	; 1
    1a6e:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>

  /* Initialize the switch status to NOT Pressed                                                                     */
  u8 LOC_u8Retrun = NOT_PRESSED;

  /* Looping on columns of the Key Pad                                                                               */
  for (LOC_u8Column = 0 + COL_INIT; LOC_u8Column < COL_FIN; LOC_u8Column++)
    1a72:	89 89       	ldd	r24, Y+17	; 0x11
    1a74:	8f 5f       	subi	r24, 0xFF	; 255
    1a76:	89 8b       	std	Y+17, r24	; 0x11
    1a78:	89 89       	ldd	r24, Y+17	; 0x11
    1a7a:	84 30       	cpi	r24, 0x04	; 4
    1a7c:	08 f4       	brcc	.+2      	; 0x1a80 <KPD_u8GetPressedKey+0x178>
    1a7e:	51 cf       	rjmp	.-350    	; 0x1922 <KPD_u8GetPressedKey+0x1a>

    /* Deactivate the Column                                                                                         */
    DIO_voidSetPinValue(PORT, LOC_u8Column, PIN_HIGH);
  }

  return LOC_u8Retrun;
    1a80:	8f 85       	ldd	r24, Y+15	; 0x0f
}
    1a82:	61 96       	adiw	r28, 0x11	; 17
    1a84:	0f b6       	in	r0, 0x3f	; 63
    1a86:	f8 94       	cli
    1a88:	de bf       	out	0x3e, r29	; 62
    1a8a:	0f be       	out	0x3f, r0	; 63
    1a8c:	cd bf       	out	0x3d, r28	; 61
    1a8e:	cf 91       	pop	r28
    1a90:	df 91       	pop	r29
    1a92:	08 95       	ret

00001a94 <LCD_init>:
#include "../MCAL/DIO_register.h"
#include "util/delay.h"


//init
void LCD_init(){
    1a94:	df 93       	push	r29
    1a96:	cf 93       	push	r28
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	2e 97       	sbiw	r28, 0x0e	; 14
    1a9e:	0f b6       	in	r0, 0x3f	; 63
    1aa0:	f8 94       	cli
    1aa2:	de bf       	out	0x3e, r29	; 62
    1aa4:	0f be       	out	0x3f, r0	; 63
    1aa6:	cd bf       	out	0x3d, r28	; 61
//rs=0 and rw=0 and latch ale hwa send 8 bits w b3den en high ,dlay 2ms, b3dha en low ,2ms

DIO_voidSetPinDirection(lcd_DATAPORT,4,DIO_u8_OUTPUT);
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	64 e0       	ldi	r22, 0x04	; 4
    1aac:	41 e0       	ldi	r20, 0x01	; 1
    1aae:	0e 94 31 08 	call	0x1062	; 0x1062 <DIO_voidSetPinDirection>
DIO_voidSetPinDirection(lcd_DATAPORT,5,DIO_u8_OUTPUT);
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	65 e0       	ldi	r22, 0x05	; 5
    1ab6:	41 e0       	ldi	r20, 0x01	; 1
    1ab8:	0e 94 31 08 	call	0x1062	; 0x1062 <DIO_voidSetPinDirection>
DIO_voidSetPinDirection(lcd_DATAPORT,6,DIO_u8_OUTPUT);
    1abc:	81 e0       	ldi	r24, 0x01	; 1
    1abe:	66 e0       	ldi	r22, 0x06	; 6
    1ac0:	41 e0       	ldi	r20, 0x01	; 1
    1ac2:	0e 94 31 08 	call	0x1062	; 0x1062 <DIO_voidSetPinDirection>
DIO_voidSetPinDirection(lcd_DATAPORT,7,DIO_u8_OUTPUT);
    1ac6:	81 e0       	ldi	r24, 0x01	; 1
    1ac8:	67 e0       	ldi	r22, 0x07	; 7
    1aca:	41 e0       	ldi	r20, 0x01	; 1
    1acc:	0e 94 31 08 	call	0x1062	; 0x1062 <DIO_voidSetPinDirection>

DIO_voidSetPinDirection(lcd_CONTROLPORT,lcd_EPIN,DIO_u8_OUTPUT);
    1ad0:	82 e0       	ldi	r24, 0x02	; 2
    1ad2:	62 e0       	ldi	r22, 0x02	; 2
    1ad4:	41 e0       	ldi	r20, 0x01	; 1
    1ad6:	0e 94 31 08 	call	0x1062	; 0x1062 <DIO_voidSetPinDirection>
DIO_voidSetPinDirection(lcd_CONTROLPORT,lcd_RSPIN,DIO_u8_OUTPUT);
    1ada:	82 e0       	ldi	r24, 0x02	; 2
    1adc:	63 e0       	ldi	r22, 0x03	; 3
    1ade:	41 e0       	ldi	r20, 0x01	; 1
    1ae0:	0e 94 31 08 	call	0x1062	; 0x1062 <DIO_voidSetPinDirection>
    1ae4:	80 e0       	ldi	r24, 0x00	; 0
    1ae6:	90 e0       	ldi	r25, 0x00	; 0
    1ae8:	a8 ec       	ldi	r26, 0xC8	; 200
    1aea:	b2 e4       	ldi	r27, 0x42	; 66
    1aec:	8b 87       	std	Y+11, r24	; 0x0b
    1aee:	9c 87       	std	Y+12, r25	; 0x0c
    1af0:	ad 87       	std	Y+13, r26	; 0x0d
    1af2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1af4:	6b 85       	ldd	r22, Y+11	; 0x0b
    1af6:	7c 85       	ldd	r23, Y+12	; 0x0c
    1af8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1afa:	9e 85       	ldd	r25, Y+14	; 0x0e
    1afc:	20 e0       	ldi	r18, 0x00	; 0
    1afe:	30 e0       	ldi	r19, 0x00	; 0
    1b00:	4a ef       	ldi	r20, 0xFA	; 250
    1b02:	54 e4       	ldi	r21, 0x44	; 68
    1b04:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1b08:	dc 01       	movw	r26, r24
    1b0a:	cb 01       	movw	r24, r22
    1b0c:	8f 83       	std	Y+7, r24	; 0x07
    1b0e:	98 87       	std	Y+8, r25	; 0x08
    1b10:	a9 87       	std	Y+9, r26	; 0x09
    1b12:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1b14:	6f 81       	ldd	r22, Y+7	; 0x07
    1b16:	78 85       	ldd	r23, Y+8	; 0x08
    1b18:	89 85       	ldd	r24, Y+9	; 0x09
    1b1a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b1c:	20 e0       	ldi	r18, 0x00	; 0
    1b1e:	30 e0       	ldi	r19, 0x00	; 0
    1b20:	40 e8       	ldi	r20, 0x80	; 128
    1b22:	5f e3       	ldi	r21, 0x3F	; 63
    1b24:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    1b28:	88 23       	and	r24, r24
    1b2a:	2c f4       	brge	.+10     	; 0x1b36 <LCD_init+0xa2>
		__ticks = 1;
    1b2c:	81 e0       	ldi	r24, 0x01	; 1
    1b2e:	90 e0       	ldi	r25, 0x00	; 0
    1b30:	9e 83       	std	Y+6, r25	; 0x06
    1b32:	8d 83       	std	Y+5, r24	; 0x05
    1b34:	3f c0       	rjmp	.+126    	; 0x1bb4 <LCD_init+0x120>
	else if (__tmp > 65535)
    1b36:	6f 81       	ldd	r22, Y+7	; 0x07
    1b38:	78 85       	ldd	r23, Y+8	; 0x08
    1b3a:	89 85       	ldd	r24, Y+9	; 0x09
    1b3c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b3e:	20 e0       	ldi	r18, 0x00	; 0
    1b40:	3f ef       	ldi	r19, 0xFF	; 255
    1b42:	4f e7       	ldi	r20, 0x7F	; 127
    1b44:	57 e4       	ldi	r21, 0x47	; 71
    1b46:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    1b4a:	18 16       	cp	r1, r24
    1b4c:	4c f5       	brge	.+82     	; 0x1ba0 <LCD_init+0x10c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b4e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b50:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b52:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b54:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b56:	20 e0       	ldi	r18, 0x00	; 0
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	40 e2       	ldi	r20, 0x20	; 32
    1b5c:	51 e4       	ldi	r21, 0x41	; 65
    1b5e:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1b62:	dc 01       	movw	r26, r24
    1b64:	cb 01       	movw	r24, r22
    1b66:	bc 01       	movw	r22, r24
    1b68:	cd 01       	movw	r24, r26
    1b6a:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1b6e:	dc 01       	movw	r26, r24
    1b70:	cb 01       	movw	r24, r22
    1b72:	9e 83       	std	Y+6, r25	; 0x06
    1b74:	8d 83       	std	Y+5, r24	; 0x05
    1b76:	0f c0       	rjmp	.+30     	; 0x1b96 <LCD_init+0x102>
    1b78:	88 ec       	ldi	r24, 0xC8	; 200
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	9c 83       	std	Y+4, r25	; 0x04
    1b7e:	8b 83       	std	Y+3, r24	; 0x03
    1b80:	8b 81       	ldd	r24, Y+3	; 0x03
    1b82:	9c 81       	ldd	r25, Y+4	; 0x04
    1b84:	01 97       	sbiw	r24, 0x01	; 1
    1b86:	f1 f7       	brne	.-4      	; 0x1b84 <LCD_init+0xf0>
    1b88:	9c 83       	std	Y+4, r25	; 0x04
    1b8a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b8e:	9e 81       	ldd	r25, Y+6	; 0x06
    1b90:	01 97       	sbiw	r24, 0x01	; 1
    1b92:	9e 83       	std	Y+6, r25	; 0x06
    1b94:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b96:	8d 81       	ldd	r24, Y+5	; 0x05
    1b98:	9e 81       	ldd	r25, Y+6	; 0x06
    1b9a:	00 97       	sbiw	r24, 0x00	; 0
    1b9c:	69 f7       	brne	.-38     	; 0x1b78 <LCD_init+0xe4>
    1b9e:	14 c0       	rjmp	.+40     	; 0x1bc8 <LCD_init+0x134>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ba0:	6f 81       	ldd	r22, Y+7	; 0x07
    1ba2:	78 85       	ldd	r23, Y+8	; 0x08
    1ba4:	89 85       	ldd	r24, Y+9	; 0x09
    1ba6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ba8:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1bac:	dc 01       	movw	r26, r24
    1bae:	cb 01       	movw	r24, r22
    1bb0:	9e 83       	std	Y+6, r25	; 0x06
    1bb2:	8d 83       	std	Y+5, r24	; 0x05
    1bb4:	8d 81       	ldd	r24, Y+5	; 0x05
    1bb6:	9e 81       	ldd	r25, Y+6	; 0x06
    1bb8:	9a 83       	std	Y+2, r25	; 0x02
    1bba:	89 83       	std	Y+1, r24	; 0x01
    1bbc:	89 81       	ldd	r24, Y+1	; 0x01
    1bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc0:	01 97       	sbiw	r24, 0x01	; 1
    1bc2:	f1 f7       	brne	.-4      	; 0x1bc0 <LCD_init+0x12c>
    1bc4:	9a 83       	std	Y+2, r25	; 0x02
    1bc6:	89 83       	std	Y+1, r24	; 0x01


	_delay_ms(100);

		LCD_SendCommand(0x02);
    1bc8:	82 e0       	ldi	r24, 0x02	; 2
    1bca:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>
		LCD_SendCommand(0x28);
    1bce:	88 e2       	ldi	r24, 0x28	; 40
    1bd0:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>
		LCD_SendCommand(0x0c);
    1bd4:	8c e0       	ldi	r24, 0x0C	; 12
    1bd6:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>
		LCD_SendCommand(0x01);
    1bda:	81 e0       	ldi	r24, 0x01	; 1
    1bdc:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>
		LCD_SendCommand(0x06);
    1be0:	86 e0       	ldi	r24, 0x06	; 6
    1be2:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>
		LCD_SendCommand(0x80);
    1be6:	80 e8       	ldi	r24, 0x80	; 128
    1be8:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>
}
    1bec:	2e 96       	adiw	r28, 0x0e	; 14
    1bee:	0f b6       	in	r0, 0x3f	; 63
    1bf0:	f8 94       	cli
    1bf2:	de bf       	out	0x3e, r29	; 62
    1bf4:	0f be       	out	0x3f, r0	; 63
    1bf6:	cd bf       	out	0x3d, r28	; 61
    1bf8:	cf 91       	pop	r28
    1bfa:	df 91       	pop	r29
    1bfc:	08 95       	ret

00001bfe <LCD_sendChar>:

//char
  void LCD_sendChar(u8 Data){
    1bfe:	df 93       	push	r29
    1c00:	cf 93       	push	r28
    1c02:	cd b7       	in	r28, 0x3d	; 61
    1c04:	de b7       	in	r29, 0x3e	; 62
    1c06:	e9 97       	sbiw	r28, 0x39	; 57
    1c08:	0f b6       	in	r0, 0x3f	; 63
    1c0a:	f8 94       	cli
    1c0c:	de bf       	out	0x3e, r29	; 62
    1c0e:	0f be       	out	0x3f, r0	; 63
    1c10:	cd bf       	out	0x3d, r28	; 61
    1c12:	89 af       	std	Y+57, r24	; 0x39


	       /* Set RS to high */
	  	  	DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_RSPIN,1);
    1c14:	82 e0       	ldi	r24, 0x02	; 2
    1c16:	63 e0       	ldi	r22, 0x03	; 3
    1c18:	41 e0       	ldi	r20, 0x01	; 1
    1c1a:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>

			DIO_voidSetPinValue(lcd_DATAPORT,4,GET_BIT(Data,4));
    1c1e:	89 ad       	ldd	r24, Y+57	; 0x39
    1c20:	82 95       	swap	r24
    1c22:	8f 70       	andi	r24, 0x0F	; 15
    1c24:	98 2f       	mov	r25, r24
    1c26:	91 70       	andi	r25, 0x01	; 1
    1c28:	81 e0       	ldi	r24, 0x01	; 1
    1c2a:	64 e0       	ldi	r22, 0x04	; 4
    1c2c:	49 2f       	mov	r20, r25
    1c2e:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
			DIO_voidSetPinValue(lcd_DATAPORT,5,GET_BIT(Data,5));
    1c32:	89 ad       	ldd	r24, Y+57	; 0x39
    1c34:	82 95       	swap	r24
    1c36:	86 95       	lsr	r24
    1c38:	87 70       	andi	r24, 0x07	; 7
    1c3a:	98 2f       	mov	r25, r24
    1c3c:	91 70       	andi	r25, 0x01	; 1
    1c3e:	81 e0       	ldi	r24, 0x01	; 1
    1c40:	65 e0       	ldi	r22, 0x05	; 5
    1c42:	49 2f       	mov	r20, r25
    1c44:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
			DIO_voidSetPinValue(lcd_DATAPORT,6,GET_BIT(Data,6));
    1c48:	89 ad       	ldd	r24, Y+57	; 0x39
    1c4a:	82 95       	swap	r24
    1c4c:	86 95       	lsr	r24
    1c4e:	86 95       	lsr	r24
    1c50:	83 70       	andi	r24, 0x03	; 3
    1c52:	98 2f       	mov	r25, r24
    1c54:	91 70       	andi	r25, 0x01	; 1
    1c56:	81 e0       	ldi	r24, 0x01	; 1
    1c58:	66 e0       	ldi	r22, 0x06	; 6
    1c5a:	49 2f       	mov	r20, r25
    1c5c:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
			DIO_voidSetPinValue(lcd_DATAPORT,7,GET_BIT(Data,7));
    1c60:	89 ad       	ldd	r24, Y+57	; 0x39
    1c62:	98 2f       	mov	r25, r24
    1c64:	99 1f       	adc	r25, r25
    1c66:	99 27       	eor	r25, r25
    1c68:	99 1f       	adc	r25, r25
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	67 e0       	ldi	r22, 0x07	; 7
    1c6e:	49 2f       	mov	r20, r25
    1c70:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>

		    //latch
			DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_EPIN,1);
    1c74:	82 e0       	ldi	r24, 0x02	; 2
    1c76:	62 e0       	ldi	r22, 0x02	; 2
    1c78:	41 e0       	ldi	r20, 0x01	; 1
    1c7a:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    1c7e:	80 e0       	ldi	r24, 0x00	; 0
    1c80:	90 e0       	ldi	r25, 0x00	; 0
    1c82:	a0 e0       	ldi	r26, 0x00	; 0
    1c84:	b0 e4       	ldi	r27, 0x40	; 64
    1c86:	8d ab       	std	Y+53, r24	; 0x35
    1c88:	9e ab       	std	Y+54, r25	; 0x36
    1c8a:	af ab       	std	Y+55, r26	; 0x37
    1c8c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c8e:	6d a9       	ldd	r22, Y+53	; 0x35
    1c90:	7e a9       	ldd	r23, Y+54	; 0x36
    1c92:	8f a9       	ldd	r24, Y+55	; 0x37
    1c94:	98 ad       	ldd	r25, Y+56	; 0x38
    1c96:	20 e0       	ldi	r18, 0x00	; 0
    1c98:	30 e0       	ldi	r19, 0x00	; 0
    1c9a:	4a ef       	ldi	r20, 0xFA	; 250
    1c9c:	54 e4       	ldi	r21, 0x44	; 68
    1c9e:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1ca2:	dc 01       	movw	r26, r24
    1ca4:	cb 01       	movw	r24, r22
    1ca6:	89 ab       	std	Y+49, r24	; 0x31
    1ca8:	9a ab       	std	Y+50, r25	; 0x32
    1caa:	ab ab       	std	Y+51, r26	; 0x33
    1cac:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1cae:	69 a9       	ldd	r22, Y+49	; 0x31
    1cb0:	7a a9       	ldd	r23, Y+50	; 0x32
    1cb2:	8b a9       	ldd	r24, Y+51	; 0x33
    1cb4:	9c a9       	ldd	r25, Y+52	; 0x34
    1cb6:	20 e0       	ldi	r18, 0x00	; 0
    1cb8:	30 e0       	ldi	r19, 0x00	; 0
    1cba:	40 e8       	ldi	r20, 0x80	; 128
    1cbc:	5f e3       	ldi	r21, 0x3F	; 63
    1cbe:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    1cc2:	88 23       	and	r24, r24
    1cc4:	2c f4       	brge	.+10     	; 0x1cd0 <LCD_sendChar+0xd2>
		__ticks = 1;
    1cc6:	81 e0       	ldi	r24, 0x01	; 1
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	98 ab       	std	Y+48, r25	; 0x30
    1ccc:	8f a7       	std	Y+47, r24	; 0x2f
    1cce:	3f c0       	rjmp	.+126    	; 0x1d4e <LCD_sendChar+0x150>
	else if (__tmp > 65535)
    1cd0:	69 a9       	ldd	r22, Y+49	; 0x31
    1cd2:	7a a9       	ldd	r23, Y+50	; 0x32
    1cd4:	8b a9       	ldd	r24, Y+51	; 0x33
    1cd6:	9c a9       	ldd	r25, Y+52	; 0x34
    1cd8:	20 e0       	ldi	r18, 0x00	; 0
    1cda:	3f ef       	ldi	r19, 0xFF	; 255
    1cdc:	4f e7       	ldi	r20, 0x7F	; 127
    1cde:	57 e4       	ldi	r21, 0x47	; 71
    1ce0:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    1ce4:	18 16       	cp	r1, r24
    1ce6:	4c f5       	brge	.+82     	; 0x1d3a <LCD_sendChar+0x13c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ce8:	6d a9       	ldd	r22, Y+53	; 0x35
    1cea:	7e a9       	ldd	r23, Y+54	; 0x36
    1cec:	8f a9       	ldd	r24, Y+55	; 0x37
    1cee:	98 ad       	ldd	r25, Y+56	; 0x38
    1cf0:	20 e0       	ldi	r18, 0x00	; 0
    1cf2:	30 e0       	ldi	r19, 0x00	; 0
    1cf4:	40 e2       	ldi	r20, 0x20	; 32
    1cf6:	51 e4       	ldi	r21, 0x41	; 65
    1cf8:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1cfc:	dc 01       	movw	r26, r24
    1cfe:	cb 01       	movw	r24, r22
    1d00:	bc 01       	movw	r22, r24
    1d02:	cd 01       	movw	r24, r26
    1d04:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1d08:	dc 01       	movw	r26, r24
    1d0a:	cb 01       	movw	r24, r22
    1d0c:	98 ab       	std	Y+48, r25	; 0x30
    1d0e:	8f a7       	std	Y+47, r24	; 0x2f
    1d10:	0f c0       	rjmp	.+30     	; 0x1d30 <LCD_sendChar+0x132>
    1d12:	88 ec       	ldi	r24, 0xC8	; 200
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	9e a7       	std	Y+46, r25	; 0x2e
    1d18:	8d a7       	std	Y+45, r24	; 0x2d
    1d1a:	8d a5       	ldd	r24, Y+45	; 0x2d
    1d1c:	9e a5       	ldd	r25, Y+46	; 0x2e
    1d1e:	01 97       	sbiw	r24, 0x01	; 1
    1d20:	f1 f7       	brne	.-4      	; 0x1d1e <LCD_sendChar+0x120>
    1d22:	9e a7       	std	Y+46, r25	; 0x2e
    1d24:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d26:	8f a5       	ldd	r24, Y+47	; 0x2f
    1d28:	98 a9       	ldd	r25, Y+48	; 0x30
    1d2a:	01 97       	sbiw	r24, 0x01	; 1
    1d2c:	98 ab       	std	Y+48, r25	; 0x30
    1d2e:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d30:	8f a5       	ldd	r24, Y+47	; 0x2f
    1d32:	98 a9       	ldd	r25, Y+48	; 0x30
    1d34:	00 97       	sbiw	r24, 0x00	; 0
    1d36:	69 f7       	brne	.-38     	; 0x1d12 <LCD_sendChar+0x114>
    1d38:	14 c0       	rjmp	.+40     	; 0x1d62 <LCD_sendChar+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d3a:	69 a9       	ldd	r22, Y+49	; 0x31
    1d3c:	7a a9       	ldd	r23, Y+50	; 0x32
    1d3e:	8b a9       	ldd	r24, Y+51	; 0x33
    1d40:	9c a9       	ldd	r25, Y+52	; 0x34
    1d42:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1d46:	dc 01       	movw	r26, r24
    1d48:	cb 01       	movw	r24, r22
    1d4a:	98 ab       	std	Y+48, r25	; 0x30
    1d4c:	8f a7       	std	Y+47, r24	; 0x2f
    1d4e:	8f a5       	ldd	r24, Y+47	; 0x2f
    1d50:	98 a9       	ldd	r25, Y+48	; 0x30
    1d52:	9c a7       	std	Y+44, r25	; 0x2c
    1d54:	8b a7       	std	Y+43, r24	; 0x2b
    1d56:	8b a5       	ldd	r24, Y+43	; 0x2b
    1d58:	9c a5       	ldd	r25, Y+44	; 0x2c
    1d5a:	01 97       	sbiw	r24, 0x01	; 1
    1d5c:	f1 f7       	brne	.-4      	; 0x1d5a <LCD_sendChar+0x15c>
    1d5e:	9c a7       	std	Y+44, r25	; 0x2c
    1d60:	8b a7       	std	Y+43, r24	; 0x2b
			_delay_ms(2);
			DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_EPIN,0);
    1d62:	82 e0       	ldi	r24, 0x02	; 2
    1d64:	62 e0       	ldi	r22, 0x02	; 2
    1d66:	40 e0       	ldi	r20, 0x00	; 0
    1d68:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    1d6c:	80 e0       	ldi	r24, 0x00	; 0
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	a0 e0       	ldi	r26, 0x00	; 0
    1d72:	b0 e4       	ldi	r27, 0x40	; 64
    1d74:	8f a3       	std	Y+39, r24	; 0x27
    1d76:	98 a7       	std	Y+40, r25	; 0x28
    1d78:	a9 a7       	std	Y+41, r26	; 0x29
    1d7a:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d7c:	6f a1       	ldd	r22, Y+39	; 0x27
    1d7e:	78 a5       	ldd	r23, Y+40	; 0x28
    1d80:	89 a5       	ldd	r24, Y+41	; 0x29
    1d82:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d84:	20 e0       	ldi	r18, 0x00	; 0
    1d86:	30 e0       	ldi	r19, 0x00	; 0
    1d88:	4a ef       	ldi	r20, 0xFA	; 250
    1d8a:	54 e4       	ldi	r21, 0x44	; 68
    1d8c:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1d90:	dc 01       	movw	r26, r24
    1d92:	cb 01       	movw	r24, r22
    1d94:	8b a3       	std	Y+35, r24	; 0x23
    1d96:	9c a3       	std	Y+36, r25	; 0x24
    1d98:	ad a3       	std	Y+37, r26	; 0x25
    1d9a:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1d9c:	6b a1       	ldd	r22, Y+35	; 0x23
    1d9e:	7c a1       	ldd	r23, Y+36	; 0x24
    1da0:	8d a1       	ldd	r24, Y+37	; 0x25
    1da2:	9e a1       	ldd	r25, Y+38	; 0x26
    1da4:	20 e0       	ldi	r18, 0x00	; 0
    1da6:	30 e0       	ldi	r19, 0x00	; 0
    1da8:	40 e8       	ldi	r20, 0x80	; 128
    1daa:	5f e3       	ldi	r21, 0x3F	; 63
    1dac:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    1db0:	88 23       	and	r24, r24
    1db2:	2c f4       	brge	.+10     	; 0x1dbe <LCD_sendChar+0x1c0>
		__ticks = 1;
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	9a a3       	std	Y+34, r25	; 0x22
    1dba:	89 a3       	std	Y+33, r24	; 0x21
    1dbc:	3f c0       	rjmp	.+126    	; 0x1e3c <LCD_sendChar+0x23e>
	else if (__tmp > 65535)
    1dbe:	6b a1       	ldd	r22, Y+35	; 0x23
    1dc0:	7c a1       	ldd	r23, Y+36	; 0x24
    1dc2:	8d a1       	ldd	r24, Y+37	; 0x25
    1dc4:	9e a1       	ldd	r25, Y+38	; 0x26
    1dc6:	20 e0       	ldi	r18, 0x00	; 0
    1dc8:	3f ef       	ldi	r19, 0xFF	; 255
    1dca:	4f e7       	ldi	r20, 0x7F	; 127
    1dcc:	57 e4       	ldi	r21, 0x47	; 71
    1dce:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    1dd2:	18 16       	cp	r1, r24
    1dd4:	4c f5       	brge	.+82     	; 0x1e28 <LCD_sendChar+0x22a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1dd6:	6f a1       	ldd	r22, Y+39	; 0x27
    1dd8:	78 a5       	ldd	r23, Y+40	; 0x28
    1dda:	89 a5       	ldd	r24, Y+41	; 0x29
    1ddc:	9a a5       	ldd	r25, Y+42	; 0x2a
    1dde:	20 e0       	ldi	r18, 0x00	; 0
    1de0:	30 e0       	ldi	r19, 0x00	; 0
    1de2:	40 e2       	ldi	r20, 0x20	; 32
    1de4:	51 e4       	ldi	r21, 0x41	; 65
    1de6:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1dea:	dc 01       	movw	r26, r24
    1dec:	cb 01       	movw	r24, r22
    1dee:	bc 01       	movw	r22, r24
    1df0:	cd 01       	movw	r24, r26
    1df2:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1df6:	dc 01       	movw	r26, r24
    1df8:	cb 01       	movw	r24, r22
    1dfa:	9a a3       	std	Y+34, r25	; 0x22
    1dfc:	89 a3       	std	Y+33, r24	; 0x21
    1dfe:	0f c0       	rjmp	.+30     	; 0x1e1e <LCD_sendChar+0x220>
    1e00:	88 ec       	ldi	r24, 0xC8	; 200
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	98 a3       	std	Y+32, r25	; 0x20
    1e06:	8f 8f       	std	Y+31, r24	; 0x1f
    1e08:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1e0a:	98 a1       	ldd	r25, Y+32	; 0x20
    1e0c:	01 97       	sbiw	r24, 0x01	; 1
    1e0e:	f1 f7       	brne	.-4      	; 0x1e0c <LCD_sendChar+0x20e>
    1e10:	98 a3       	std	Y+32, r25	; 0x20
    1e12:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e14:	89 a1       	ldd	r24, Y+33	; 0x21
    1e16:	9a a1       	ldd	r25, Y+34	; 0x22
    1e18:	01 97       	sbiw	r24, 0x01	; 1
    1e1a:	9a a3       	std	Y+34, r25	; 0x22
    1e1c:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e1e:	89 a1       	ldd	r24, Y+33	; 0x21
    1e20:	9a a1       	ldd	r25, Y+34	; 0x22
    1e22:	00 97       	sbiw	r24, 0x00	; 0
    1e24:	69 f7       	brne	.-38     	; 0x1e00 <LCD_sendChar+0x202>
    1e26:	14 c0       	rjmp	.+40     	; 0x1e50 <LCD_sendChar+0x252>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e28:	6b a1       	ldd	r22, Y+35	; 0x23
    1e2a:	7c a1       	ldd	r23, Y+36	; 0x24
    1e2c:	8d a1       	ldd	r24, Y+37	; 0x25
    1e2e:	9e a1       	ldd	r25, Y+38	; 0x26
    1e30:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1e34:	dc 01       	movw	r26, r24
    1e36:	cb 01       	movw	r24, r22
    1e38:	9a a3       	std	Y+34, r25	; 0x22
    1e3a:	89 a3       	std	Y+33, r24	; 0x21
    1e3c:	89 a1       	ldd	r24, Y+33	; 0x21
    1e3e:	9a a1       	ldd	r25, Y+34	; 0x22
    1e40:	9e 8f       	std	Y+30, r25	; 0x1e
    1e42:	8d 8f       	std	Y+29, r24	; 0x1d
    1e44:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e46:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1e48:	01 97       	sbiw	r24, 0x01	; 1
    1e4a:	f1 f7       	brne	.-4      	; 0x1e48 <LCD_sendChar+0x24a>
    1e4c:	9e 8f       	std	Y+30, r25	; 0x1e
    1e4e:	8d 8f       	std	Y+29, r24	; 0x1d
			_delay_ms(2);


			DIO_voidSetPinValue(lcd_DATAPORT,4,GET_BIT(Data,0));
    1e50:	89 ad       	ldd	r24, Y+57	; 0x39
    1e52:	98 2f       	mov	r25, r24
    1e54:	91 70       	andi	r25, 0x01	; 1
    1e56:	81 e0       	ldi	r24, 0x01	; 1
    1e58:	64 e0       	ldi	r22, 0x04	; 4
    1e5a:	49 2f       	mov	r20, r25
    1e5c:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
			DIO_voidSetPinValue(lcd_DATAPORT,5,GET_BIT(Data,1));
    1e60:	89 ad       	ldd	r24, Y+57	; 0x39
    1e62:	86 95       	lsr	r24
    1e64:	98 2f       	mov	r25, r24
    1e66:	91 70       	andi	r25, 0x01	; 1
    1e68:	81 e0       	ldi	r24, 0x01	; 1
    1e6a:	65 e0       	ldi	r22, 0x05	; 5
    1e6c:	49 2f       	mov	r20, r25
    1e6e:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
			DIO_voidSetPinValue(lcd_DATAPORT,6,GET_BIT(Data,2));
    1e72:	89 ad       	ldd	r24, Y+57	; 0x39
    1e74:	86 95       	lsr	r24
    1e76:	86 95       	lsr	r24
    1e78:	98 2f       	mov	r25, r24
    1e7a:	91 70       	andi	r25, 0x01	; 1
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	66 e0       	ldi	r22, 0x06	; 6
    1e80:	49 2f       	mov	r20, r25
    1e82:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
			DIO_voidSetPinValue(lcd_DATAPORT,7,GET_BIT(Data,3));
    1e86:	89 ad       	ldd	r24, Y+57	; 0x39
    1e88:	86 95       	lsr	r24
    1e8a:	86 95       	lsr	r24
    1e8c:	86 95       	lsr	r24
    1e8e:	98 2f       	mov	r25, r24
    1e90:	91 70       	andi	r25, 0x01	; 1
    1e92:	81 e0       	ldi	r24, 0x01	; 1
    1e94:	67 e0       	ldi	r22, 0x07	; 7
    1e96:	49 2f       	mov	r20, r25
    1e98:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>

		    //latch
			DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_EPIN, 1);
    1e9c:	82 e0       	ldi	r24, 0x02	; 2
    1e9e:	62 e0       	ldi	r22, 0x02	; 2
    1ea0:	41 e0       	ldi	r20, 0x01	; 1
    1ea2:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    1ea6:	80 e0       	ldi	r24, 0x00	; 0
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	a0 e0       	ldi	r26, 0x00	; 0
    1eac:	b0 e4       	ldi	r27, 0x40	; 64
    1eae:	89 8f       	std	Y+25, r24	; 0x19
    1eb0:	9a 8f       	std	Y+26, r25	; 0x1a
    1eb2:	ab 8f       	std	Y+27, r26	; 0x1b
    1eb4:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1eb6:	69 8d       	ldd	r22, Y+25	; 0x19
    1eb8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1eba:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1ebc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1ebe:	20 e0       	ldi	r18, 0x00	; 0
    1ec0:	30 e0       	ldi	r19, 0x00	; 0
    1ec2:	4a ef       	ldi	r20, 0xFA	; 250
    1ec4:	54 e4       	ldi	r21, 0x44	; 68
    1ec6:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1eca:	dc 01       	movw	r26, r24
    1ecc:	cb 01       	movw	r24, r22
    1ece:	8d 8b       	std	Y+21, r24	; 0x15
    1ed0:	9e 8b       	std	Y+22, r25	; 0x16
    1ed2:	af 8b       	std	Y+23, r26	; 0x17
    1ed4:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1ed6:	6d 89       	ldd	r22, Y+21	; 0x15
    1ed8:	7e 89       	ldd	r23, Y+22	; 0x16
    1eda:	8f 89       	ldd	r24, Y+23	; 0x17
    1edc:	98 8d       	ldd	r25, Y+24	; 0x18
    1ede:	20 e0       	ldi	r18, 0x00	; 0
    1ee0:	30 e0       	ldi	r19, 0x00	; 0
    1ee2:	40 e8       	ldi	r20, 0x80	; 128
    1ee4:	5f e3       	ldi	r21, 0x3F	; 63
    1ee6:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    1eea:	88 23       	and	r24, r24
    1eec:	2c f4       	brge	.+10     	; 0x1ef8 <LCD_sendChar+0x2fa>
		__ticks = 1;
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	90 e0       	ldi	r25, 0x00	; 0
    1ef2:	9c 8b       	std	Y+20, r25	; 0x14
    1ef4:	8b 8b       	std	Y+19, r24	; 0x13
    1ef6:	3f c0       	rjmp	.+126    	; 0x1f76 <LCD_sendChar+0x378>
	else if (__tmp > 65535)
    1ef8:	6d 89       	ldd	r22, Y+21	; 0x15
    1efa:	7e 89       	ldd	r23, Y+22	; 0x16
    1efc:	8f 89       	ldd	r24, Y+23	; 0x17
    1efe:	98 8d       	ldd	r25, Y+24	; 0x18
    1f00:	20 e0       	ldi	r18, 0x00	; 0
    1f02:	3f ef       	ldi	r19, 0xFF	; 255
    1f04:	4f e7       	ldi	r20, 0x7F	; 127
    1f06:	57 e4       	ldi	r21, 0x47	; 71
    1f08:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    1f0c:	18 16       	cp	r1, r24
    1f0e:	4c f5       	brge	.+82     	; 0x1f62 <LCD_sendChar+0x364>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f10:	69 8d       	ldd	r22, Y+25	; 0x19
    1f12:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1f14:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1f16:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1f18:	20 e0       	ldi	r18, 0x00	; 0
    1f1a:	30 e0       	ldi	r19, 0x00	; 0
    1f1c:	40 e2       	ldi	r20, 0x20	; 32
    1f1e:	51 e4       	ldi	r21, 0x41	; 65
    1f20:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1f24:	dc 01       	movw	r26, r24
    1f26:	cb 01       	movw	r24, r22
    1f28:	bc 01       	movw	r22, r24
    1f2a:	cd 01       	movw	r24, r26
    1f2c:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1f30:	dc 01       	movw	r26, r24
    1f32:	cb 01       	movw	r24, r22
    1f34:	9c 8b       	std	Y+20, r25	; 0x14
    1f36:	8b 8b       	std	Y+19, r24	; 0x13
    1f38:	0f c0       	rjmp	.+30     	; 0x1f58 <LCD_sendChar+0x35a>
    1f3a:	88 ec       	ldi	r24, 0xC8	; 200
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	9a 8b       	std	Y+18, r25	; 0x12
    1f40:	89 8b       	std	Y+17, r24	; 0x11
    1f42:	89 89       	ldd	r24, Y+17	; 0x11
    1f44:	9a 89       	ldd	r25, Y+18	; 0x12
    1f46:	01 97       	sbiw	r24, 0x01	; 1
    1f48:	f1 f7       	brne	.-4      	; 0x1f46 <LCD_sendChar+0x348>
    1f4a:	9a 8b       	std	Y+18, r25	; 0x12
    1f4c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f4e:	8b 89       	ldd	r24, Y+19	; 0x13
    1f50:	9c 89       	ldd	r25, Y+20	; 0x14
    1f52:	01 97       	sbiw	r24, 0x01	; 1
    1f54:	9c 8b       	std	Y+20, r25	; 0x14
    1f56:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f58:	8b 89       	ldd	r24, Y+19	; 0x13
    1f5a:	9c 89       	ldd	r25, Y+20	; 0x14
    1f5c:	00 97       	sbiw	r24, 0x00	; 0
    1f5e:	69 f7       	brne	.-38     	; 0x1f3a <LCD_sendChar+0x33c>
    1f60:	14 c0       	rjmp	.+40     	; 0x1f8a <LCD_sendChar+0x38c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f62:	6d 89       	ldd	r22, Y+21	; 0x15
    1f64:	7e 89       	ldd	r23, Y+22	; 0x16
    1f66:	8f 89       	ldd	r24, Y+23	; 0x17
    1f68:	98 8d       	ldd	r25, Y+24	; 0x18
    1f6a:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    1f6e:	dc 01       	movw	r26, r24
    1f70:	cb 01       	movw	r24, r22
    1f72:	9c 8b       	std	Y+20, r25	; 0x14
    1f74:	8b 8b       	std	Y+19, r24	; 0x13
    1f76:	8b 89       	ldd	r24, Y+19	; 0x13
    1f78:	9c 89       	ldd	r25, Y+20	; 0x14
    1f7a:	98 8b       	std	Y+16, r25	; 0x10
    1f7c:	8f 87       	std	Y+15, r24	; 0x0f
    1f7e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f80:	98 89       	ldd	r25, Y+16	; 0x10
    1f82:	01 97       	sbiw	r24, 0x01	; 1
    1f84:	f1 f7       	brne	.-4      	; 0x1f82 <LCD_sendChar+0x384>
    1f86:	98 8b       	std	Y+16, r25	; 0x10
    1f88:	8f 87       	std	Y+15, r24	; 0x0f
		   _delay_ms(2);
		   	DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_EPIN, 0);
    1f8a:	82 e0       	ldi	r24, 0x02	; 2
    1f8c:	62 e0       	ldi	r22, 0x02	; 2
    1f8e:	40 e0       	ldi	r20, 0x00	; 0
    1f90:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    1f94:	80 e0       	ldi	r24, 0x00	; 0
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	a0 e0       	ldi	r26, 0x00	; 0
    1f9a:	b0 e4       	ldi	r27, 0x40	; 64
    1f9c:	8b 87       	std	Y+11, r24	; 0x0b
    1f9e:	9c 87       	std	Y+12, r25	; 0x0c
    1fa0:	ad 87       	std	Y+13, r26	; 0x0d
    1fa2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fa4:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fa6:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fa8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1faa:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fac:	20 e0       	ldi	r18, 0x00	; 0
    1fae:	30 e0       	ldi	r19, 0x00	; 0
    1fb0:	4a ef       	ldi	r20, 0xFA	; 250
    1fb2:	54 e4       	ldi	r21, 0x44	; 68
    1fb4:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    1fb8:	dc 01       	movw	r26, r24
    1fba:	cb 01       	movw	r24, r22
    1fbc:	8f 83       	std	Y+7, r24	; 0x07
    1fbe:	98 87       	std	Y+8, r25	; 0x08
    1fc0:	a9 87       	std	Y+9, r26	; 0x09
    1fc2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1fc4:	6f 81       	ldd	r22, Y+7	; 0x07
    1fc6:	78 85       	ldd	r23, Y+8	; 0x08
    1fc8:	89 85       	ldd	r24, Y+9	; 0x09
    1fca:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fcc:	20 e0       	ldi	r18, 0x00	; 0
    1fce:	30 e0       	ldi	r19, 0x00	; 0
    1fd0:	40 e8       	ldi	r20, 0x80	; 128
    1fd2:	5f e3       	ldi	r21, 0x3F	; 63
    1fd4:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    1fd8:	88 23       	and	r24, r24
    1fda:	2c f4       	brge	.+10     	; 0x1fe6 <LCD_sendChar+0x3e8>
		__ticks = 1;
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	90 e0       	ldi	r25, 0x00	; 0
    1fe0:	9e 83       	std	Y+6, r25	; 0x06
    1fe2:	8d 83       	std	Y+5, r24	; 0x05
    1fe4:	3f c0       	rjmp	.+126    	; 0x2064 <LCD_sendChar+0x466>
	else if (__tmp > 65535)
    1fe6:	6f 81       	ldd	r22, Y+7	; 0x07
    1fe8:	78 85       	ldd	r23, Y+8	; 0x08
    1fea:	89 85       	ldd	r24, Y+9	; 0x09
    1fec:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fee:	20 e0       	ldi	r18, 0x00	; 0
    1ff0:	3f ef       	ldi	r19, 0xFF	; 255
    1ff2:	4f e7       	ldi	r20, 0x7F	; 127
    1ff4:	57 e4       	ldi	r21, 0x47	; 71
    1ff6:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    1ffa:	18 16       	cp	r1, r24
    1ffc:	4c f5       	brge	.+82     	; 0x2050 <LCD_sendChar+0x452>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ffe:	6b 85       	ldd	r22, Y+11	; 0x0b
    2000:	7c 85       	ldd	r23, Y+12	; 0x0c
    2002:	8d 85       	ldd	r24, Y+13	; 0x0d
    2004:	9e 85       	ldd	r25, Y+14	; 0x0e
    2006:	20 e0       	ldi	r18, 0x00	; 0
    2008:	30 e0       	ldi	r19, 0x00	; 0
    200a:	40 e2       	ldi	r20, 0x20	; 32
    200c:	51 e4       	ldi	r21, 0x41	; 65
    200e:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    2012:	dc 01       	movw	r26, r24
    2014:	cb 01       	movw	r24, r22
    2016:	bc 01       	movw	r22, r24
    2018:	cd 01       	movw	r24, r26
    201a:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    201e:	dc 01       	movw	r26, r24
    2020:	cb 01       	movw	r24, r22
    2022:	9e 83       	std	Y+6, r25	; 0x06
    2024:	8d 83       	std	Y+5, r24	; 0x05
    2026:	0f c0       	rjmp	.+30     	; 0x2046 <LCD_sendChar+0x448>
    2028:	88 ec       	ldi	r24, 0xC8	; 200
    202a:	90 e0       	ldi	r25, 0x00	; 0
    202c:	9c 83       	std	Y+4, r25	; 0x04
    202e:	8b 83       	std	Y+3, r24	; 0x03
    2030:	8b 81       	ldd	r24, Y+3	; 0x03
    2032:	9c 81       	ldd	r25, Y+4	; 0x04
    2034:	01 97       	sbiw	r24, 0x01	; 1
    2036:	f1 f7       	brne	.-4      	; 0x2034 <LCD_sendChar+0x436>
    2038:	9c 83       	std	Y+4, r25	; 0x04
    203a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    203c:	8d 81       	ldd	r24, Y+5	; 0x05
    203e:	9e 81       	ldd	r25, Y+6	; 0x06
    2040:	01 97       	sbiw	r24, 0x01	; 1
    2042:	9e 83       	std	Y+6, r25	; 0x06
    2044:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2046:	8d 81       	ldd	r24, Y+5	; 0x05
    2048:	9e 81       	ldd	r25, Y+6	; 0x06
    204a:	00 97       	sbiw	r24, 0x00	; 0
    204c:	69 f7       	brne	.-38     	; 0x2028 <LCD_sendChar+0x42a>
    204e:	14 c0       	rjmp	.+40     	; 0x2078 <LCD_sendChar+0x47a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2050:	6f 81       	ldd	r22, Y+7	; 0x07
    2052:	78 85       	ldd	r23, Y+8	; 0x08
    2054:	89 85       	ldd	r24, Y+9	; 0x09
    2056:	9a 85       	ldd	r25, Y+10	; 0x0a
    2058:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    205c:	dc 01       	movw	r26, r24
    205e:	cb 01       	movw	r24, r22
    2060:	9e 83       	std	Y+6, r25	; 0x06
    2062:	8d 83       	std	Y+5, r24	; 0x05
    2064:	8d 81       	ldd	r24, Y+5	; 0x05
    2066:	9e 81       	ldd	r25, Y+6	; 0x06
    2068:	9a 83       	std	Y+2, r25	; 0x02
    206a:	89 83       	std	Y+1, r24	; 0x01
    206c:	89 81       	ldd	r24, Y+1	; 0x01
    206e:	9a 81       	ldd	r25, Y+2	; 0x02
    2070:	01 97       	sbiw	r24, 0x01	; 1
    2072:	f1 f7       	brne	.-4      	; 0x2070 <LCD_sendChar+0x472>
    2074:	9a 83       	std	Y+2, r25	; 0x02
    2076:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(2);

}
    2078:	e9 96       	adiw	r28, 0x39	; 57
    207a:	0f b6       	in	r0, 0x3f	; 63
    207c:	f8 94       	cli
    207e:	de bf       	out	0x3e, r29	; 62
    2080:	0f be       	out	0x3f, r0	; 63
    2082:	cd bf       	out	0x3d, r28	; 61
    2084:	cf 91       	pop	r28
    2086:	df 91       	pop	r29
    2088:	08 95       	ret

0000208a <LCD_SendCommand>:

//send command
void LCD_SendCommand(u8 command){
    208a:	0f 93       	push	r16
    208c:	1f 93       	push	r17
    208e:	df 93       	push	r29
    2090:	cf 93       	push	r28
    2092:	cd b7       	in	r28, 0x3d	; 61
    2094:	de b7       	in	r29, 0x3e	; 62
    2096:	c7 54       	subi	r28, 0x47	; 71
    2098:	d0 40       	sbci	r29, 0x00	; 0
    209a:	0f b6       	in	r0, 0x3f	; 63
    209c:	f8 94       	cli
    209e:	de bf       	out	0x3e, r29	; 62
    20a0:	0f be       	out	0x3f, r0	; 63
    20a2:	cd bf       	out	0x3d, r28	; 61
    20a4:	fe 01       	movw	r30, r28
    20a6:	e9 5b       	subi	r30, 0xB9	; 185
    20a8:	ff 4f       	sbci	r31, 0xFF	; 255
    20aa:	80 83       	st	Z, r24
	DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_RSPIN,0);
    20ac:	82 e0       	ldi	r24, 0x02	; 2
    20ae:	63 e0       	ldi	r22, 0x03	; 3
    20b0:	40 e0       	ldi	r20, 0x00	; 0
    20b2:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    20b6:	fe 01       	movw	r30, r28
    20b8:	ed 5b       	subi	r30, 0xBD	; 189
    20ba:	ff 4f       	sbci	r31, 0xFF	; 255
    20bc:	80 e0       	ldi	r24, 0x00	; 0
    20be:	90 e0       	ldi	r25, 0x00	; 0
    20c0:	a0 ea       	ldi	r26, 0xA0	; 160
    20c2:	b1 e4       	ldi	r27, 0x41	; 65
    20c4:	80 83       	st	Z, r24
    20c6:	91 83       	std	Z+1, r25	; 0x01
    20c8:	a2 83       	std	Z+2, r26	; 0x02
    20ca:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20cc:	8e 01       	movw	r16, r28
    20ce:	01 5c       	subi	r16, 0xC1	; 193
    20d0:	1f 4f       	sbci	r17, 0xFF	; 255
    20d2:	fe 01       	movw	r30, r28
    20d4:	ed 5b       	subi	r30, 0xBD	; 189
    20d6:	ff 4f       	sbci	r31, 0xFF	; 255
    20d8:	60 81       	ld	r22, Z
    20da:	71 81       	ldd	r23, Z+1	; 0x01
    20dc:	82 81       	ldd	r24, Z+2	; 0x02
    20de:	93 81       	ldd	r25, Z+3	; 0x03
    20e0:	20 e0       	ldi	r18, 0x00	; 0
    20e2:	30 e0       	ldi	r19, 0x00	; 0
    20e4:	4a ef       	ldi	r20, 0xFA	; 250
    20e6:	54 e4       	ldi	r21, 0x44	; 68
    20e8:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    20ec:	dc 01       	movw	r26, r24
    20ee:	cb 01       	movw	r24, r22
    20f0:	f8 01       	movw	r30, r16
    20f2:	80 83       	st	Z, r24
    20f4:	91 83       	std	Z+1, r25	; 0x01
    20f6:	a2 83       	std	Z+2, r26	; 0x02
    20f8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    20fa:	fe 01       	movw	r30, r28
    20fc:	ff 96       	adiw	r30, 0x3f	; 63
    20fe:	60 81       	ld	r22, Z
    2100:	71 81       	ldd	r23, Z+1	; 0x01
    2102:	82 81       	ldd	r24, Z+2	; 0x02
    2104:	93 81       	ldd	r25, Z+3	; 0x03
    2106:	20 e0       	ldi	r18, 0x00	; 0
    2108:	30 e0       	ldi	r19, 0x00	; 0
    210a:	40 e8       	ldi	r20, 0x80	; 128
    210c:	5f e3       	ldi	r21, 0x3F	; 63
    210e:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    2112:	88 23       	and	r24, r24
    2114:	2c f4       	brge	.+10     	; 0x2120 <LCD_SendCommand+0x96>
		__ticks = 1;
    2116:	81 e0       	ldi	r24, 0x01	; 1
    2118:	90 e0       	ldi	r25, 0x00	; 0
    211a:	9e af       	std	Y+62, r25	; 0x3e
    211c:	8d af       	std	Y+61, r24	; 0x3d
    211e:	46 c0       	rjmp	.+140    	; 0x21ac <LCD_SendCommand+0x122>
	else if (__tmp > 65535)
    2120:	fe 01       	movw	r30, r28
    2122:	ff 96       	adiw	r30, 0x3f	; 63
    2124:	60 81       	ld	r22, Z
    2126:	71 81       	ldd	r23, Z+1	; 0x01
    2128:	82 81       	ldd	r24, Z+2	; 0x02
    212a:	93 81       	ldd	r25, Z+3	; 0x03
    212c:	20 e0       	ldi	r18, 0x00	; 0
    212e:	3f ef       	ldi	r19, 0xFF	; 255
    2130:	4f e7       	ldi	r20, 0x7F	; 127
    2132:	57 e4       	ldi	r21, 0x47	; 71
    2134:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    2138:	18 16       	cp	r1, r24
    213a:	64 f5       	brge	.+88     	; 0x2194 <LCD_SendCommand+0x10a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    213c:	fe 01       	movw	r30, r28
    213e:	ed 5b       	subi	r30, 0xBD	; 189
    2140:	ff 4f       	sbci	r31, 0xFF	; 255
    2142:	60 81       	ld	r22, Z
    2144:	71 81       	ldd	r23, Z+1	; 0x01
    2146:	82 81       	ldd	r24, Z+2	; 0x02
    2148:	93 81       	ldd	r25, Z+3	; 0x03
    214a:	20 e0       	ldi	r18, 0x00	; 0
    214c:	30 e0       	ldi	r19, 0x00	; 0
    214e:	40 e2       	ldi	r20, 0x20	; 32
    2150:	51 e4       	ldi	r21, 0x41	; 65
    2152:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    2156:	dc 01       	movw	r26, r24
    2158:	cb 01       	movw	r24, r22
    215a:	bc 01       	movw	r22, r24
    215c:	cd 01       	movw	r24, r26
    215e:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    2162:	dc 01       	movw	r26, r24
    2164:	cb 01       	movw	r24, r22
    2166:	9e af       	std	Y+62, r25	; 0x3e
    2168:	8d af       	std	Y+61, r24	; 0x3d
    216a:	0f c0       	rjmp	.+30     	; 0x218a <LCD_SendCommand+0x100>
    216c:	88 ec       	ldi	r24, 0xC8	; 200
    216e:	90 e0       	ldi	r25, 0x00	; 0
    2170:	9c af       	std	Y+60, r25	; 0x3c
    2172:	8b af       	std	Y+59, r24	; 0x3b
    2174:	8b ad       	ldd	r24, Y+59	; 0x3b
    2176:	9c ad       	ldd	r25, Y+60	; 0x3c
    2178:	01 97       	sbiw	r24, 0x01	; 1
    217a:	f1 f7       	brne	.-4      	; 0x2178 <LCD_SendCommand+0xee>
    217c:	9c af       	std	Y+60, r25	; 0x3c
    217e:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2180:	8d ad       	ldd	r24, Y+61	; 0x3d
    2182:	9e ad       	ldd	r25, Y+62	; 0x3e
    2184:	01 97       	sbiw	r24, 0x01	; 1
    2186:	9e af       	std	Y+62, r25	; 0x3e
    2188:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    218a:	8d ad       	ldd	r24, Y+61	; 0x3d
    218c:	9e ad       	ldd	r25, Y+62	; 0x3e
    218e:	00 97       	sbiw	r24, 0x00	; 0
    2190:	69 f7       	brne	.-38     	; 0x216c <LCD_SendCommand+0xe2>
    2192:	16 c0       	rjmp	.+44     	; 0x21c0 <LCD_SendCommand+0x136>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2194:	fe 01       	movw	r30, r28
    2196:	ff 96       	adiw	r30, 0x3f	; 63
    2198:	60 81       	ld	r22, Z
    219a:	71 81       	ldd	r23, Z+1	; 0x01
    219c:	82 81       	ldd	r24, Z+2	; 0x02
    219e:	93 81       	ldd	r25, Z+3	; 0x03
    21a0:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    21a4:	dc 01       	movw	r26, r24
    21a6:	cb 01       	movw	r24, r22
    21a8:	9e af       	std	Y+62, r25	; 0x3e
    21aa:	8d af       	std	Y+61, r24	; 0x3d
    21ac:	8d ad       	ldd	r24, Y+61	; 0x3d
    21ae:	9e ad       	ldd	r25, Y+62	; 0x3e
    21b0:	9a af       	std	Y+58, r25	; 0x3a
    21b2:	89 af       	std	Y+57, r24	; 0x39
    21b4:	89 ad       	ldd	r24, Y+57	; 0x39
    21b6:	9a ad       	ldd	r25, Y+58	; 0x3a
    21b8:	01 97       	sbiw	r24, 0x01	; 1
    21ba:	f1 f7       	brne	.-4      	; 0x21b8 <LCD_SendCommand+0x12e>
    21bc:	9a af       	std	Y+58, r25	; 0x3a
    21be:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(20);

	DIO_voidSetPinValue(lcd_DATAPORT,4,GET_BIT(command,4));
    21c0:	fe 01       	movw	r30, r28
    21c2:	e9 5b       	subi	r30, 0xB9	; 185
    21c4:	ff 4f       	sbci	r31, 0xFF	; 255
    21c6:	80 81       	ld	r24, Z
    21c8:	82 95       	swap	r24
    21ca:	8f 70       	andi	r24, 0x0F	; 15
    21cc:	98 2f       	mov	r25, r24
    21ce:	91 70       	andi	r25, 0x01	; 1
    21d0:	81 e0       	ldi	r24, 0x01	; 1
    21d2:	64 e0       	ldi	r22, 0x04	; 4
    21d4:	49 2f       	mov	r20, r25
    21d6:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(lcd_DATAPORT,5,GET_BIT(command,5));
    21da:	fe 01       	movw	r30, r28
    21dc:	e9 5b       	subi	r30, 0xB9	; 185
    21de:	ff 4f       	sbci	r31, 0xFF	; 255
    21e0:	80 81       	ld	r24, Z
    21e2:	82 95       	swap	r24
    21e4:	86 95       	lsr	r24
    21e6:	87 70       	andi	r24, 0x07	; 7
    21e8:	98 2f       	mov	r25, r24
    21ea:	91 70       	andi	r25, 0x01	; 1
    21ec:	81 e0       	ldi	r24, 0x01	; 1
    21ee:	65 e0       	ldi	r22, 0x05	; 5
    21f0:	49 2f       	mov	r20, r25
    21f2:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(lcd_DATAPORT,6,GET_BIT(command,6));
    21f6:	fe 01       	movw	r30, r28
    21f8:	e9 5b       	subi	r30, 0xB9	; 185
    21fa:	ff 4f       	sbci	r31, 0xFF	; 255
    21fc:	80 81       	ld	r24, Z
    21fe:	82 95       	swap	r24
    2200:	86 95       	lsr	r24
    2202:	86 95       	lsr	r24
    2204:	83 70       	andi	r24, 0x03	; 3
    2206:	98 2f       	mov	r25, r24
    2208:	91 70       	andi	r25, 0x01	; 1
    220a:	81 e0       	ldi	r24, 0x01	; 1
    220c:	66 e0       	ldi	r22, 0x06	; 6
    220e:	49 2f       	mov	r20, r25
    2210:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(lcd_DATAPORT,7,GET_BIT(command,7));
    2214:	fe 01       	movw	r30, r28
    2216:	e9 5b       	subi	r30, 0xB9	; 185
    2218:	ff 4f       	sbci	r31, 0xFF	; 255
    221a:	80 81       	ld	r24, Z
    221c:	98 2f       	mov	r25, r24
    221e:	99 1f       	adc	r25, r25
    2220:	99 27       	eor	r25, r25
    2222:	99 1f       	adc	r25, r25
    2224:	81 e0       	ldi	r24, 0x01	; 1
    2226:	67 e0       	ldi	r22, 0x07	; 7
    2228:	49 2f       	mov	r20, r25
    222a:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>

    //latch
	DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_EPIN,1);
    222e:	82 e0       	ldi	r24, 0x02	; 2
    2230:	62 e0       	ldi	r22, 0x02	; 2
    2232:	41 e0       	ldi	r20, 0x01	; 1
    2234:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    2238:	80 e0       	ldi	r24, 0x00	; 0
    223a:	90 e0       	ldi	r25, 0x00	; 0
    223c:	a0 e0       	ldi	r26, 0x00	; 0
    223e:	b0 e4       	ldi	r27, 0x40	; 64
    2240:	8d ab       	std	Y+53, r24	; 0x35
    2242:	9e ab       	std	Y+54, r25	; 0x36
    2244:	af ab       	std	Y+55, r26	; 0x37
    2246:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2248:	6d a9       	ldd	r22, Y+53	; 0x35
    224a:	7e a9       	ldd	r23, Y+54	; 0x36
    224c:	8f a9       	ldd	r24, Y+55	; 0x37
    224e:	98 ad       	ldd	r25, Y+56	; 0x38
    2250:	20 e0       	ldi	r18, 0x00	; 0
    2252:	30 e0       	ldi	r19, 0x00	; 0
    2254:	4a ef       	ldi	r20, 0xFA	; 250
    2256:	54 e4       	ldi	r21, 0x44	; 68
    2258:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    225c:	dc 01       	movw	r26, r24
    225e:	cb 01       	movw	r24, r22
    2260:	89 ab       	std	Y+49, r24	; 0x31
    2262:	9a ab       	std	Y+50, r25	; 0x32
    2264:	ab ab       	std	Y+51, r26	; 0x33
    2266:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2268:	69 a9       	ldd	r22, Y+49	; 0x31
    226a:	7a a9       	ldd	r23, Y+50	; 0x32
    226c:	8b a9       	ldd	r24, Y+51	; 0x33
    226e:	9c a9       	ldd	r25, Y+52	; 0x34
    2270:	20 e0       	ldi	r18, 0x00	; 0
    2272:	30 e0       	ldi	r19, 0x00	; 0
    2274:	40 e8       	ldi	r20, 0x80	; 128
    2276:	5f e3       	ldi	r21, 0x3F	; 63
    2278:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    227c:	88 23       	and	r24, r24
    227e:	2c f4       	brge	.+10     	; 0x228a <LCD_SendCommand+0x200>
		__ticks = 1;
    2280:	81 e0       	ldi	r24, 0x01	; 1
    2282:	90 e0       	ldi	r25, 0x00	; 0
    2284:	98 ab       	std	Y+48, r25	; 0x30
    2286:	8f a7       	std	Y+47, r24	; 0x2f
    2288:	3f c0       	rjmp	.+126    	; 0x2308 <LCD_SendCommand+0x27e>
	else if (__tmp > 65535)
    228a:	69 a9       	ldd	r22, Y+49	; 0x31
    228c:	7a a9       	ldd	r23, Y+50	; 0x32
    228e:	8b a9       	ldd	r24, Y+51	; 0x33
    2290:	9c a9       	ldd	r25, Y+52	; 0x34
    2292:	20 e0       	ldi	r18, 0x00	; 0
    2294:	3f ef       	ldi	r19, 0xFF	; 255
    2296:	4f e7       	ldi	r20, 0x7F	; 127
    2298:	57 e4       	ldi	r21, 0x47	; 71
    229a:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    229e:	18 16       	cp	r1, r24
    22a0:	4c f5       	brge	.+82     	; 0x22f4 <LCD_SendCommand+0x26a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    22a2:	6d a9       	ldd	r22, Y+53	; 0x35
    22a4:	7e a9       	ldd	r23, Y+54	; 0x36
    22a6:	8f a9       	ldd	r24, Y+55	; 0x37
    22a8:	98 ad       	ldd	r25, Y+56	; 0x38
    22aa:	20 e0       	ldi	r18, 0x00	; 0
    22ac:	30 e0       	ldi	r19, 0x00	; 0
    22ae:	40 e2       	ldi	r20, 0x20	; 32
    22b0:	51 e4       	ldi	r21, 0x41	; 65
    22b2:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    22b6:	dc 01       	movw	r26, r24
    22b8:	cb 01       	movw	r24, r22
    22ba:	bc 01       	movw	r22, r24
    22bc:	cd 01       	movw	r24, r26
    22be:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    22c2:	dc 01       	movw	r26, r24
    22c4:	cb 01       	movw	r24, r22
    22c6:	98 ab       	std	Y+48, r25	; 0x30
    22c8:	8f a7       	std	Y+47, r24	; 0x2f
    22ca:	0f c0       	rjmp	.+30     	; 0x22ea <LCD_SendCommand+0x260>
    22cc:	88 ec       	ldi	r24, 0xC8	; 200
    22ce:	90 e0       	ldi	r25, 0x00	; 0
    22d0:	9e a7       	std	Y+46, r25	; 0x2e
    22d2:	8d a7       	std	Y+45, r24	; 0x2d
    22d4:	8d a5       	ldd	r24, Y+45	; 0x2d
    22d6:	9e a5       	ldd	r25, Y+46	; 0x2e
    22d8:	01 97       	sbiw	r24, 0x01	; 1
    22da:	f1 f7       	brne	.-4      	; 0x22d8 <LCD_SendCommand+0x24e>
    22dc:	9e a7       	std	Y+46, r25	; 0x2e
    22de:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    22e0:	8f a5       	ldd	r24, Y+47	; 0x2f
    22e2:	98 a9       	ldd	r25, Y+48	; 0x30
    22e4:	01 97       	sbiw	r24, 0x01	; 1
    22e6:	98 ab       	std	Y+48, r25	; 0x30
    22e8:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    22ea:	8f a5       	ldd	r24, Y+47	; 0x2f
    22ec:	98 a9       	ldd	r25, Y+48	; 0x30
    22ee:	00 97       	sbiw	r24, 0x00	; 0
    22f0:	69 f7       	brne	.-38     	; 0x22cc <LCD_SendCommand+0x242>
    22f2:	14 c0       	rjmp	.+40     	; 0x231c <LCD_SendCommand+0x292>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    22f4:	69 a9       	ldd	r22, Y+49	; 0x31
    22f6:	7a a9       	ldd	r23, Y+50	; 0x32
    22f8:	8b a9       	ldd	r24, Y+51	; 0x33
    22fa:	9c a9       	ldd	r25, Y+52	; 0x34
    22fc:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    2300:	dc 01       	movw	r26, r24
    2302:	cb 01       	movw	r24, r22
    2304:	98 ab       	std	Y+48, r25	; 0x30
    2306:	8f a7       	std	Y+47, r24	; 0x2f
    2308:	8f a5       	ldd	r24, Y+47	; 0x2f
    230a:	98 a9       	ldd	r25, Y+48	; 0x30
    230c:	9c a7       	std	Y+44, r25	; 0x2c
    230e:	8b a7       	std	Y+43, r24	; 0x2b
    2310:	8b a5       	ldd	r24, Y+43	; 0x2b
    2312:	9c a5       	ldd	r25, Y+44	; 0x2c
    2314:	01 97       	sbiw	r24, 0x01	; 1
    2316:	f1 f7       	brne	.-4      	; 0x2314 <LCD_SendCommand+0x28a>
    2318:	9c a7       	std	Y+44, r25	; 0x2c
    231a:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(2);
	DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_EPIN,0);
    231c:	82 e0       	ldi	r24, 0x02	; 2
    231e:	62 e0       	ldi	r22, 0x02	; 2
    2320:	40 e0       	ldi	r20, 0x00	; 0
    2322:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    2326:	80 e0       	ldi	r24, 0x00	; 0
    2328:	90 e0       	ldi	r25, 0x00	; 0
    232a:	a0 e0       	ldi	r26, 0x00	; 0
    232c:	b0 e4       	ldi	r27, 0x40	; 64
    232e:	8f a3       	std	Y+39, r24	; 0x27
    2330:	98 a7       	std	Y+40, r25	; 0x28
    2332:	a9 a7       	std	Y+41, r26	; 0x29
    2334:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2336:	6f a1       	ldd	r22, Y+39	; 0x27
    2338:	78 a5       	ldd	r23, Y+40	; 0x28
    233a:	89 a5       	ldd	r24, Y+41	; 0x29
    233c:	9a a5       	ldd	r25, Y+42	; 0x2a
    233e:	20 e0       	ldi	r18, 0x00	; 0
    2340:	30 e0       	ldi	r19, 0x00	; 0
    2342:	4a ef       	ldi	r20, 0xFA	; 250
    2344:	54 e4       	ldi	r21, 0x44	; 68
    2346:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    234a:	dc 01       	movw	r26, r24
    234c:	cb 01       	movw	r24, r22
    234e:	8b a3       	std	Y+35, r24	; 0x23
    2350:	9c a3       	std	Y+36, r25	; 0x24
    2352:	ad a3       	std	Y+37, r26	; 0x25
    2354:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2356:	6b a1       	ldd	r22, Y+35	; 0x23
    2358:	7c a1       	ldd	r23, Y+36	; 0x24
    235a:	8d a1       	ldd	r24, Y+37	; 0x25
    235c:	9e a1       	ldd	r25, Y+38	; 0x26
    235e:	20 e0       	ldi	r18, 0x00	; 0
    2360:	30 e0       	ldi	r19, 0x00	; 0
    2362:	40 e8       	ldi	r20, 0x80	; 128
    2364:	5f e3       	ldi	r21, 0x3F	; 63
    2366:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    236a:	88 23       	and	r24, r24
    236c:	2c f4       	brge	.+10     	; 0x2378 <LCD_SendCommand+0x2ee>
		__ticks = 1;
    236e:	81 e0       	ldi	r24, 0x01	; 1
    2370:	90 e0       	ldi	r25, 0x00	; 0
    2372:	9a a3       	std	Y+34, r25	; 0x22
    2374:	89 a3       	std	Y+33, r24	; 0x21
    2376:	3f c0       	rjmp	.+126    	; 0x23f6 <LCD_SendCommand+0x36c>
	else if (__tmp > 65535)
    2378:	6b a1       	ldd	r22, Y+35	; 0x23
    237a:	7c a1       	ldd	r23, Y+36	; 0x24
    237c:	8d a1       	ldd	r24, Y+37	; 0x25
    237e:	9e a1       	ldd	r25, Y+38	; 0x26
    2380:	20 e0       	ldi	r18, 0x00	; 0
    2382:	3f ef       	ldi	r19, 0xFF	; 255
    2384:	4f e7       	ldi	r20, 0x7F	; 127
    2386:	57 e4       	ldi	r21, 0x47	; 71
    2388:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    238c:	18 16       	cp	r1, r24
    238e:	4c f5       	brge	.+82     	; 0x23e2 <LCD_SendCommand+0x358>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2390:	6f a1       	ldd	r22, Y+39	; 0x27
    2392:	78 a5       	ldd	r23, Y+40	; 0x28
    2394:	89 a5       	ldd	r24, Y+41	; 0x29
    2396:	9a a5       	ldd	r25, Y+42	; 0x2a
    2398:	20 e0       	ldi	r18, 0x00	; 0
    239a:	30 e0       	ldi	r19, 0x00	; 0
    239c:	40 e2       	ldi	r20, 0x20	; 32
    239e:	51 e4       	ldi	r21, 0x41	; 65
    23a0:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    23a4:	dc 01       	movw	r26, r24
    23a6:	cb 01       	movw	r24, r22
    23a8:	bc 01       	movw	r22, r24
    23aa:	cd 01       	movw	r24, r26
    23ac:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    23b0:	dc 01       	movw	r26, r24
    23b2:	cb 01       	movw	r24, r22
    23b4:	9a a3       	std	Y+34, r25	; 0x22
    23b6:	89 a3       	std	Y+33, r24	; 0x21
    23b8:	0f c0       	rjmp	.+30     	; 0x23d8 <LCD_SendCommand+0x34e>
    23ba:	88 ec       	ldi	r24, 0xC8	; 200
    23bc:	90 e0       	ldi	r25, 0x00	; 0
    23be:	98 a3       	std	Y+32, r25	; 0x20
    23c0:	8f 8f       	std	Y+31, r24	; 0x1f
    23c2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    23c4:	98 a1       	ldd	r25, Y+32	; 0x20
    23c6:	01 97       	sbiw	r24, 0x01	; 1
    23c8:	f1 f7       	brne	.-4      	; 0x23c6 <LCD_SendCommand+0x33c>
    23ca:	98 a3       	std	Y+32, r25	; 0x20
    23cc:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    23ce:	89 a1       	ldd	r24, Y+33	; 0x21
    23d0:	9a a1       	ldd	r25, Y+34	; 0x22
    23d2:	01 97       	sbiw	r24, 0x01	; 1
    23d4:	9a a3       	std	Y+34, r25	; 0x22
    23d6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    23d8:	89 a1       	ldd	r24, Y+33	; 0x21
    23da:	9a a1       	ldd	r25, Y+34	; 0x22
    23dc:	00 97       	sbiw	r24, 0x00	; 0
    23de:	69 f7       	brne	.-38     	; 0x23ba <LCD_SendCommand+0x330>
    23e0:	14 c0       	rjmp	.+40     	; 0x240a <LCD_SendCommand+0x380>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    23e2:	6b a1       	ldd	r22, Y+35	; 0x23
    23e4:	7c a1       	ldd	r23, Y+36	; 0x24
    23e6:	8d a1       	ldd	r24, Y+37	; 0x25
    23e8:	9e a1       	ldd	r25, Y+38	; 0x26
    23ea:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    23ee:	dc 01       	movw	r26, r24
    23f0:	cb 01       	movw	r24, r22
    23f2:	9a a3       	std	Y+34, r25	; 0x22
    23f4:	89 a3       	std	Y+33, r24	; 0x21
    23f6:	89 a1       	ldd	r24, Y+33	; 0x21
    23f8:	9a a1       	ldd	r25, Y+34	; 0x22
    23fa:	9e 8f       	std	Y+30, r25	; 0x1e
    23fc:	8d 8f       	std	Y+29, r24	; 0x1d
    23fe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2400:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2402:	01 97       	sbiw	r24, 0x01	; 1
    2404:	f1 f7       	brne	.-4      	; 0x2402 <LCD_SendCommand+0x378>
    2406:	9e 8f       	std	Y+30, r25	; 0x1e
    2408:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);

	DIO_voidSetPinValue(lcd_DATAPORT,4,GET_BIT(command,0));
    240a:	fe 01       	movw	r30, r28
    240c:	e9 5b       	subi	r30, 0xB9	; 185
    240e:	ff 4f       	sbci	r31, 0xFF	; 255
    2410:	80 81       	ld	r24, Z
    2412:	98 2f       	mov	r25, r24
    2414:	91 70       	andi	r25, 0x01	; 1
    2416:	81 e0       	ldi	r24, 0x01	; 1
    2418:	64 e0       	ldi	r22, 0x04	; 4
    241a:	49 2f       	mov	r20, r25
    241c:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(lcd_DATAPORT,5,GET_BIT(command,1));
    2420:	fe 01       	movw	r30, r28
    2422:	e9 5b       	subi	r30, 0xB9	; 185
    2424:	ff 4f       	sbci	r31, 0xFF	; 255
    2426:	80 81       	ld	r24, Z
    2428:	86 95       	lsr	r24
    242a:	98 2f       	mov	r25, r24
    242c:	91 70       	andi	r25, 0x01	; 1
    242e:	81 e0       	ldi	r24, 0x01	; 1
    2430:	65 e0       	ldi	r22, 0x05	; 5
    2432:	49 2f       	mov	r20, r25
    2434:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(lcd_DATAPORT,6,GET_BIT(command,2));
    2438:	fe 01       	movw	r30, r28
    243a:	e9 5b       	subi	r30, 0xB9	; 185
    243c:	ff 4f       	sbci	r31, 0xFF	; 255
    243e:	80 81       	ld	r24, Z
    2440:	86 95       	lsr	r24
    2442:	86 95       	lsr	r24
    2444:	98 2f       	mov	r25, r24
    2446:	91 70       	andi	r25, 0x01	; 1
    2448:	81 e0       	ldi	r24, 0x01	; 1
    244a:	66 e0       	ldi	r22, 0x06	; 6
    244c:	49 2f       	mov	r20, r25
    244e:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(lcd_DATAPORT,7,GET_BIT(command,3));
    2452:	fe 01       	movw	r30, r28
    2454:	e9 5b       	subi	r30, 0xB9	; 185
    2456:	ff 4f       	sbci	r31, 0xFF	; 255
    2458:	80 81       	ld	r24, Z
    245a:	86 95       	lsr	r24
    245c:	86 95       	lsr	r24
    245e:	86 95       	lsr	r24
    2460:	98 2f       	mov	r25, r24
    2462:	91 70       	andi	r25, 0x01	; 1
    2464:	81 e0       	ldi	r24, 0x01	; 1
    2466:	67 e0       	ldi	r22, 0x07	; 7
    2468:	49 2f       	mov	r20, r25
    246a:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>


    //latch
	DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_EPIN,1);
    246e:	82 e0       	ldi	r24, 0x02	; 2
    2470:	62 e0       	ldi	r22, 0x02	; 2
    2472:	41 e0       	ldi	r20, 0x01	; 1
    2474:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    2478:	80 e0       	ldi	r24, 0x00	; 0
    247a:	90 e0       	ldi	r25, 0x00	; 0
    247c:	a0 e0       	ldi	r26, 0x00	; 0
    247e:	b0 e4       	ldi	r27, 0x40	; 64
    2480:	89 8f       	std	Y+25, r24	; 0x19
    2482:	9a 8f       	std	Y+26, r25	; 0x1a
    2484:	ab 8f       	std	Y+27, r26	; 0x1b
    2486:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2488:	69 8d       	ldd	r22, Y+25	; 0x19
    248a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    248c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    248e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2490:	20 e0       	ldi	r18, 0x00	; 0
    2492:	30 e0       	ldi	r19, 0x00	; 0
    2494:	4a ef       	ldi	r20, 0xFA	; 250
    2496:	54 e4       	ldi	r21, 0x44	; 68
    2498:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    249c:	dc 01       	movw	r26, r24
    249e:	cb 01       	movw	r24, r22
    24a0:	8d 8b       	std	Y+21, r24	; 0x15
    24a2:	9e 8b       	std	Y+22, r25	; 0x16
    24a4:	af 8b       	std	Y+23, r26	; 0x17
    24a6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    24a8:	6d 89       	ldd	r22, Y+21	; 0x15
    24aa:	7e 89       	ldd	r23, Y+22	; 0x16
    24ac:	8f 89       	ldd	r24, Y+23	; 0x17
    24ae:	98 8d       	ldd	r25, Y+24	; 0x18
    24b0:	20 e0       	ldi	r18, 0x00	; 0
    24b2:	30 e0       	ldi	r19, 0x00	; 0
    24b4:	40 e8       	ldi	r20, 0x80	; 128
    24b6:	5f e3       	ldi	r21, 0x3F	; 63
    24b8:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    24bc:	88 23       	and	r24, r24
    24be:	2c f4       	brge	.+10     	; 0x24ca <LCD_SendCommand+0x440>
		__ticks = 1;
    24c0:	81 e0       	ldi	r24, 0x01	; 1
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	9c 8b       	std	Y+20, r25	; 0x14
    24c6:	8b 8b       	std	Y+19, r24	; 0x13
    24c8:	3f c0       	rjmp	.+126    	; 0x2548 <LCD_SendCommand+0x4be>
	else if (__tmp > 65535)
    24ca:	6d 89       	ldd	r22, Y+21	; 0x15
    24cc:	7e 89       	ldd	r23, Y+22	; 0x16
    24ce:	8f 89       	ldd	r24, Y+23	; 0x17
    24d0:	98 8d       	ldd	r25, Y+24	; 0x18
    24d2:	20 e0       	ldi	r18, 0x00	; 0
    24d4:	3f ef       	ldi	r19, 0xFF	; 255
    24d6:	4f e7       	ldi	r20, 0x7F	; 127
    24d8:	57 e4       	ldi	r21, 0x47	; 71
    24da:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    24de:	18 16       	cp	r1, r24
    24e0:	4c f5       	brge	.+82     	; 0x2534 <LCD_SendCommand+0x4aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    24e2:	69 8d       	ldd	r22, Y+25	; 0x19
    24e4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    24e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    24e8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    24ea:	20 e0       	ldi	r18, 0x00	; 0
    24ec:	30 e0       	ldi	r19, 0x00	; 0
    24ee:	40 e2       	ldi	r20, 0x20	; 32
    24f0:	51 e4       	ldi	r21, 0x41	; 65
    24f2:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    24f6:	dc 01       	movw	r26, r24
    24f8:	cb 01       	movw	r24, r22
    24fa:	bc 01       	movw	r22, r24
    24fc:	cd 01       	movw	r24, r26
    24fe:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    2502:	dc 01       	movw	r26, r24
    2504:	cb 01       	movw	r24, r22
    2506:	9c 8b       	std	Y+20, r25	; 0x14
    2508:	8b 8b       	std	Y+19, r24	; 0x13
    250a:	0f c0       	rjmp	.+30     	; 0x252a <LCD_SendCommand+0x4a0>
    250c:	88 ec       	ldi	r24, 0xC8	; 200
    250e:	90 e0       	ldi	r25, 0x00	; 0
    2510:	9a 8b       	std	Y+18, r25	; 0x12
    2512:	89 8b       	std	Y+17, r24	; 0x11
    2514:	89 89       	ldd	r24, Y+17	; 0x11
    2516:	9a 89       	ldd	r25, Y+18	; 0x12
    2518:	01 97       	sbiw	r24, 0x01	; 1
    251a:	f1 f7       	brne	.-4      	; 0x2518 <LCD_SendCommand+0x48e>
    251c:	9a 8b       	std	Y+18, r25	; 0x12
    251e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2520:	8b 89       	ldd	r24, Y+19	; 0x13
    2522:	9c 89       	ldd	r25, Y+20	; 0x14
    2524:	01 97       	sbiw	r24, 0x01	; 1
    2526:	9c 8b       	std	Y+20, r25	; 0x14
    2528:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    252a:	8b 89       	ldd	r24, Y+19	; 0x13
    252c:	9c 89       	ldd	r25, Y+20	; 0x14
    252e:	00 97       	sbiw	r24, 0x00	; 0
    2530:	69 f7       	brne	.-38     	; 0x250c <LCD_SendCommand+0x482>
    2532:	14 c0       	rjmp	.+40     	; 0x255c <LCD_SendCommand+0x4d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2534:	6d 89       	ldd	r22, Y+21	; 0x15
    2536:	7e 89       	ldd	r23, Y+22	; 0x16
    2538:	8f 89       	ldd	r24, Y+23	; 0x17
    253a:	98 8d       	ldd	r25, Y+24	; 0x18
    253c:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    2540:	dc 01       	movw	r26, r24
    2542:	cb 01       	movw	r24, r22
    2544:	9c 8b       	std	Y+20, r25	; 0x14
    2546:	8b 8b       	std	Y+19, r24	; 0x13
    2548:	8b 89       	ldd	r24, Y+19	; 0x13
    254a:	9c 89       	ldd	r25, Y+20	; 0x14
    254c:	98 8b       	std	Y+16, r25	; 0x10
    254e:	8f 87       	std	Y+15, r24	; 0x0f
    2550:	8f 85       	ldd	r24, Y+15	; 0x0f
    2552:	98 89       	ldd	r25, Y+16	; 0x10
    2554:	01 97       	sbiw	r24, 0x01	; 1
    2556:	f1 f7       	brne	.-4      	; 0x2554 <LCD_SendCommand+0x4ca>
    2558:	98 8b       	std	Y+16, r25	; 0x10
    255a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);
	DIO_voidSetPinValue(lcd_CONTROLPORT,lcd_EPIN,0);
    255c:	82 e0       	ldi	r24, 0x02	; 2
    255e:	62 e0       	ldi	r22, 0x02	; 2
    2560:	40 e0       	ldi	r20, 0x00	; 0
    2562:	0e 94 a8 06 	call	0xd50	; 0xd50 <DIO_voidSetPinValue>
    2566:	80 e0       	ldi	r24, 0x00	; 0
    2568:	90 e0       	ldi	r25, 0x00	; 0
    256a:	a0 e0       	ldi	r26, 0x00	; 0
    256c:	b0 e4       	ldi	r27, 0x40	; 64
    256e:	8b 87       	std	Y+11, r24	; 0x0b
    2570:	9c 87       	std	Y+12, r25	; 0x0c
    2572:	ad 87       	std	Y+13, r26	; 0x0d
    2574:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2576:	6b 85       	ldd	r22, Y+11	; 0x0b
    2578:	7c 85       	ldd	r23, Y+12	; 0x0c
    257a:	8d 85       	ldd	r24, Y+13	; 0x0d
    257c:	9e 85       	ldd	r25, Y+14	; 0x0e
    257e:	20 e0       	ldi	r18, 0x00	; 0
    2580:	30 e0       	ldi	r19, 0x00	; 0
    2582:	4a ef       	ldi	r20, 0xFA	; 250
    2584:	54 e4       	ldi	r21, 0x44	; 68
    2586:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    258a:	dc 01       	movw	r26, r24
    258c:	cb 01       	movw	r24, r22
    258e:	8f 83       	std	Y+7, r24	; 0x07
    2590:	98 87       	std	Y+8, r25	; 0x08
    2592:	a9 87       	std	Y+9, r26	; 0x09
    2594:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2596:	6f 81       	ldd	r22, Y+7	; 0x07
    2598:	78 85       	ldd	r23, Y+8	; 0x08
    259a:	89 85       	ldd	r24, Y+9	; 0x09
    259c:	9a 85       	ldd	r25, Y+10	; 0x0a
    259e:	20 e0       	ldi	r18, 0x00	; 0
    25a0:	30 e0       	ldi	r19, 0x00	; 0
    25a2:	40 e8       	ldi	r20, 0x80	; 128
    25a4:	5f e3       	ldi	r21, 0x3F	; 63
    25a6:	0e 94 97 03 	call	0x72e	; 0x72e <__ltsf2>
    25aa:	88 23       	and	r24, r24
    25ac:	2c f4       	brge	.+10     	; 0x25b8 <LCD_SendCommand+0x52e>
		__ticks = 1;
    25ae:	81 e0       	ldi	r24, 0x01	; 1
    25b0:	90 e0       	ldi	r25, 0x00	; 0
    25b2:	9e 83       	std	Y+6, r25	; 0x06
    25b4:	8d 83       	std	Y+5, r24	; 0x05
    25b6:	3f c0       	rjmp	.+126    	; 0x2636 <LCD_SendCommand+0x5ac>
	else if (__tmp > 65535)
    25b8:	6f 81       	ldd	r22, Y+7	; 0x07
    25ba:	78 85       	ldd	r23, Y+8	; 0x08
    25bc:	89 85       	ldd	r24, Y+9	; 0x09
    25be:	9a 85       	ldd	r25, Y+10	; 0x0a
    25c0:	20 e0       	ldi	r18, 0x00	; 0
    25c2:	3f ef       	ldi	r19, 0xFF	; 255
    25c4:	4f e7       	ldi	r20, 0x7F	; 127
    25c6:	57 e4       	ldi	r21, 0x47	; 71
    25c8:	0e 94 37 03 	call	0x66e	; 0x66e <__gtsf2>
    25cc:	18 16       	cp	r1, r24
    25ce:	4c f5       	brge	.+82     	; 0x2622 <LCD_SendCommand+0x598>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25d0:	6b 85       	ldd	r22, Y+11	; 0x0b
    25d2:	7c 85       	ldd	r23, Y+12	; 0x0c
    25d4:	8d 85       	ldd	r24, Y+13	; 0x0d
    25d6:	9e 85       	ldd	r25, Y+14	; 0x0e
    25d8:	20 e0       	ldi	r18, 0x00	; 0
    25da:	30 e0       	ldi	r19, 0x00	; 0
    25dc:	40 e2       	ldi	r20, 0x20	; 32
    25de:	51 e4       	ldi	r21, 0x41	; 65
    25e0:	0e 94 3d 02 	call	0x47a	; 0x47a <__mulsf3>
    25e4:	dc 01       	movw	r26, r24
    25e6:	cb 01       	movw	r24, r22
    25e8:	bc 01       	movw	r22, r24
    25ea:	cd 01       	movw	r24, r26
    25ec:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    25f0:	dc 01       	movw	r26, r24
    25f2:	cb 01       	movw	r24, r22
    25f4:	9e 83       	std	Y+6, r25	; 0x06
    25f6:	8d 83       	std	Y+5, r24	; 0x05
    25f8:	0f c0       	rjmp	.+30     	; 0x2618 <LCD_SendCommand+0x58e>
    25fa:	88 ec       	ldi	r24, 0xC8	; 200
    25fc:	90 e0       	ldi	r25, 0x00	; 0
    25fe:	9c 83       	std	Y+4, r25	; 0x04
    2600:	8b 83       	std	Y+3, r24	; 0x03
    2602:	8b 81       	ldd	r24, Y+3	; 0x03
    2604:	9c 81       	ldd	r25, Y+4	; 0x04
    2606:	01 97       	sbiw	r24, 0x01	; 1
    2608:	f1 f7       	brne	.-4      	; 0x2606 <LCD_SendCommand+0x57c>
    260a:	9c 83       	std	Y+4, r25	; 0x04
    260c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    260e:	8d 81       	ldd	r24, Y+5	; 0x05
    2610:	9e 81       	ldd	r25, Y+6	; 0x06
    2612:	01 97       	sbiw	r24, 0x01	; 1
    2614:	9e 83       	std	Y+6, r25	; 0x06
    2616:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2618:	8d 81       	ldd	r24, Y+5	; 0x05
    261a:	9e 81       	ldd	r25, Y+6	; 0x06
    261c:	00 97       	sbiw	r24, 0x00	; 0
    261e:	69 f7       	brne	.-38     	; 0x25fa <LCD_SendCommand+0x570>
    2620:	14 c0       	rjmp	.+40     	; 0x264a <LCD_SendCommand+0x5c0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2622:	6f 81       	ldd	r22, Y+7	; 0x07
    2624:	78 85       	ldd	r23, Y+8	; 0x08
    2626:	89 85       	ldd	r24, Y+9	; 0x09
    2628:	9a 85       	ldd	r25, Y+10	; 0x0a
    262a:	0e 94 67 00 	call	0xce	; 0xce <__fixunssfsi>
    262e:	dc 01       	movw	r26, r24
    2630:	cb 01       	movw	r24, r22
    2632:	9e 83       	std	Y+6, r25	; 0x06
    2634:	8d 83       	std	Y+5, r24	; 0x05
    2636:	8d 81       	ldd	r24, Y+5	; 0x05
    2638:	9e 81       	ldd	r25, Y+6	; 0x06
    263a:	9a 83       	std	Y+2, r25	; 0x02
    263c:	89 83       	std	Y+1, r24	; 0x01
    263e:	89 81       	ldd	r24, Y+1	; 0x01
    2640:	9a 81       	ldd	r25, Y+2	; 0x02
    2642:	01 97       	sbiw	r24, 0x01	; 1
    2644:	f1 f7       	brne	.-4      	; 0x2642 <LCD_SendCommand+0x5b8>
    2646:	9a 83       	std	Y+2, r25	; 0x02
    2648:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);

}
    264a:	c9 5b       	subi	r28, 0xB9	; 185
    264c:	df 4f       	sbci	r29, 0xFF	; 255
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	f8 94       	cli
    2652:	de bf       	out	0x3e, r29	; 62
    2654:	0f be       	out	0x3f, r0	; 63
    2656:	cd bf       	out	0x3d, r28	; 61
    2658:	cf 91       	pop	r28
    265a:	df 91       	pop	r29
    265c:	1f 91       	pop	r17
    265e:	0f 91       	pop	r16
    2660:	08 95       	ret

00002662 <LCD_SendString>:

void LCD_SendString (u8 *str){
    2662:	df 93       	push	r29
    2664:	cf 93       	push	r28
    2666:	00 d0       	rcall	.+0      	; 0x2668 <LCD_SendString+0x6>
    2668:	0f 92       	push	r0
    266a:	cd b7       	in	r28, 0x3d	; 61
    266c:	de b7       	in	r29, 0x3e	; 62
    266e:	9b 83       	std	Y+3, r25	; 0x03
    2670:	8a 83       	std	Y+2, r24	; 0x02
	u8 i;

	for(i=0;str[i] != '\0';i++){
    2672:	19 82       	std	Y+1, r1	; 0x01
    2674:	0e c0       	rjmp	.+28     	; 0x2692 <LCD_SendString+0x30>
		LCD_sendChar(str[i]);
    2676:	89 81       	ldd	r24, Y+1	; 0x01
    2678:	28 2f       	mov	r18, r24
    267a:	30 e0       	ldi	r19, 0x00	; 0
    267c:	8a 81       	ldd	r24, Y+2	; 0x02
    267e:	9b 81       	ldd	r25, Y+3	; 0x03
    2680:	fc 01       	movw	r30, r24
    2682:	e2 0f       	add	r30, r18
    2684:	f3 1f       	adc	r31, r19
    2686:	80 81       	ld	r24, Z
    2688:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
}

void LCD_SendString (u8 *str){
	u8 i;

	for(i=0;str[i] != '\0';i++){
    268c:	89 81       	ldd	r24, Y+1	; 0x01
    268e:	8f 5f       	subi	r24, 0xFF	; 255
    2690:	89 83       	std	Y+1, r24	; 0x01
    2692:	89 81       	ldd	r24, Y+1	; 0x01
    2694:	28 2f       	mov	r18, r24
    2696:	30 e0       	ldi	r19, 0x00	; 0
    2698:	8a 81       	ldd	r24, Y+2	; 0x02
    269a:	9b 81       	ldd	r25, Y+3	; 0x03
    269c:	fc 01       	movw	r30, r24
    269e:	e2 0f       	add	r30, r18
    26a0:	f3 1f       	adc	r31, r19
    26a2:	80 81       	ld	r24, Z
    26a4:	88 23       	and	r24, r24
    26a6:	39 f7       	brne	.-50     	; 0x2676 <LCD_SendString+0x14>
		LCD_sendChar(str[i]);
	}

}
    26a8:	0f 90       	pop	r0
    26aa:	0f 90       	pop	r0
    26ac:	0f 90       	pop	r0
    26ae:	cf 91       	pop	r28
    26b0:	df 91       	pop	r29
    26b2:	08 95       	ret

000026b4 <GoToXY>:

void GoToXY(u8 x,u8 y){
    26b4:	df 93       	push	r29
    26b6:	cf 93       	push	r28
    26b8:	00 d0       	rcall	.+0      	; 0x26ba <GoToXY+0x6>
    26ba:	0f 92       	push	r0
    26bc:	cd b7       	in	r28, 0x3d	; 61
    26be:	de b7       	in	r29, 0x3e	; 62
    26c0:	8a 83       	std	Y+2, r24	; 0x02
    26c2:	6b 83       	std	Y+3, r22	; 0x03
	u8 address;
	if(y<2 && x<16){
    26c4:	8b 81       	ldd	r24, Y+3	; 0x03
    26c6:	82 30       	cpi	r24, 0x02	; 2
    26c8:	c8 f4       	brcc	.+50     	; 0x26fc <GoToXY+0x48>
    26ca:	8a 81       	ldd	r24, Y+2	; 0x02
    26cc:	80 31       	cpi	r24, 0x10	; 16
    26ce:	b0 f4       	brcc	.+44     	; 0x26fc <GoToXY+0x48>
		address=y*0x40+x;
    26d0:	8b 81       	ldd	r24, Y+3	; 0x03
    26d2:	88 2f       	mov	r24, r24
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	00 24       	eor	r0, r0
    26d8:	96 95       	lsr	r25
    26da:	87 95       	ror	r24
    26dc:	07 94       	ror	r0
    26de:	96 95       	lsr	r25
    26e0:	87 95       	ror	r24
    26e2:	07 94       	ror	r0
    26e4:	98 2f       	mov	r25, r24
    26e6:	80 2d       	mov	r24, r0
    26e8:	98 2f       	mov	r25, r24
    26ea:	8a 81       	ldd	r24, Y+2	; 0x02
    26ec:	89 0f       	add	r24, r25
    26ee:	89 83       	std	Y+1, r24	; 0x01
		address=SET_BIT(address,7);
    26f0:	89 81       	ldd	r24, Y+1	; 0x01
    26f2:	80 68       	ori	r24, 0x80	; 128
    26f4:	89 83       	std	Y+1, r24	; 0x01
		LCD_SendCommand(address);
    26f6:	89 81       	ldd	r24, Y+1	; 0x01
    26f8:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>

	}
}
    26fc:	0f 90       	pop	r0
    26fe:	0f 90       	pop	r0
    2700:	0f 90       	pop	r0
    2702:	cf 91       	pop	r28
    2704:	df 91       	pop	r29
    2706:	08 95       	ret

00002708 <LCD_voidWriteNumber>:

void LCD_voidWriteNumber(s32 num)
{
    2708:	0f 93       	push	r16
    270a:	1f 93       	push	r17
    270c:	df 93       	push	r29
    270e:	cf 93       	push	r28
    2710:	cd b7       	in	r28, 0x3d	; 61
    2712:	de b7       	in	r29, 0x3e	; 62
    2714:	66 97       	sbiw	r28, 0x16	; 22
    2716:	0f b6       	in	r0, 0x3f	; 63
    2718:	f8 94       	cli
    271a:	de bf       	out	0x3e, r29	; 62
    271c:	0f be       	out	0x3f, r0	; 63
    271e:	cd bf       	out	0x3d, r28	; 61
    2720:	6b 8b       	std	Y+19, r22	; 0x13
    2722:	7c 8b       	std	Y+20, r23	; 0x14
    2724:	8d 8b       	std	Y+21, r24	; 0x15
    2726:	9e 8b       	std	Y+22, r25	; 0x16
	s8 j,i=0;
    2728:	19 82       	std	Y+1, r1	; 0x01
	u8 str[16];
	if(num==0)
    272a:	8b 89       	ldd	r24, Y+19	; 0x13
    272c:	9c 89       	ldd	r25, Y+20	; 0x14
    272e:	ad 89       	ldd	r26, Y+21	; 0x15
    2730:	be 89       	ldd	r27, Y+22	; 0x16
    2732:	00 97       	sbiw	r24, 0x00	; 0
    2734:	a1 05       	cpc	r26, r1
    2736:	b1 05       	cpc	r27, r1
    2738:	21 f4       	brne	.+8      	; 0x2742 <LCD_voidWriteNumber+0x3a>
	{
		LCD_sendChar('0');
    273a:	80 e3       	ldi	r24, 0x30	; 48
    273c:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
    2740:	4a c0       	rjmp	.+148    	; 0x27d6 <LCD_voidWriteNumber+0xce>
	}
	else if(num<0)
    2742:	8b 89       	ldd	r24, Y+19	; 0x13
    2744:	9c 89       	ldd	r25, Y+20	; 0x14
    2746:	ad 89       	ldd	r26, Y+21	; 0x15
    2748:	be 89       	ldd	r27, Y+22	; 0x16
    274a:	bb 23       	and	r27, r27
    274c:	0c f0       	brlt	.+2      	; 0x2750 <LCD_voidWriteNumber+0x48>
    274e:	43 c0       	rjmp	.+134    	; 0x27d6 <LCD_voidWriteNumber+0xce>
	{
		LCD_sendChar('-');
    2750:	8d e2       	ldi	r24, 0x2D	; 45
    2752:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
		num=num*-1;
    2756:	8b 89       	ldd	r24, Y+19	; 0x13
    2758:	9c 89       	ldd	r25, Y+20	; 0x14
    275a:	ad 89       	ldd	r26, Y+21	; 0x15
    275c:	be 89       	ldd	r27, Y+22	; 0x16
    275e:	b0 95       	com	r27
    2760:	a0 95       	com	r26
    2762:	90 95       	com	r25
    2764:	81 95       	neg	r24
    2766:	9f 4f       	sbci	r25, 0xFF	; 255
    2768:	af 4f       	sbci	r26, 0xFF	; 255
    276a:	bf 4f       	sbci	r27, 0xFF	; 255
    276c:	8b 8b       	std	Y+19, r24	; 0x13
    276e:	9c 8b       	std	Y+20, r25	; 0x14
    2770:	ad 8b       	std	Y+21, r26	; 0x15
    2772:	be 8b       	std	Y+22, r27	; 0x16
    2774:	30 c0       	rjmp	.+96     	; 0x27d6 <LCD_voidWriteNumber+0xce>
	}
	while(num)
	{
		str[i]=num%10+'0';
    2776:	89 81       	ldd	r24, Y+1	; 0x01
    2778:	08 2f       	mov	r16, r24
    277a:	11 27       	eor	r17, r17
    277c:	07 fd       	sbrc	r16, 7
    277e:	10 95       	com	r17
    2780:	8b 89       	ldd	r24, Y+19	; 0x13
    2782:	9c 89       	ldd	r25, Y+20	; 0x14
    2784:	ad 89       	ldd	r26, Y+21	; 0x15
    2786:	be 89       	ldd	r27, Y+22	; 0x16
    2788:	2a e0       	ldi	r18, 0x0A	; 10
    278a:	30 e0       	ldi	r19, 0x00	; 0
    278c:	40 e0       	ldi	r20, 0x00	; 0
    278e:	50 e0       	ldi	r21, 0x00	; 0
    2790:	bc 01       	movw	r22, r24
    2792:	cd 01       	movw	r24, r26
    2794:	0e 94 34 4d 	call	0x9a68	; 0x9a68 <__divmodsi4>
    2798:	dc 01       	movw	r26, r24
    279a:	cb 01       	movw	r24, r22
    279c:	28 2f       	mov	r18, r24
    279e:	20 5d       	subi	r18, 0xD0	; 208
    27a0:	ce 01       	movw	r24, r28
    27a2:	03 96       	adiw	r24, 0x03	; 3
    27a4:	fc 01       	movw	r30, r24
    27a6:	e0 0f       	add	r30, r16
    27a8:	f1 1f       	adc	r31, r17
    27aa:	20 83       	st	Z, r18
		num=num/10;
    27ac:	8b 89       	ldd	r24, Y+19	; 0x13
    27ae:	9c 89       	ldd	r25, Y+20	; 0x14
    27b0:	ad 89       	ldd	r26, Y+21	; 0x15
    27b2:	be 89       	ldd	r27, Y+22	; 0x16
    27b4:	2a e0       	ldi	r18, 0x0A	; 10
    27b6:	30 e0       	ldi	r19, 0x00	; 0
    27b8:	40 e0       	ldi	r20, 0x00	; 0
    27ba:	50 e0       	ldi	r21, 0x00	; 0
    27bc:	bc 01       	movw	r22, r24
    27be:	cd 01       	movw	r24, r26
    27c0:	0e 94 34 4d 	call	0x9a68	; 0x9a68 <__divmodsi4>
    27c4:	da 01       	movw	r26, r20
    27c6:	c9 01       	movw	r24, r18
    27c8:	8b 8b       	std	Y+19, r24	; 0x13
    27ca:	9c 8b       	std	Y+20, r25	; 0x14
    27cc:	ad 8b       	std	Y+21, r26	; 0x15
    27ce:	be 8b       	std	Y+22, r27	; 0x16
		i++;
    27d0:	89 81       	ldd	r24, Y+1	; 0x01
    27d2:	8f 5f       	subi	r24, 0xFF	; 255
    27d4:	89 83       	std	Y+1, r24	; 0x01
	else if(num<0)
	{
		LCD_sendChar('-');
		num=num*-1;
	}
	while(num)
    27d6:	8b 89       	ldd	r24, Y+19	; 0x13
    27d8:	9c 89       	ldd	r25, Y+20	; 0x14
    27da:	ad 89       	ldd	r26, Y+21	; 0x15
    27dc:	be 89       	ldd	r27, Y+22	; 0x16
    27de:	00 97       	sbiw	r24, 0x00	; 0
    27e0:	a1 05       	cpc	r26, r1
    27e2:	b1 05       	cpc	r27, r1
    27e4:	41 f6       	brne	.-112    	; 0x2776 <LCD_voidWriteNumber+0x6e>
	{
		str[i]=num%10+'0';
		num=num/10;
		i++;
	}
	for(j=i-1;j>=0;j--)
    27e6:	89 81       	ldd	r24, Y+1	; 0x01
    27e8:	81 50       	subi	r24, 0x01	; 1
    27ea:	8a 83       	std	Y+2, r24	; 0x02
    27ec:	10 c0       	rjmp	.+32     	; 0x280e <LCD_voidWriteNumber+0x106>
	{
		LCD_sendChar(str[j]);
    27ee:	8a 81       	ldd	r24, Y+2	; 0x02
    27f0:	28 2f       	mov	r18, r24
    27f2:	33 27       	eor	r19, r19
    27f4:	27 fd       	sbrc	r18, 7
    27f6:	30 95       	com	r19
    27f8:	ce 01       	movw	r24, r28
    27fa:	03 96       	adiw	r24, 0x03	; 3
    27fc:	fc 01       	movw	r30, r24
    27fe:	e2 0f       	add	r30, r18
    2800:	f3 1f       	adc	r31, r19
    2802:	80 81       	ld	r24, Z
    2804:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
	{
		str[i]=num%10+'0';
		num=num/10;
		i++;
	}
	for(j=i-1;j>=0;j--)
    2808:	8a 81       	ldd	r24, Y+2	; 0x02
    280a:	81 50       	subi	r24, 0x01	; 1
    280c:	8a 83       	std	Y+2, r24	; 0x02
    280e:	8a 81       	ldd	r24, Y+2	; 0x02
    2810:	88 23       	and	r24, r24
    2812:	6c f7       	brge	.-38     	; 0x27ee <LCD_voidWriteNumber+0xe6>
	{
		LCD_sendChar(str[j]);
	}
}
    2814:	66 96       	adiw	r28, 0x16	; 22
    2816:	0f b6       	in	r0, 0x3f	; 63
    2818:	f8 94       	cli
    281a:	de bf       	out	0x3e, r29	; 62
    281c:	0f be       	out	0x3f, r0	; 63
    281e:	cd bf       	out	0x3d, r28	; 61
    2820:	cf 91       	pop	r28
    2822:	df 91       	pop	r29
    2824:	1f 91       	pop	r17
    2826:	0f 91       	pop	r16
    2828:	08 95       	ret

0000282a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    282a:	df 93       	push	r29
    282c:	cf 93       	push	r28
    282e:	00 d0       	rcall	.+0      	; 0x2830 <xEventGroupCreate+0x6>
    2830:	cd b7       	in	r28, 0x3d	; 61
    2832:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    2834:	8b e0       	ldi	r24, 0x0B	; 11
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <pvPortMalloc>
    283c:	9a 83       	std	Y+2, r25	; 0x02
    283e:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    2840:	89 81       	ldd	r24, Y+1	; 0x01
    2842:	9a 81       	ldd	r25, Y+2	; 0x02
    2844:	00 97       	sbiw	r24, 0x00	; 0
    2846:	49 f0       	breq	.+18     	; 0x285a <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    2848:	e9 81       	ldd	r30, Y+1	; 0x01
    284a:	fa 81       	ldd	r31, Y+2	; 0x02
    284c:	11 82       	std	Z+1, r1	; 0x01
    284e:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2850:	89 81       	ldd	r24, Y+1	; 0x01
    2852:	9a 81       	ldd	r25, Y+2	; 0x02
    2854:	02 96       	adiw	r24, 0x02	; 2
    2856:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    285a:	89 81       	ldd	r24, Y+1	; 0x01
    285c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    285e:	0f 90       	pop	r0
    2860:	0f 90       	pop	r0
    2862:	cf 91       	pop	r28
    2864:	df 91       	pop	r29
    2866:	08 95       	ret

00002868 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    2868:	df 93       	push	r29
    286a:	cf 93       	push	r28
    286c:	cd b7       	in	r28, 0x3d	; 61
    286e:	de b7       	in	r29, 0x3e	; 62
    2870:	60 97       	sbiw	r28, 0x10	; 16
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	de bf       	out	0x3e, r29	; 62
    2878:	0f be       	out	0x3f, r0	; 63
    287a:	cd bf       	out	0x3d, r28	; 61
    287c:	9a 87       	std	Y+10, r25	; 0x0a
    287e:	89 87       	std	Y+9, r24	; 0x09
    2880:	7c 87       	std	Y+12, r23	; 0x0c
    2882:	6b 87       	std	Y+11, r22	; 0x0b
    2884:	5e 87       	std	Y+14, r21	; 0x0e
    2886:	4d 87       	std	Y+13, r20	; 0x0d
    2888:	38 8b       	std	Y+16, r19	; 0x10
    288a:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    288c:	89 85       	ldd	r24, Y+9	; 0x09
    288e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2890:	9c 83       	std	Y+4, r25	; 0x04
    2892:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    2894:	19 82       	std	Y+1, r1	; 0x01
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    2896:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    289a:	eb 81       	ldd	r30, Y+3	; 0x03
    289c:	fc 81       	ldd	r31, Y+4	; 0x04
    289e:	80 81       	ld	r24, Z
    28a0:	91 81       	ldd	r25, Z+1	; 0x01
    28a2:	98 87       	std	Y+8, r25	; 0x08
    28a4:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    28a6:	89 85       	ldd	r24, Y+9	; 0x09
    28a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    28aa:	2b 85       	ldd	r18, Y+11	; 0x0b
    28ac:	3c 85       	ldd	r19, Y+12	; 0x0c
    28ae:	b9 01       	movw	r22, r18
    28b0:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    28b4:	2f 81       	ldd	r18, Y+7	; 0x07
    28b6:	38 85       	ldd	r19, Y+8	; 0x08
    28b8:	8b 85       	ldd	r24, Y+11	; 0x0b
    28ba:	9c 85       	ldd	r25, Y+12	; 0x0c
    28bc:	28 2b       	or	r18, r24
    28be:	39 2b       	or	r19, r25
    28c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    28c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    28c4:	28 23       	and	r18, r24
    28c6:	39 23       	and	r19, r25
    28c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    28ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    28cc:	28 17       	cp	r18, r24
    28ce:	39 07       	cpc	r19, r25
    28d0:	c9 f4       	brne	.+50     	; 0x2904 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    28d2:	2f 81       	ldd	r18, Y+7	; 0x07
    28d4:	38 85       	ldd	r19, Y+8	; 0x08
    28d6:	8b 85       	ldd	r24, Y+11	; 0x0b
    28d8:	9c 85       	ldd	r25, Y+12	; 0x0c
    28da:	82 2b       	or	r24, r18
    28dc:	93 2b       	or	r25, r19
    28de:	9e 83       	std	Y+6, r25	; 0x06
    28e0:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    28e2:	eb 81       	ldd	r30, Y+3	; 0x03
    28e4:	fc 81       	ldd	r31, Y+4	; 0x04
    28e6:	20 81       	ld	r18, Z
    28e8:	31 81       	ldd	r19, Z+1	; 0x01
    28ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    28ec:	9e 85       	ldd	r25, Y+14	; 0x0e
    28ee:	80 95       	com	r24
    28f0:	90 95       	com	r25
    28f2:	82 23       	and	r24, r18
    28f4:	93 23       	and	r25, r19
    28f6:	eb 81       	ldd	r30, Y+3	; 0x03
    28f8:	fc 81       	ldd	r31, Y+4	; 0x04
    28fa:	91 83       	std	Z+1, r25	; 0x01
    28fc:	80 83       	st	Z, r24

            xTicksToWait = 0;
    28fe:	18 8a       	std	Y+16, r1	; 0x10
    2900:	1f 86       	std	Y+15, r1	; 0x0f
    2902:	1e c0       	rjmp	.+60     	; 0x2940 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    2904:	8f 85       	ldd	r24, Y+15	; 0x0f
    2906:	98 89       	ldd	r25, Y+16	; 0x10
    2908:	00 97       	sbiw	r24, 0x00	; 0
    290a:	91 f0       	breq	.+36     	; 0x2930 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    290c:	8b 81       	ldd	r24, Y+3	; 0x03
    290e:	9c 81       	ldd	r25, Y+4	; 0x04
    2910:	bc 01       	movw	r22, r24
    2912:	6e 5f       	subi	r22, 0xFE	; 254
    2914:	7f 4f       	sbci	r23, 0xFF	; 255
    2916:	8d 85       	ldd	r24, Y+13	; 0x0d
    2918:	9e 85       	ldd	r25, Y+14	; 0x0e
    291a:	9c 01       	movw	r18, r24
    291c:	35 60       	ori	r19, 0x05	; 5
    291e:	4f 85       	ldd	r20, Y+15	; 0x0f
    2920:	58 89       	ldd	r21, Y+16	; 0x10
    2922:	cb 01       	movw	r24, r22
    2924:	b9 01       	movw	r22, r18
    2926:	0e 94 98 35 	call	0x6b30	; 0x6b30 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    292a:	1e 82       	std	Y+6, r1	; 0x06
    292c:	1d 82       	std	Y+5, r1	; 0x05
    292e:	08 c0       	rjmp	.+16     	; 0x2940 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    2930:	eb 81       	ldd	r30, Y+3	; 0x03
    2932:	fc 81       	ldd	r31, Y+4	; 0x04
    2934:	80 81       	ld	r24, Z
    2936:	91 81       	ldd	r25, Z+1	; 0x01
    2938:	9e 83       	std	Y+6, r25	; 0x06
    293a:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    293c:	81 e0       	ldi	r24, 0x01	; 1
    293e:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    2940:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    2944:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    2946:	8f 85       	ldd	r24, Y+15	; 0x0f
    2948:	98 89       	ldd	r25, Y+16	; 0x10
    294a:	00 97       	sbiw	r24, 0x00	; 0
    294c:	09 f4       	brne	.+2      	; 0x2950 <xEventGroupSync+0xe8>
    294e:	3a c0       	rjmp	.+116    	; 0x29c4 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    2950:	8a 81       	ldd	r24, Y+2	; 0x02
    2952:	88 23       	and	r24, r24
    2954:	11 f4       	brne	.+4      	; 0x295a <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    2956:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    295a:	0e 94 40 3c 	call	0x7880	; 0x7880 <uxTaskResetEventItemValue>
    295e:	9e 83       	std	Y+6, r25	; 0x06
    2960:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2962:	8d 81       	ldd	r24, Y+5	; 0x05
    2964:	9e 81       	ldd	r25, Y+6	; 0x06
    2966:	80 70       	andi	r24, 0x00	; 0
    2968:	92 70       	andi	r25, 0x02	; 2
    296a:	00 97       	sbiw	r24, 0x00	; 0
    296c:	31 f5       	brne	.+76     	; 0x29ba <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    296e:	0f b6       	in	r0, 0x3f	; 63
    2970:	f8 94       	cli
    2972:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    2974:	eb 81       	ldd	r30, Y+3	; 0x03
    2976:	fc 81       	ldd	r31, Y+4	; 0x04
    2978:	80 81       	ld	r24, Z
    297a:	91 81       	ldd	r25, Z+1	; 0x01
    297c:	9e 83       	std	Y+6, r25	; 0x06
    297e:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2980:	2d 81       	ldd	r18, Y+5	; 0x05
    2982:	3e 81       	ldd	r19, Y+6	; 0x06
    2984:	8d 85       	ldd	r24, Y+13	; 0x0d
    2986:	9e 85       	ldd	r25, Y+14	; 0x0e
    2988:	28 23       	and	r18, r24
    298a:	39 23       	and	r19, r25
    298c:	8d 85       	ldd	r24, Y+13	; 0x0d
    298e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2990:	28 17       	cp	r18, r24
    2992:	39 07       	cpc	r19, r25
    2994:	71 f4       	brne	.+28     	; 0x29b2 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2996:	eb 81       	ldd	r30, Y+3	; 0x03
    2998:	fc 81       	ldd	r31, Y+4	; 0x04
    299a:	20 81       	ld	r18, Z
    299c:	31 81       	ldd	r19, Z+1	; 0x01
    299e:	8d 85       	ldd	r24, Y+13	; 0x0d
    29a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    29a2:	80 95       	com	r24
    29a4:	90 95       	com	r25
    29a6:	82 23       	and	r24, r18
    29a8:	93 23       	and	r25, r19
    29aa:	eb 81       	ldd	r30, Y+3	; 0x03
    29ac:	fc 81       	ldd	r31, Y+4	; 0x04
    29ae:	91 83       	std	Z+1, r25	; 0x01
    29b0:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    29b2:	0f 90       	pop	r0
    29b4:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    29b6:	81 e0       	ldi	r24, 0x01	; 1
    29b8:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    29ba:	8d 81       	ldd	r24, Y+5	; 0x05
    29bc:	9e 81       	ldd	r25, Y+6	; 0x06
    29be:	90 70       	andi	r25, 0x00	; 0
    29c0:	9e 83       	std	Y+6, r25	; 0x06
    29c2:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    29c4:	8d 81       	ldd	r24, Y+5	; 0x05
    29c6:	9e 81       	ldd	r25, Y+6	; 0x06
}
    29c8:	60 96       	adiw	r28, 0x10	; 16
    29ca:	0f b6       	in	r0, 0x3f	; 63
    29cc:	f8 94       	cli
    29ce:	de bf       	out	0x3e, r29	; 62
    29d0:	0f be       	out	0x3f, r0	; 63
    29d2:	cd bf       	out	0x3d, r28	; 61
    29d4:	cf 91       	pop	r28
    29d6:	df 91       	pop	r29
    29d8:	08 95       	ret

000029da <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    29da:	0f 93       	push	r16
    29dc:	1f 93       	push	r17
    29de:	df 93       	push	r29
    29e0:	cf 93       	push	r28
    29e2:	cd b7       	in	r28, 0x3d	; 61
    29e4:	de b7       	in	r29, 0x3e	; 62
    29e6:	63 97       	sbiw	r28, 0x13	; 19
    29e8:	0f b6       	in	r0, 0x3f	; 63
    29ea:	f8 94       	cli
    29ec:	de bf       	out	0x3e, r29	; 62
    29ee:	0f be       	out	0x3f, r0	; 63
    29f0:	cd bf       	out	0x3d, r28	; 61
    29f2:	9d 87       	std	Y+13, r25	; 0x0d
    29f4:	8c 87       	std	Y+12, r24	; 0x0c
    29f6:	7f 87       	std	Y+15, r23	; 0x0f
    29f8:	6e 87       	std	Y+14, r22	; 0x0e
    29fa:	48 8b       	std	Y+16, r20	; 0x10
    29fc:	29 8b       	std	Y+17, r18	; 0x11
    29fe:	1b 8b       	std	Y+19, r17	; 0x13
    2a00:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    2a02:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a04:	9d 85       	ldd	r25, Y+13	; 0x0d
    2a06:	9b 87       	std	Y+11, r25	; 0x0b
    2a08:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    2a0a:	1f 82       	std	Y+7, r1	; 0x07
    2a0c:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    2a0e:	1b 82       	std	Y+3, r1	; 0x03
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    2a10:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2a14:	ea 85       	ldd	r30, Y+10	; 0x0a
    2a16:	fb 85       	ldd	r31, Y+11	; 0x0b
    2a18:	80 81       	ld	r24, Z
    2a1a:	91 81       	ldd	r25, Z+1	; 0x01
    2a1c:	9a 83       	std	Y+2, r25	; 0x02
    2a1e:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2a20:	89 81       	ldd	r24, Y+1	; 0x01
    2a22:	9a 81       	ldd	r25, Y+2	; 0x02
    2a24:	2e 85       	ldd	r18, Y+14	; 0x0e
    2a26:	3f 85       	ldd	r19, Y+15	; 0x0f
    2a28:	b9 01       	movw	r22, r18
    2a2a:	49 89       	ldd	r20, Y+17	; 0x11
    2a2c:	0e 94 28 17 	call	0x2e50	; 0x2e50 <prvTestWaitCondition>
    2a30:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    2a32:	8d 81       	ldd	r24, Y+5	; 0x05
    2a34:	88 23       	and	r24, r24
    2a36:	c1 f0       	breq	.+48     	; 0x2a68 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    2a38:	89 81       	ldd	r24, Y+1	; 0x01
    2a3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a3c:	99 87       	std	Y+9, r25	; 0x09
    2a3e:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    2a40:	1b 8a       	std	Y+19, r1	; 0x13
    2a42:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    2a44:	88 89       	ldd	r24, Y+16	; 0x10
    2a46:	88 23       	and	r24, r24
    2a48:	e9 f1       	breq	.+122    	; 0x2ac4 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2a4a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2a4c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2a4e:	20 81       	ld	r18, Z
    2a50:	31 81       	ldd	r19, Z+1	; 0x01
    2a52:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a54:	9f 85       	ldd	r25, Y+15	; 0x0f
    2a56:	80 95       	com	r24
    2a58:	90 95       	com	r25
    2a5a:	82 23       	and	r24, r18
    2a5c:	93 23       	and	r25, r19
    2a5e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2a60:	fb 85       	ldd	r31, Y+11	; 0x0b
    2a62:	91 83       	std	Z+1, r25	; 0x01
    2a64:	80 83       	st	Z, r24
    2a66:	2e c0       	rjmp	.+92     	; 0x2ac4 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    2a68:	8a 89       	ldd	r24, Y+18	; 0x12
    2a6a:	9b 89       	ldd	r25, Y+19	; 0x13
    2a6c:	00 97       	sbiw	r24, 0x00	; 0
    2a6e:	39 f4       	brne	.+14     	; 0x2a7e <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    2a70:	89 81       	ldd	r24, Y+1	; 0x01
    2a72:	9a 81       	ldd	r25, Y+2	; 0x02
    2a74:	99 87       	std	Y+9, r25	; 0x09
    2a76:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    2a78:	81 e0       	ldi	r24, 0x01	; 1
    2a7a:	8b 83       	std	Y+3, r24	; 0x03
    2a7c:	23 c0       	rjmp	.+70     	; 0x2ac4 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    2a7e:	88 89       	ldd	r24, Y+16	; 0x10
    2a80:	88 23       	and	r24, r24
    2a82:	29 f0       	breq	.+10     	; 0x2a8e <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2a84:	8e 81       	ldd	r24, Y+6	; 0x06
    2a86:	9f 81       	ldd	r25, Y+7	; 0x07
    2a88:	91 60       	ori	r25, 0x01	; 1
    2a8a:	9f 83       	std	Y+7, r25	; 0x07
    2a8c:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    2a8e:	89 89       	ldd	r24, Y+17	; 0x11
    2a90:	88 23       	and	r24, r24
    2a92:	29 f0       	breq	.+10     	; 0x2a9e <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2a94:	8e 81       	ldd	r24, Y+6	; 0x06
    2a96:	9f 81       	ldd	r25, Y+7	; 0x07
    2a98:	94 60       	ori	r25, 0x04	; 4
    2a9a:	9f 83       	std	Y+7, r25	; 0x07
    2a9c:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2a9e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2aa0:	9b 85       	ldd	r25, Y+11	; 0x0b
    2aa2:	bc 01       	movw	r22, r24
    2aa4:	6e 5f       	subi	r22, 0xFE	; 254
    2aa6:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa8:	2e 85       	ldd	r18, Y+14	; 0x0e
    2aaa:	3f 85       	ldd	r19, Y+15	; 0x0f
    2aac:	8e 81       	ldd	r24, Y+6	; 0x06
    2aae:	9f 81       	ldd	r25, Y+7	; 0x07
    2ab0:	28 2b       	or	r18, r24
    2ab2:	39 2b       	or	r19, r25
    2ab4:	4a 89       	ldd	r20, Y+18	; 0x12
    2ab6:	5b 89       	ldd	r21, Y+19	; 0x13
    2ab8:	cb 01       	movw	r24, r22
    2aba:	b9 01       	movw	r22, r18
    2abc:	0e 94 98 35 	call	0x6b30	; 0x6b30 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    2ac0:	19 86       	std	Y+9, r1	; 0x09
    2ac2:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    2ac4:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    2ac8:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    2aca:	8a 89       	ldd	r24, Y+18	; 0x12
    2acc:	9b 89       	ldd	r25, Y+19	; 0x13
    2ace:	00 97       	sbiw	r24, 0x00	; 0
    2ad0:	09 f4       	brne	.+2      	; 0x2ad4 <xEventGroupWaitBits+0xfa>
    2ad2:	3c c0       	rjmp	.+120    	; 0x2b4c <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    2ad4:	8c 81       	ldd	r24, Y+4	; 0x04
    2ad6:	88 23       	and	r24, r24
    2ad8:	11 f4       	brne	.+4      	; 0x2ade <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    2ada:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    2ade:	0e 94 40 3c 	call	0x7880	; 0x7880 <uxTaskResetEventItemValue>
    2ae2:	99 87       	std	Y+9, r25	; 0x09
    2ae4:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2ae6:	88 85       	ldd	r24, Y+8	; 0x08
    2ae8:	99 85       	ldd	r25, Y+9	; 0x09
    2aea:	80 70       	andi	r24, 0x00	; 0
    2aec:	92 70       	andi	r25, 0x02	; 2
    2aee:	00 97       	sbiw	r24, 0x00	; 0
    2af0:	41 f5       	brne	.+80     	; 0x2b42 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    2af2:	0f b6       	in	r0, 0x3f	; 63
    2af4:	f8 94       	cli
    2af6:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    2af8:	ea 85       	ldd	r30, Y+10	; 0x0a
    2afa:	fb 85       	ldd	r31, Y+11	; 0x0b
    2afc:	80 81       	ld	r24, Z
    2afe:	91 81       	ldd	r25, Z+1	; 0x01
    2b00:	99 87       	std	Y+9, r25	; 0x09
    2b02:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2b04:	88 85       	ldd	r24, Y+8	; 0x08
    2b06:	99 85       	ldd	r25, Y+9	; 0x09
    2b08:	2e 85       	ldd	r18, Y+14	; 0x0e
    2b0a:	3f 85       	ldd	r19, Y+15	; 0x0f
    2b0c:	b9 01       	movw	r22, r18
    2b0e:	49 89       	ldd	r20, Y+17	; 0x11
    2b10:	0e 94 28 17 	call	0x2e50	; 0x2e50 <prvTestWaitCondition>
    2b14:	88 23       	and	r24, r24
    2b16:	89 f0       	breq	.+34     	; 0x2b3a <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    2b18:	88 89       	ldd	r24, Y+16	; 0x10
    2b1a:	88 23       	and	r24, r24
    2b1c:	71 f0       	breq	.+28     	; 0x2b3a <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2b1e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2b20:	fb 85       	ldd	r31, Y+11	; 0x0b
    2b22:	20 81       	ld	r18, Z
    2b24:	31 81       	ldd	r19, Z+1	; 0x01
    2b26:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b28:	9f 85       	ldd	r25, Y+15	; 0x0f
    2b2a:	80 95       	com	r24
    2b2c:	90 95       	com	r25
    2b2e:	82 23       	and	r24, r18
    2b30:	93 23       	and	r25, r19
    2b32:	ea 85       	ldd	r30, Y+10	; 0x0a
    2b34:	fb 85       	ldd	r31, Y+11	; 0x0b
    2b36:	91 83       	std	Z+1, r25	; 0x01
    2b38:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    2b3a:	81 e0       	ldi	r24, 0x01	; 1
    2b3c:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    2b3e:	0f 90       	pop	r0
    2b40:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2b42:	88 85       	ldd	r24, Y+8	; 0x08
    2b44:	99 85       	ldd	r25, Y+9	; 0x09
    2b46:	90 70       	andi	r25, 0x00	; 0
    2b48:	99 87       	std	Y+9, r25	; 0x09
    2b4a:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    2b4c:	88 85       	ldd	r24, Y+8	; 0x08
    2b4e:	99 85       	ldd	r25, Y+9	; 0x09
}
    2b50:	63 96       	adiw	r28, 0x13	; 19
    2b52:	0f b6       	in	r0, 0x3f	; 63
    2b54:	f8 94       	cli
    2b56:	de bf       	out	0x3e, r29	; 62
    2b58:	0f be       	out	0x3f, r0	; 63
    2b5a:	cd bf       	out	0x3d, r28	; 61
    2b5c:	cf 91       	pop	r28
    2b5e:	df 91       	pop	r29
    2b60:	1f 91       	pop	r17
    2b62:	0f 91       	pop	r16
    2b64:	08 95       	ret

00002b66 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    2b66:	df 93       	push	r29
    2b68:	cf 93       	push	r28
    2b6a:	cd b7       	in	r28, 0x3d	; 61
    2b6c:	de b7       	in	r29, 0x3e	; 62
    2b6e:	28 97       	sbiw	r28, 0x08	; 8
    2b70:	0f b6       	in	r0, 0x3f	; 63
    2b72:	f8 94       	cli
    2b74:	de bf       	out	0x3e, r29	; 62
    2b76:	0f be       	out	0x3f, r0	; 63
    2b78:	cd bf       	out	0x3d, r28	; 61
    2b7a:	9e 83       	std	Y+6, r25	; 0x06
    2b7c:	8d 83       	std	Y+5, r24	; 0x05
    2b7e:	78 87       	std	Y+8, r23	; 0x08
    2b80:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    2b82:	8d 81       	ldd	r24, Y+5	; 0x05
    2b84:	9e 81       	ldd	r25, Y+6	; 0x06
    2b86:	9c 83       	std	Y+4, r25	; 0x04
    2b88:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    2b8a:	0f b6       	in	r0, 0x3f	; 63
    2b8c:	f8 94       	cli
    2b8e:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    2b90:	eb 81       	ldd	r30, Y+3	; 0x03
    2b92:	fc 81       	ldd	r31, Y+4	; 0x04
    2b94:	80 81       	ld	r24, Z
    2b96:	91 81       	ldd	r25, Z+1	; 0x01
    2b98:	9a 83       	std	Y+2, r25	; 0x02
    2b9a:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    2b9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2ba0:	20 81       	ld	r18, Z
    2ba2:	31 81       	ldd	r19, Z+1	; 0x01
    2ba4:	8f 81       	ldd	r24, Y+7	; 0x07
    2ba6:	98 85       	ldd	r25, Y+8	; 0x08
    2ba8:	80 95       	com	r24
    2baa:	90 95       	com	r25
    2bac:	82 23       	and	r24, r18
    2bae:	93 23       	and	r25, r19
    2bb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb4:	91 83       	std	Z+1, r25	; 0x01
    2bb6:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    2bb8:	0f 90       	pop	r0
    2bba:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2bbc:	89 81       	ldd	r24, Y+1	; 0x01
    2bbe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2bc0:	28 96       	adiw	r28, 0x08	; 8
    2bc2:	0f b6       	in	r0, 0x3f	; 63
    2bc4:	f8 94       	cli
    2bc6:	de bf       	out	0x3e, r29	; 62
    2bc8:	0f be       	out	0x3f, r0	; 63
    2bca:	cd bf       	out	0x3d, r28	; 61
    2bcc:	cf 91       	pop	r28
    2bce:	df 91       	pop	r29
    2bd0:	08 95       	ret

00002bd2 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2bd2:	df 93       	push	r29
    2bd4:	cf 93       	push	r28
    2bd6:	cd b7       	in	r28, 0x3d	; 61
    2bd8:	de b7       	in	r29, 0x3e	; 62
    2bda:	27 97       	sbiw	r28, 0x07	; 7
    2bdc:	0f b6       	in	r0, 0x3f	; 63
    2bde:	f8 94       	cli
    2be0:	de bf       	out	0x3e, r29	; 62
    2be2:	0f be       	out	0x3f, r0	; 63
    2be4:	cd bf       	out	0x3d, r28	; 61
    2be6:	9f 83       	std	Y+7, r25	; 0x07
    2be8:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    2bea:	8e 81       	ldd	r24, Y+6	; 0x06
    2bec:	9f 81       	ldd	r25, Y+7	; 0x07
    2bee:	9c 83       	std	Y+4, r25	; 0x04
    2bf0:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2bf2:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    2bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf8:	80 81       	ld	r24, Z
    2bfa:	91 81       	ldd	r25, Z+1	; 0x01
    2bfc:	9a 83       	std	Y+2, r25	; 0x02
    2bfe:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    2c00:	89 81       	ldd	r24, Y+1	; 0x01
    2c02:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2c04:	27 96       	adiw	r28, 0x07	; 7
    2c06:	0f b6       	in	r0, 0x3f	; 63
    2c08:	f8 94       	cli
    2c0a:	de bf       	out	0x3e, r29	; 62
    2c0c:	0f be       	out	0x3f, r0	; 63
    2c0e:	cd bf       	out	0x3d, r28	; 61
    2c10:	cf 91       	pop	r28
    2c12:	df 91       	pop	r29
    2c14:	08 95       	ret

00002c16 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    2c16:	df 93       	push	r29
    2c18:	cf 93       	push	r28
    2c1a:	cd b7       	in	r28, 0x3d	; 61
    2c1c:	de b7       	in	r29, 0x3e	; 62
    2c1e:	65 97       	sbiw	r28, 0x15	; 21
    2c20:	0f b6       	in	r0, 0x3f	; 63
    2c22:	f8 94       	cli
    2c24:	de bf       	out	0x3e, r29	; 62
    2c26:	0f be       	out	0x3f, r0	; 63
    2c28:	cd bf       	out	0x3d, r28	; 61
    2c2a:	9b 8b       	std	Y+19, r25	; 0x13
    2c2c:	8a 8b       	std	Y+18, r24	; 0x12
    2c2e:	7d 8b       	std	Y+21, r23	; 0x15
    2c30:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem;
    ListItem_t * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2c32:	19 86       	std	Y+9, r1	; 0x09
    2c34:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    2c36:	8a 89       	ldd	r24, Y+18	; 0x12
    2c38:	9b 89       	ldd	r25, Y+19	; 0x13
    2c3a:	9b 83       	std	Y+3, r25	; 0x03
    2c3c:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    2c3e:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    2c40:	8a 81       	ldd	r24, Y+2	; 0x02
    2c42:	9b 81       	ldd	r25, Y+3	; 0x03
    2c44:	02 96       	adiw	r24, 0x02	; 2
    2c46:	9b 87       	std	Y+11, r25	; 0x0b
    2c48:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2c4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c4c:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c4e:	03 96       	adiw	r24, 0x03	; 3
    2c50:	9d 87       	std	Y+13, r25	; 0x0d
    2c52:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    2c54:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    2c58:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c5a:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c5c:	85 81       	ldd	r24, Z+5	; 0x05
    2c5e:	96 81       	ldd	r25, Z+6	; 0x06
    2c60:	99 8b       	std	Y+17, r25	; 0x11
    2c62:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    2c64:	ea 81       	ldd	r30, Y+2	; 0x02
    2c66:	fb 81       	ldd	r31, Y+3	; 0x03
    2c68:	20 81       	ld	r18, Z
    2c6a:	31 81       	ldd	r19, Z+1	; 0x01
    2c6c:	8c 89       	ldd	r24, Y+20	; 0x14
    2c6e:	9d 89       	ldd	r25, Y+21	; 0x15
    2c70:	82 2b       	or	r24, r18
    2c72:	93 2b       	or	r25, r19
    2c74:	ea 81       	ldd	r30, Y+2	; 0x02
    2c76:	fb 81       	ldd	r31, Y+3	; 0x03
    2c78:	91 83       	std	Z+1, r25	; 0x01
    2c7a:	80 83       	st	Z, r24
    2c7c:	59 c0       	rjmp	.+178    	; 0x2d30 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    2c7e:	e8 89       	ldd	r30, Y+16	; 0x10
    2c80:	f9 89       	ldd	r31, Y+17	; 0x11
    2c82:	82 81       	ldd	r24, Z+2	; 0x02
    2c84:	93 81       	ldd	r25, Z+3	; 0x03
    2c86:	9f 87       	std	Y+15, r25	; 0x0f
    2c88:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2c8a:	e8 89       	ldd	r30, Y+16	; 0x10
    2c8c:	f9 89       	ldd	r31, Y+17	; 0x11
    2c8e:	80 81       	ld	r24, Z
    2c90:	91 81       	ldd	r25, Z+1	; 0x01
    2c92:	9f 83       	std	Y+7, r25	; 0x07
    2c94:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    2c96:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2c98:	8e 81       	ldd	r24, Y+6	; 0x06
    2c9a:	9f 81       	ldd	r25, Y+7	; 0x07
    2c9c:	80 70       	andi	r24, 0x00	; 0
    2c9e:	9d 83       	std	Y+5, r25	; 0x05
    2ca0:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2ca2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ca4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ca6:	90 70       	andi	r25, 0x00	; 0
    2ca8:	9f 83       	std	Y+7, r25	; 0x07
    2caa:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2cac:	8c 81       	ldd	r24, Y+4	; 0x04
    2cae:	9d 81       	ldd	r25, Y+5	; 0x05
    2cb0:	80 70       	andi	r24, 0x00	; 0
    2cb2:	94 70       	andi	r25, 0x04	; 4
    2cb4:	00 97       	sbiw	r24, 0x00	; 0
    2cb6:	69 f4       	brne	.+26     	; 0x2cd2 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2cb8:	ea 81       	ldd	r30, Y+2	; 0x02
    2cba:	fb 81       	ldd	r31, Y+3	; 0x03
    2cbc:	20 81       	ld	r18, Z
    2cbe:	31 81       	ldd	r19, Z+1	; 0x01
    2cc0:	8e 81       	ldd	r24, Y+6	; 0x06
    2cc2:	9f 81       	ldd	r25, Y+7	; 0x07
    2cc4:	82 23       	and	r24, r18
    2cc6:	93 23       	and	r25, r19
    2cc8:	00 97       	sbiw	r24, 0x00	; 0
    2cca:	91 f0       	breq	.+36     	; 0x2cf0 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    2ccc:	81 e0       	ldi	r24, 0x01	; 1
    2cce:	89 83       	std	Y+1, r24	; 0x01
    2cd0:	0f c0       	rjmp	.+30     	; 0x2cf0 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2cd2:	ea 81       	ldd	r30, Y+2	; 0x02
    2cd4:	fb 81       	ldd	r31, Y+3	; 0x03
    2cd6:	20 81       	ld	r18, Z
    2cd8:	31 81       	ldd	r19, Z+1	; 0x01
    2cda:	8e 81       	ldd	r24, Y+6	; 0x06
    2cdc:	9f 81       	ldd	r25, Y+7	; 0x07
    2cde:	28 23       	and	r18, r24
    2ce0:	39 23       	and	r19, r25
    2ce2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ce4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ce6:	28 17       	cp	r18, r24
    2ce8:	39 07       	cpc	r19, r25
    2cea:	11 f4       	brne	.+4      	; 0x2cf0 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    2cec:	81 e0       	ldi	r24, 0x01	; 1
    2cee:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    2cf0:	89 81       	ldd	r24, Y+1	; 0x01
    2cf2:	88 23       	and	r24, r24
    2cf4:	c9 f0       	breq	.+50     	; 0x2d28 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2cf6:	8c 81       	ldd	r24, Y+4	; 0x04
    2cf8:	9d 81       	ldd	r25, Y+5	; 0x05
    2cfa:	80 70       	andi	r24, 0x00	; 0
    2cfc:	91 70       	andi	r25, 0x01	; 1
    2cfe:	00 97       	sbiw	r24, 0x00	; 0
    2d00:	41 f0       	breq	.+16     	; 0x2d12 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    2d02:	88 85       	ldd	r24, Y+8	; 0x08
    2d04:	99 85       	ldd	r25, Y+9	; 0x09
    2d06:	2e 81       	ldd	r18, Y+6	; 0x06
    2d08:	3f 81       	ldd	r19, Y+7	; 0x07
    2d0a:	82 2b       	or	r24, r18
    2d0c:	93 2b       	or	r25, r19
    2d0e:	99 87       	std	Y+9, r25	; 0x09
    2d10:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2d12:	ea 81       	ldd	r30, Y+2	; 0x02
    2d14:	fb 81       	ldd	r31, Y+3	; 0x03
    2d16:	80 81       	ld	r24, Z
    2d18:	91 81       	ldd	r25, Z+1	; 0x01
    2d1a:	9c 01       	movw	r18, r24
    2d1c:	32 60       	ori	r19, 0x02	; 2
    2d1e:	88 89       	ldd	r24, Y+16	; 0x10
    2d20:	99 89       	ldd	r25, Y+17	; 0x11
    2d22:	b9 01       	movw	r22, r18
    2d24:	0e 94 41 37 	call	0x6e82	; 0x6e82 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    2d28:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d2a:	9f 85       	ldd	r25, Y+15	; 0x0f
    2d2c:	99 8b       	std	Y+17, r25	; 0x11
    2d2e:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    2d30:	28 89       	ldd	r18, Y+16	; 0x10
    2d32:	39 89       	ldd	r19, Y+17	; 0x11
    2d34:	8c 85       	ldd	r24, Y+12	; 0x0c
    2d36:	9d 85       	ldd	r25, Y+13	; 0x0d
    2d38:	28 17       	cp	r18, r24
    2d3a:	39 07       	cpc	r19, r25
    2d3c:	09 f0       	breq	.+2      	; 0x2d40 <xEventGroupSetBits+0x12a>
    2d3e:	9f cf       	rjmp	.-194    	; 0x2c7e <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    2d40:	ea 81       	ldd	r30, Y+2	; 0x02
    2d42:	fb 81       	ldd	r31, Y+3	; 0x03
    2d44:	20 81       	ld	r18, Z
    2d46:	31 81       	ldd	r19, Z+1	; 0x01
    2d48:	88 85       	ldd	r24, Y+8	; 0x08
    2d4a:	99 85       	ldd	r25, Y+9	; 0x09
    2d4c:	80 95       	com	r24
    2d4e:	90 95       	com	r25
    2d50:	82 23       	and	r24, r18
    2d52:	93 23       	and	r25, r19
    2d54:	ea 81       	ldd	r30, Y+2	; 0x02
    2d56:	fb 81       	ldd	r31, Y+3	; 0x03
    2d58:	91 83       	std	Z+1, r25	; 0x01
    2d5a:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    2d5c:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    2d60:	ea 81       	ldd	r30, Y+2	; 0x02
    2d62:	fb 81       	ldd	r31, Y+3	; 0x03
    2d64:	80 81       	ld	r24, Z
    2d66:	91 81       	ldd	r25, Z+1	; 0x01
}
    2d68:	65 96       	adiw	r28, 0x15	; 21
    2d6a:	0f b6       	in	r0, 0x3f	; 63
    2d6c:	f8 94       	cli
    2d6e:	de bf       	out	0x3e, r29	; 62
    2d70:	0f be       	out	0x3f, r0	; 63
    2d72:	cd bf       	out	0x3d, r28	; 61
    2d74:	cf 91       	pop	r28
    2d76:	df 91       	pop	r29
    2d78:	08 95       	ret

00002d7a <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2d7a:	df 93       	push	r29
    2d7c:	cf 93       	push	r28
    2d7e:	00 d0       	rcall	.+0      	; 0x2d80 <vEventGroupDelete+0x6>
    2d80:	00 d0       	rcall	.+0      	; 0x2d82 <vEventGroupDelete+0x8>
    2d82:	00 d0       	rcall	.+0      	; 0x2d84 <vEventGroupDelete+0xa>
    2d84:	cd b7       	in	r28, 0x3d	; 61
    2d86:	de b7       	in	r29, 0x3e	; 62
    2d88:	9e 83       	std	Y+6, r25	; 0x06
    2d8a:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    2d8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2d8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2d90:	9c 83       	std	Y+4, r25	; 0x04
    2d92:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2d94:	8b 81       	ldd	r24, Y+3	; 0x03
    2d96:	9c 81       	ldd	r25, Y+4	; 0x04
    2d98:	02 96       	adiw	r24, 0x02	; 2
    2d9a:	9a 83       	std	Y+2, r25	; 0x02
    2d9c:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    2d9e:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
    2da2:	08 c0       	rjmp	.+16     	; 0x2db4 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2da4:	e9 81       	ldd	r30, Y+1	; 0x01
    2da6:	fa 81       	ldd	r31, Y+2	; 0x02
    2da8:	85 81       	ldd	r24, Z+5	; 0x05
    2daa:	96 81       	ldd	r25, Z+6	; 0x06
    2dac:	60 e0       	ldi	r22, 0x00	; 0
    2dae:	72 e0       	ldi	r23, 0x02	; 2
    2db0:	0e 94 41 37 	call	0x6e82	; 0x6e82 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2db4:	e9 81       	ldd	r30, Y+1	; 0x01
    2db6:	fa 81       	ldd	r31, Y+2	; 0x02
    2db8:	80 81       	ld	r24, Z
    2dba:	88 23       	and	r24, r24
    2dbc:	99 f7       	brne	.-26     	; 0x2da4 <vEventGroupDelete+0x2a>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
    2dbe:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
    2dc2:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc4:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc6:	0e 94 b4 17 	call	0x2f68	; 0x2f68 <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2dca:	26 96       	adiw	r28, 0x06	; 6
    2dcc:	0f b6       	in	r0, 0x3f	; 63
    2dce:	f8 94       	cli
    2dd0:	de bf       	out	0x3e, r29	; 62
    2dd2:	0f be       	out	0x3f, r0	; 63
    2dd4:	cd bf       	out	0x3d, r28	; 61
    2dd6:	cf 91       	pop	r28
    2dd8:	df 91       	pop	r29
    2dda:	08 95       	ret

00002ddc <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    2ddc:	df 93       	push	r29
    2dde:	cf 93       	push	r28
    2de0:	00 d0       	rcall	.+0      	; 0x2de2 <vEventGroupSetBitsCallback+0x6>
    2de2:	00 d0       	rcall	.+0      	; 0x2de4 <vEventGroupSetBitsCallback+0x8>
    2de4:	00 d0       	rcall	.+0      	; 0x2de6 <vEventGroupSetBitsCallback+0xa>
    2de6:	cd b7       	in	r28, 0x3d	; 61
    2de8:	de b7       	in	r29, 0x3e	; 62
    2dea:	9a 83       	std	Y+2, r25	; 0x02
    2dec:	89 83       	std	Y+1, r24	; 0x01
    2dee:	4b 83       	std	Y+3, r20	; 0x03
    2df0:	5c 83       	std	Y+4, r21	; 0x04
    2df2:	6d 83       	std	Y+5, r22	; 0x05
    2df4:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2df6:	89 81       	ldd	r24, Y+1	; 0x01
    2df8:	9a 81       	ldd	r25, Y+2	; 0x02
    2dfa:	2b 81       	ldd	r18, Y+3	; 0x03
    2dfc:	3c 81       	ldd	r19, Y+4	; 0x04
    2dfe:	b9 01       	movw	r22, r18
    2e00:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xEventGroupSetBits>
}
    2e04:	26 96       	adiw	r28, 0x06	; 6
    2e06:	0f b6       	in	r0, 0x3f	; 63
    2e08:	f8 94       	cli
    2e0a:	de bf       	out	0x3e, r29	; 62
    2e0c:	0f be       	out	0x3f, r0	; 63
    2e0e:	cd bf       	out	0x3d, r28	; 61
    2e10:	cf 91       	pop	r28
    2e12:	df 91       	pop	r29
    2e14:	08 95       	ret

00002e16 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    2e16:	df 93       	push	r29
    2e18:	cf 93       	push	r28
    2e1a:	00 d0       	rcall	.+0      	; 0x2e1c <vEventGroupClearBitsCallback+0x6>
    2e1c:	00 d0       	rcall	.+0      	; 0x2e1e <vEventGroupClearBitsCallback+0x8>
    2e1e:	00 d0       	rcall	.+0      	; 0x2e20 <vEventGroupClearBitsCallback+0xa>
    2e20:	cd b7       	in	r28, 0x3d	; 61
    2e22:	de b7       	in	r29, 0x3e	; 62
    2e24:	9a 83       	std	Y+2, r25	; 0x02
    2e26:	89 83       	std	Y+1, r24	; 0x01
    2e28:	4b 83       	std	Y+3, r20	; 0x03
    2e2a:	5c 83       	std	Y+4, r21	; 0x04
    2e2c:	6d 83       	std	Y+5, r22	; 0x05
    2e2e:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    2e30:	89 81       	ldd	r24, Y+1	; 0x01
    2e32:	9a 81       	ldd	r25, Y+2	; 0x02
    2e34:	2b 81       	ldd	r18, Y+3	; 0x03
    2e36:	3c 81       	ldd	r19, Y+4	; 0x04
    2e38:	b9 01       	movw	r22, r18
    2e3a:	0e 94 b3 15 	call	0x2b66	; 0x2b66 <xEventGroupClearBits>
}
    2e3e:	26 96       	adiw	r28, 0x06	; 6
    2e40:	0f b6       	in	r0, 0x3f	; 63
    2e42:	f8 94       	cli
    2e44:	de bf       	out	0x3e, r29	; 62
    2e46:	0f be       	out	0x3f, r0	; 63
    2e48:	cd bf       	out	0x3d, r28	; 61
    2e4a:	cf 91       	pop	r28
    2e4c:	df 91       	pop	r29
    2e4e:	08 95       	ret

00002e50 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    2e50:	df 93       	push	r29
    2e52:	cf 93       	push	r28
    2e54:	00 d0       	rcall	.+0      	; 0x2e56 <prvTestWaitCondition+0x6>
    2e56:	00 d0       	rcall	.+0      	; 0x2e58 <prvTestWaitCondition+0x8>
    2e58:	00 d0       	rcall	.+0      	; 0x2e5a <prvTestWaitCondition+0xa>
    2e5a:	cd b7       	in	r28, 0x3d	; 61
    2e5c:	de b7       	in	r29, 0x3e	; 62
    2e5e:	9b 83       	std	Y+3, r25	; 0x03
    2e60:	8a 83       	std	Y+2, r24	; 0x02
    2e62:	7d 83       	std	Y+5, r23	; 0x05
    2e64:	6c 83       	std	Y+4, r22	; 0x04
    2e66:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    2e68:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    2e6a:	8e 81       	ldd	r24, Y+6	; 0x06
    2e6c:	88 23       	and	r24, r24
    2e6e:	59 f4       	brne	.+22     	; 0x2e86 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    2e70:	8a 81       	ldd	r24, Y+2	; 0x02
    2e72:	9b 81       	ldd	r25, Y+3	; 0x03
    2e74:	2c 81       	ldd	r18, Y+4	; 0x04
    2e76:	3d 81       	ldd	r19, Y+5	; 0x05
    2e78:	82 23       	and	r24, r18
    2e7a:	93 23       	and	r25, r19
    2e7c:	00 97       	sbiw	r24, 0x00	; 0
    2e7e:	81 f0       	breq	.+32     	; 0x2ea0 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2e80:	81 e0       	ldi	r24, 0x01	; 1
    2e82:	89 83       	std	Y+1, r24	; 0x01
    2e84:	0d c0       	rjmp	.+26     	; 0x2ea0 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2e86:	2a 81       	ldd	r18, Y+2	; 0x02
    2e88:	3b 81       	ldd	r19, Y+3	; 0x03
    2e8a:	8c 81       	ldd	r24, Y+4	; 0x04
    2e8c:	9d 81       	ldd	r25, Y+5	; 0x05
    2e8e:	28 23       	and	r18, r24
    2e90:	39 23       	and	r19, r25
    2e92:	8c 81       	ldd	r24, Y+4	; 0x04
    2e94:	9d 81       	ldd	r25, Y+5	; 0x05
    2e96:	28 17       	cp	r18, r24
    2e98:	39 07       	cpc	r19, r25
    2e9a:	11 f4       	brne	.+4      	; 0x2ea0 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    2e9c:	81 e0       	ldi	r24, 0x01	; 1
    2e9e:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    2ea0:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ea2:	26 96       	adiw	r28, 0x06	; 6
    2ea4:	0f b6       	in	r0, 0x3f	; 63
    2ea6:	f8 94       	cli
    2ea8:	de bf       	out	0x3e, r29	; 62
    2eaa:	0f be       	out	0x3f, r0	; 63
    2eac:	cd bf       	out	0x3d, r28	; 61
    2eae:	cf 91       	pop	r28
    2eb0:	df 91       	pop	r29
    2eb2:	08 95       	ret

00002eb4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    2eb4:	df 93       	push	r29
    2eb6:	cf 93       	push	r28
    2eb8:	00 d0       	rcall	.+0      	; 0x2eba <pvPortMalloc+0x6>
    2eba:	00 d0       	rcall	.+0      	; 0x2ebc <pvPortMalloc+0x8>
    2ebc:	cd b7       	in	r28, 0x3d	; 61
    2ebe:	de b7       	in	r29, 0x3e	; 62
    2ec0:	9c 83       	std	Y+4, r25	; 0x04
    2ec2:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
    2ec4:	1a 82       	std	Y+2, r1	; 0x02
    2ec6:	19 82       	std	Y+1, r1	; 0x01
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
    2ec8:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    2ecc:	80 91 78 01 	lds	r24, 0x0178
    2ed0:	90 91 79 01 	lds	r25, 0x0179
    2ed4:	00 97       	sbiw	r24, 0x00	; 0
    2ed6:	31 f4       	brne	.+12     	; 0x2ee4 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2ed8:	8a e7       	ldi	r24, 0x7A	; 122
    2eda:	91 e0       	ldi	r25, 0x01	; 1
    2edc:	90 93 79 01 	sts	0x0179, r25
    2ee0:	80 93 78 01 	sts	0x0178, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
    2ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee8:	00 97       	sbiw	r24, 0x00	; 0
    2eea:	99 f1       	breq	.+102    	; 0x2f52 <pvPortMalloc+0x9e>
    2eec:	80 91 76 01 	lds	r24, 0x0176
    2ef0:	90 91 77 01 	lds	r25, 0x0177
    2ef4:	2b 81       	ldd	r18, Y+3	; 0x03
    2ef6:	3c 81       	ldd	r19, Y+4	; 0x04
    2ef8:	82 0f       	add	r24, r18
    2efa:	93 1f       	adc	r25, r19
    2efc:	25 e0       	ldi	r18, 0x05	; 5
    2efe:	8b 3d       	cpi	r24, 0xDB	; 219
    2f00:	92 07       	cpc	r25, r18
    2f02:	38 f5       	brcc	.+78     	; 0x2f52 <pvPortMalloc+0x9e>
    2f04:	20 91 76 01 	lds	r18, 0x0176
    2f08:	30 91 77 01 	lds	r19, 0x0177
    2f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f10:	28 0f       	add	r18, r24
    2f12:	39 1f       	adc	r19, r25
    2f14:	80 91 76 01 	lds	r24, 0x0176
    2f18:	90 91 77 01 	lds	r25, 0x0177
    2f1c:	82 17       	cp	r24, r18
    2f1e:	93 07       	cpc	r25, r19
    2f20:	c0 f4       	brcc	.+48     	; 0x2f52 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    2f22:	20 91 78 01 	lds	r18, 0x0178
    2f26:	30 91 79 01 	lds	r19, 0x0179
    2f2a:	80 91 76 01 	lds	r24, 0x0176
    2f2e:	90 91 77 01 	lds	r25, 0x0177
    2f32:	82 0f       	add	r24, r18
    2f34:	93 1f       	adc	r25, r19
    2f36:	9a 83       	std	Y+2, r25	; 0x02
    2f38:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
    2f3a:	20 91 76 01 	lds	r18, 0x0176
    2f3e:	30 91 77 01 	lds	r19, 0x0177
    2f42:	8b 81       	ldd	r24, Y+3	; 0x03
    2f44:	9c 81       	ldd	r25, Y+4	; 0x04
    2f46:	82 0f       	add	r24, r18
    2f48:	93 1f       	adc	r25, r19
    2f4a:	90 93 77 01 	sts	0x0177, r25
    2f4e:	80 93 76 01 	sts	0x0176, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    2f52:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
            vApplicationMallocFailedHook();
        }
    }
    #endif

    return pvReturn;
    2f56:	89 81       	ldd	r24, Y+1	; 0x01
    2f58:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f5a:	0f 90       	pop	r0
    2f5c:	0f 90       	pop	r0
    2f5e:	0f 90       	pop	r0
    2f60:	0f 90       	pop	r0
    2f62:	cf 91       	pop	r28
    2f64:	df 91       	pop	r29
    2f66:	08 95       	ret

00002f68 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    2f68:	df 93       	push	r29
    2f6a:	cf 93       	push	r28
    2f6c:	00 d0       	rcall	.+0      	; 0x2f6e <vPortFree+0x6>
    2f6e:	cd b7       	in	r28, 0x3d	; 61
    2f70:	de b7       	in	r29, 0x3e	; 62
    2f72:	9a 83       	std	Y+2, r25	; 0x02
    2f74:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    2f76:	0f 90       	pop	r0
    2f78:	0f 90       	pop	r0
    2f7a:	cf 91       	pop	r28
    2f7c:	df 91       	pop	r29
    2f7e:	08 95       	ret

00002f80 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2f80:	df 93       	push	r29
    2f82:	cf 93       	push	r28
    2f84:	cd b7       	in	r28, 0x3d	; 61
    2f86:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    2f88:	10 92 77 01 	sts	0x0177, r1
    2f8c:	10 92 76 01 	sts	0x0176, r1
}
    2f90:	cf 91       	pop	r28
    2f92:	df 91       	pop	r29
    2f94:	08 95       	ret

00002f96 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2f96:	df 93       	push	r29
    2f98:	cf 93       	push	r28
    2f9a:	cd b7       	in	r28, 0x3d	; 61
    2f9c:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2f9e:	20 91 76 01 	lds	r18, 0x0176
    2fa2:	30 91 77 01 	lds	r19, 0x0177
    2fa6:	8b ed       	ldi	r24, 0xDB	; 219
    2fa8:	95 e0       	ldi	r25, 0x05	; 5
    2faa:	82 1b       	sub	r24, r18
    2fac:	93 0b       	sbc	r25, r19
}
    2fae:	cf 91       	pop	r28
    2fb0:	df 91       	pop	r29
    2fb2:	08 95       	ret

00002fb4 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2fb4:	df 93       	push	r29
    2fb6:	cf 93       	push	r28
    2fb8:	00 d0       	rcall	.+0      	; 0x2fba <vListInitialise+0x6>
    2fba:	cd b7       	in	r28, 0x3d	; 61
    2fbc:	de b7       	in	r29, 0x3e	; 62
    2fbe:	9a 83       	std	Y+2, r25	; 0x02
    2fc0:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2fc2:	89 81       	ldd	r24, Y+1	; 0x01
    2fc4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc6:	03 96       	adiw	r24, 0x03	; 3
    2fc8:	e9 81       	ldd	r30, Y+1	; 0x01
    2fca:	fa 81       	ldd	r31, Y+2	; 0x02
    2fcc:	92 83       	std	Z+2, r25	; 0x02
    2fce:	81 83       	std	Z+1, r24	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2fd0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd4:	8f ef       	ldi	r24, 0xFF	; 255
    2fd6:	9f ef       	ldi	r25, 0xFF	; 255
    2fd8:	94 83       	std	Z+4, r25	; 0x04
    2fda:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2fdc:	89 81       	ldd	r24, Y+1	; 0x01
    2fde:	9a 81       	ldd	r25, Y+2	; 0x02
    2fe0:	03 96       	adiw	r24, 0x03	; 3
    2fe2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe6:	96 83       	std	Z+6, r25	; 0x06
    2fe8:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2fea:	89 81       	ldd	r24, Y+1	; 0x01
    2fec:	9a 81       	ldd	r25, Y+2	; 0x02
    2fee:	03 96       	adiw	r24, 0x03	; 3
    2ff0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff4:	90 87       	std	Z+8, r25	; 0x08
    2ff6:	87 83       	std	Z+7, r24	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2ff8:	e9 81       	ldd	r30, Y+1	; 0x01
    2ffa:	fa 81       	ldd	r31, Y+2	; 0x02
    2ffc:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    2ffe:	0f 90       	pop	r0
    3000:	0f 90       	pop	r0
    3002:	cf 91       	pop	r28
    3004:	df 91       	pop	r29
    3006:	08 95       	ret

00003008 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    3008:	df 93       	push	r29
    300a:	cf 93       	push	r28
    300c:	00 d0       	rcall	.+0      	; 0x300e <vListInitialiseItem+0x6>
    300e:	cd b7       	in	r28, 0x3d	; 61
    3010:	de b7       	in	r29, 0x3e	; 62
    3012:	9a 83       	std	Y+2, r25	; 0x02
    3014:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    3016:	e9 81       	ldd	r30, Y+1	; 0x01
    3018:	fa 81       	ldd	r31, Y+2	; 0x02
    301a:	11 86       	std	Z+9, r1	; 0x09
    301c:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    301e:	0f 90       	pop	r0
    3020:	0f 90       	pop	r0
    3022:	cf 91       	pop	r28
    3024:	df 91       	pop	r29
    3026:	08 95       	ret

00003028 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    3028:	df 93       	push	r29
    302a:	cf 93       	push	r28
    302c:	00 d0       	rcall	.+0      	; 0x302e <vListInsertEnd+0x6>
    302e:	00 d0       	rcall	.+0      	; 0x3030 <vListInsertEnd+0x8>
    3030:	00 d0       	rcall	.+0      	; 0x3032 <vListInsertEnd+0xa>
    3032:	cd b7       	in	r28, 0x3d	; 61
    3034:	de b7       	in	r29, 0x3e	; 62
    3036:	9c 83       	std	Y+4, r25	; 0x04
    3038:	8b 83       	std	Y+3, r24	; 0x03
    303a:	7e 83       	std	Y+6, r23	; 0x06
    303c:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    303e:	eb 81       	ldd	r30, Y+3	; 0x03
    3040:	fc 81       	ldd	r31, Y+4	; 0x04
    3042:	81 81       	ldd	r24, Z+1	; 0x01
    3044:	92 81       	ldd	r25, Z+2	; 0x02
    3046:	9a 83       	std	Y+2, r25	; 0x02
    3048:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    304a:	ed 81       	ldd	r30, Y+5	; 0x05
    304c:	fe 81       	ldd	r31, Y+6	; 0x06
    304e:	89 81       	ldd	r24, Y+1	; 0x01
    3050:	9a 81       	ldd	r25, Y+2	; 0x02
    3052:	93 83       	std	Z+3, r25	; 0x03
    3054:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3056:	e9 81       	ldd	r30, Y+1	; 0x01
    3058:	fa 81       	ldd	r31, Y+2	; 0x02
    305a:	84 81       	ldd	r24, Z+4	; 0x04
    305c:	95 81       	ldd	r25, Z+5	; 0x05
    305e:	ed 81       	ldd	r30, Y+5	; 0x05
    3060:	fe 81       	ldd	r31, Y+6	; 0x06
    3062:	95 83       	std	Z+5, r25	; 0x05
    3064:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3066:	e9 81       	ldd	r30, Y+1	; 0x01
    3068:	fa 81       	ldd	r31, Y+2	; 0x02
    306a:	04 80       	ldd	r0, Z+4	; 0x04
    306c:	f5 81       	ldd	r31, Z+5	; 0x05
    306e:	e0 2d       	mov	r30, r0
    3070:	8d 81       	ldd	r24, Y+5	; 0x05
    3072:	9e 81       	ldd	r25, Y+6	; 0x06
    3074:	93 83       	std	Z+3, r25	; 0x03
    3076:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    3078:	e9 81       	ldd	r30, Y+1	; 0x01
    307a:	fa 81       	ldd	r31, Y+2	; 0x02
    307c:	8d 81       	ldd	r24, Y+5	; 0x05
    307e:	9e 81       	ldd	r25, Y+6	; 0x06
    3080:	95 83       	std	Z+5, r25	; 0x05
    3082:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3084:	ed 81       	ldd	r30, Y+5	; 0x05
    3086:	fe 81       	ldd	r31, Y+6	; 0x06
    3088:	8b 81       	ldd	r24, Y+3	; 0x03
    308a:	9c 81       	ldd	r25, Y+4	; 0x04
    308c:	91 87       	std	Z+9, r25	; 0x09
    308e:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    3090:	eb 81       	ldd	r30, Y+3	; 0x03
    3092:	fc 81       	ldd	r31, Y+4	; 0x04
    3094:	80 81       	ld	r24, Z
    3096:	8f 5f       	subi	r24, 0xFF	; 255
    3098:	eb 81       	ldd	r30, Y+3	; 0x03
    309a:	fc 81       	ldd	r31, Y+4	; 0x04
    309c:	80 83       	st	Z, r24
}
    309e:	26 96       	adiw	r28, 0x06	; 6
    30a0:	0f b6       	in	r0, 0x3f	; 63
    30a2:	f8 94       	cli
    30a4:	de bf       	out	0x3e, r29	; 62
    30a6:	0f be       	out	0x3f, r0	; 63
    30a8:	cd bf       	out	0x3d, r28	; 61
    30aa:	cf 91       	pop	r28
    30ac:	df 91       	pop	r29
    30ae:	08 95       	ret

000030b0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    30b0:	df 93       	push	r29
    30b2:	cf 93       	push	r28
    30b4:	cd b7       	in	r28, 0x3d	; 61
    30b6:	de b7       	in	r29, 0x3e	; 62
    30b8:	28 97       	sbiw	r28, 0x08	; 8
    30ba:	0f b6       	in	r0, 0x3f	; 63
    30bc:	f8 94       	cli
    30be:	de bf       	out	0x3e, r29	; 62
    30c0:	0f be       	out	0x3f, r0	; 63
    30c2:	cd bf       	out	0x3d, r28	; 61
    30c4:	9e 83       	std	Y+6, r25	; 0x06
    30c6:	8d 83       	std	Y+5, r24	; 0x05
    30c8:	78 87       	std	Y+8, r23	; 0x08
    30ca:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    30cc:	ef 81       	ldd	r30, Y+7	; 0x07
    30ce:	f8 85       	ldd	r31, Y+8	; 0x08
    30d0:	80 81       	ld	r24, Z
    30d2:	91 81       	ldd	r25, Z+1	; 0x01
    30d4:	9a 83       	std	Y+2, r25	; 0x02
    30d6:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    30d8:	89 81       	ldd	r24, Y+1	; 0x01
    30da:	9a 81       	ldd	r25, Y+2	; 0x02
    30dc:	2f ef       	ldi	r18, 0xFF	; 255
    30de:	8f 3f       	cpi	r24, 0xFF	; 255
    30e0:	92 07       	cpc	r25, r18
    30e2:	39 f4       	brne	.+14     	; 0x30f2 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    30e4:	ed 81       	ldd	r30, Y+5	; 0x05
    30e6:	fe 81       	ldd	r31, Y+6	; 0x06
    30e8:	87 81       	ldd	r24, Z+7	; 0x07
    30ea:	90 85       	ldd	r25, Z+8	; 0x08
    30ec:	9c 83       	std	Y+4, r25	; 0x04
    30ee:	8b 83       	std	Y+3, r24	; 0x03
    30f0:	18 c0       	rjmp	.+48     	; 0x3122 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    30f2:	8d 81       	ldd	r24, Y+5	; 0x05
    30f4:	9e 81       	ldd	r25, Y+6	; 0x06
    30f6:	03 96       	adiw	r24, 0x03	; 3
    30f8:	9c 83       	std	Y+4, r25	; 0x04
    30fa:	8b 83       	std	Y+3, r24	; 0x03
    30fc:	06 c0       	rjmp	.+12     	; 0x310a <vListInsert+0x5a>
    30fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3100:	fc 81       	ldd	r31, Y+4	; 0x04
    3102:	82 81       	ldd	r24, Z+2	; 0x02
    3104:	93 81       	ldd	r25, Z+3	; 0x03
    3106:	9c 83       	std	Y+4, r25	; 0x04
    3108:	8b 83       	std	Y+3, r24	; 0x03
    310a:	eb 81       	ldd	r30, Y+3	; 0x03
    310c:	fc 81       	ldd	r31, Y+4	; 0x04
    310e:	02 80       	ldd	r0, Z+2	; 0x02
    3110:	f3 81       	ldd	r31, Z+3	; 0x03
    3112:	e0 2d       	mov	r30, r0
    3114:	20 81       	ld	r18, Z
    3116:	31 81       	ldd	r19, Z+1	; 0x01
    3118:	89 81       	ldd	r24, Y+1	; 0x01
    311a:	9a 81       	ldd	r25, Y+2	; 0x02
    311c:	82 17       	cp	r24, r18
    311e:	93 07       	cpc	r25, r19
    3120:	70 f7       	brcc	.-36     	; 0x30fe <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    3122:	eb 81       	ldd	r30, Y+3	; 0x03
    3124:	fc 81       	ldd	r31, Y+4	; 0x04
    3126:	82 81       	ldd	r24, Z+2	; 0x02
    3128:	93 81       	ldd	r25, Z+3	; 0x03
    312a:	ef 81       	ldd	r30, Y+7	; 0x07
    312c:	f8 85       	ldd	r31, Y+8	; 0x08
    312e:	93 83       	std	Z+3, r25	; 0x03
    3130:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3132:	ef 81       	ldd	r30, Y+7	; 0x07
    3134:	f8 85       	ldd	r31, Y+8	; 0x08
    3136:	02 80       	ldd	r0, Z+2	; 0x02
    3138:	f3 81       	ldd	r31, Z+3	; 0x03
    313a:	e0 2d       	mov	r30, r0
    313c:	8f 81       	ldd	r24, Y+7	; 0x07
    313e:	98 85       	ldd	r25, Y+8	; 0x08
    3140:	95 83       	std	Z+5, r25	; 0x05
    3142:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    3144:	ef 81       	ldd	r30, Y+7	; 0x07
    3146:	f8 85       	ldd	r31, Y+8	; 0x08
    3148:	8b 81       	ldd	r24, Y+3	; 0x03
    314a:	9c 81       	ldd	r25, Y+4	; 0x04
    314c:	95 83       	std	Z+5, r25	; 0x05
    314e:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3150:	eb 81       	ldd	r30, Y+3	; 0x03
    3152:	fc 81       	ldd	r31, Y+4	; 0x04
    3154:	8f 81       	ldd	r24, Y+7	; 0x07
    3156:	98 85       	ldd	r25, Y+8	; 0x08
    3158:	93 83       	std	Z+3, r25	; 0x03
    315a:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    315c:	ef 81       	ldd	r30, Y+7	; 0x07
    315e:	f8 85       	ldd	r31, Y+8	; 0x08
    3160:	8d 81       	ldd	r24, Y+5	; 0x05
    3162:	9e 81       	ldd	r25, Y+6	; 0x06
    3164:	91 87       	std	Z+9, r25	; 0x09
    3166:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    3168:	ed 81       	ldd	r30, Y+5	; 0x05
    316a:	fe 81       	ldd	r31, Y+6	; 0x06
    316c:	80 81       	ld	r24, Z
    316e:	8f 5f       	subi	r24, 0xFF	; 255
    3170:	ed 81       	ldd	r30, Y+5	; 0x05
    3172:	fe 81       	ldd	r31, Y+6	; 0x06
    3174:	80 83       	st	Z, r24
}
    3176:	28 96       	adiw	r28, 0x08	; 8
    3178:	0f b6       	in	r0, 0x3f	; 63
    317a:	f8 94       	cli
    317c:	de bf       	out	0x3e, r29	; 62
    317e:	0f be       	out	0x3f, r0	; 63
    3180:	cd bf       	out	0x3d, r28	; 61
    3182:	cf 91       	pop	r28
    3184:	df 91       	pop	r29
    3186:	08 95       	ret

00003188 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3188:	df 93       	push	r29
    318a:	cf 93       	push	r28
    318c:	00 d0       	rcall	.+0      	; 0x318e <uxListRemove+0x6>
    318e:	00 d0       	rcall	.+0      	; 0x3190 <uxListRemove+0x8>
    3190:	cd b7       	in	r28, 0x3d	; 61
    3192:	de b7       	in	r29, 0x3e	; 62
    3194:	9c 83       	std	Y+4, r25	; 0x04
    3196:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    3198:	eb 81       	ldd	r30, Y+3	; 0x03
    319a:	fc 81       	ldd	r31, Y+4	; 0x04
    319c:	80 85       	ldd	r24, Z+8	; 0x08
    319e:	91 85       	ldd	r25, Z+9	; 0x09
    31a0:	9a 83       	std	Y+2, r25	; 0x02
    31a2:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    31a4:	eb 81       	ldd	r30, Y+3	; 0x03
    31a6:	fc 81       	ldd	r31, Y+4	; 0x04
    31a8:	a2 81       	ldd	r26, Z+2	; 0x02
    31aa:	b3 81       	ldd	r27, Z+3	; 0x03
    31ac:	eb 81       	ldd	r30, Y+3	; 0x03
    31ae:	fc 81       	ldd	r31, Y+4	; 0x04
    31b0:	84 81       	ldd	r24, Z+4	; 0x04
    31b2:	95 81       	ldd	r25, Z+5	; 0x05
    31b4:	15 96       	adiw	r26, 0x05	; 5
    31b6:	9c 93       	st	X, r25
    31b8:	8e 93       	st	-X, r24
    31ba:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    31bc:	eb 81       	ldd	r30, Y+3	; 0x03
    31be:	fc 81       	ldd	r31, Y+4	; 0x04
    31c0:	a4 81       	ldd	r26, Z+4	; 0x04
    31c2:	b5 81       	ldd	r27, Z+5	; 0x05
    31c4:	eb 81       	ldd	r30, Y+3	; 0x03
    31c6:	fc 81       	ldd	r31, Y+4	; 0x04
    31c8:	82 81       	ldd	r24, Z+2	; 0x02
    31ca:	93 81       	ldd	r25, Z+3	; 0x03
    31cc:	13 96       	adiw	r26, 0x03	; 3
    31ce:	9c 93       	st	X, r25
    31d0:	8e 93       	st	-X, r24
    31d2:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    31d4:	e9 81       	ldd	r30, Y+1	; 0x01
    31d6:	fa 81       	ldd	r31, Y+2	; 0x02
    31d8:	21 81       	ldd	r18, Z+1	; 0x01
    31da:	32 81       	ldd	r19, Z+2	; 0x02
    31dc:	8b 81       	ldd	r24, Y+3	; 0x03
    31de:	9c 81       	ldd	r25, Y+4	; 0x04
    31e0:	28 17       	cp	r18, r24
    31e2:	39 07       	cpc	r19, r25
    31e4:	41 f4       	brne	.+16     	; 0x31f6 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    31e6:	eb 81       	ldd	r30, Y+3	; 0x03
    31e8:	fc 81       	ldd	r31, Y+4	; 0x04
    31ea:	84 81       	ldd	r24, Z+4	; 0x04
    31ec:	95 81       	ldd	r25, Z+5	; 0x05
    31ee:	e9 81       	ldd	r30, Y+1	; 0x01
    31f0:	fa 81       	ldd	r31, Y+2	; 0x02
    31f2:	92 83       	std	Z+2, r25	; 0x02
    31f4:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    31f6:	eb 81       	ldd	r30, Y+3	; 0x03
    31f8:	fc 81       	ldd	r31, Y+4	; 0x04
    31fa:	11 86       	std	Z+9, r1	; 0x09
    31fc:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    31fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3200:	fa 81       	ldd	r31, Y+2	; 0x02
    3202:	80 81       	ld	r24, Z
    3204:	81 50       	subi	r24, 0x01	; 1
    3206:	e9 81       	ldd	r30, Y+1	; 0x01
    3208:	fa 81       	ldd	r31, Y+2	; 0x02
    320a:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    320c:	e9 81       	ldd	r30, Y+1	; 0x01
    320e:	fa 81       	ldd	r31, Y+2	; 0x02
    3210:	80 81       	ld	r24, Z
}
    3212:	0f 90       	pop	r0
    3214:	0f 90       	pop	r0
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	cf 91       	pop	r28
    321c:	df 91       	pop	r29
    321e:	08 95       	ret

00003220 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    3220:	df 93       	push	r29
    3222:	cf 93       	push	r28
    3224:	cd b7       	in	r28, 0x3d	; 61
    3226:	de b7       	in	r29, 0x3e	; 62
    3228:	28 97       	sbiw	r28, 0x08	; 8
    322a:	0f b6       	in	r0, 0x3f	; 63
    322c:	f8 94       	cli
    322e:	de bf       	out	0x3e, r29	; 62
    3230:	0f be       	out	0x3f, r0	; 63
    3232:	cd bf       	out	0x3d, r28	; 61
    3234:	9c 83       	std	Y+4, r25	; 0x04
    3236:	8b 83       	std	Y+3, r24	; 0x03
    3238:	7e 83       	std	Y+6, r23	; 0x06
    323a:	6d 83       	std	Y+5, r22	; 0x05
    323c:	58 87       	std	Y+8, r21	; 0x08
    323e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3240:	eb 81       	ldd	r30, Y+3	; 0x03
    3242:	fc 81       	ldd	r31, Y+4	; 0x04
    3244:	81 e1       	ldi	r24, 0x11	; 17
    3246:	80 83       	st	Z, r24
	pxTopOfStack--;
    3248:	8b 81       	ldd	r24, Y+3	; 0x03
    324a:	9c 81       	ldd	r25, Y+4	; 0x04
    324c:	01 97       	sbiw	r24, 0x01	; 1
    324e:	9c 83       	std	Y+4, r25	; 0x04
    3250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3252:	eb 81       	ldd	r30, Y+3	; 0x03
    3254:	fc 81       	ldd	r31, Y+4	; 0x04
    3256:	82 e2       	ldi	r24, 0x22	; 34
    3258:	80 83       	st	Z, r24
	pxTopOfStack--;
    325a:	8b 81       	ldd	r24, Y+3	; 0x03
    325c:	9c 81       	ldd	r25, Y+4	; 0x04
    325e:	01 97       	sbiw	r24, 0x01	; 1
    3260:	9c 83       	std	Y+4, r25	; 0x04
    3262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3264:	eb 81       	ldd	r30, Y+3	; 0x03
    3266:	fc 81       	ldd	r31, Y+4	; 0x04
    3268:	83 e3       	ldi	r24, 0x33	; 51
    326a:	80 83       	st	Z, r24
	pxTopOfStack--;
    326c:	8b 81       	ldd	r24, Y+3	; 0x03
    326e:	9c 81       	ldd	r25, Y+4	; 0x04
    3270:	01 97       	sbiw	r24, 0x01	; 1
    3272:	9c 83       	std	Y+4, r25	; 0x04
    3274:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    3276:	8d 81       	ldd	r24, Y+5	; 0x05
    3278:	9e 81       	ldd	r25, Y+6	; 0x06
    327a:	9a 83       	std	Y+2, r25	; 0x02
    327c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    327e:	89 81       	ldd	r24, Y+1	; 0x01
    3280:	eb 81       	ldd	r30, Y+3	; 0x03
    3282:	fc 81       	ldd	r31, Y+4	; 0x04
    3284:	80 83       	st	Z, r24
	pxTopOfStack--;
    3286:	8b 81       	ldd	r24, Y+3	; 0x03
    3288:	9c 81       	ldd	r25, Y+4	; 0x04
    328a:	01 97       	sbiw	r24, 0x01	; 1
    328c:	9c 83       	std	Y+4, r25	; 0x04
    328e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3290:	89 81       	ldd	r24, Y+1	; 0x01
    3292:	9a 81       	ldd	r25, Y+2	; 0x02
    3294:	89 2f       	mov	r24, r25
    3296:	99 27       	eor	r25, r25
    3298:	9a 83       	std	Y+2, r25	; 0x02
    329a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    329c:	89 81       	ldd	r24, Y+1	; 0x01
    329e:	eb 81       	ldd	r30, Y+3	; 0x03
    32a0:	fc 81       	ldd	r31, Y+4	; 0x04
    32a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    32a4:	8b 81       	ldd	r24, Y+3	; 0x03
    32a6:	9c 81       	ldd	r25, Y+4	; 0x04
    32a8:	01 97       	sbiw	r24, 0x01	; 1
    32aa:	9c 83       	std	Y+4, r25	; 0x04
    32ac:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    32ae:	eb 81       	ldd	r30, Y+3	; 0x03
    32b0:	fc 81       	ldd	r31, Y+4	; 0x04
    32b2:	10 82       	st	Z, r1
	pxTopOfStack--;
    32b4:	8b 81       	ldd	r24, Y+3	; 0x03
    32b6:	9c 81       	ldd	r25, Y+4	; 0x04
    32b8:	01 97       	sbiw	r24, 0x01	; 1
    32ba:	9c 83       	std	Y+4, r25	; 0x04
    32bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    32be:	eb 81       	ldd	r30, Y+3	; 0x03
    32c0:	fc 81       	ldd	r31, Y+4	; 0x04
    32c2:	80 e8       	ldi	r24, 0x80	; 128
    32c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    32c6:	8b 81       	ldd	r24, Y+3	; 0x03
    32c8:	9c 81       	ldd	r25, Y+4	; 0x04
    32ca:	01 97       	sbiw	r24, 0x01	; 1
    32cc:	9c 83       	std	Y+4, r25	; 0x04
    32ce:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    32d0:	eb 81       	ldd	r30, Y+3	; 0x03
    32d2:	fc 81       	ldd	r31, Y+4	; 0x04
    32d4:	10 82       	st	Z, r1
	pxTopOfStack--;
    32d6:	8b 81       	ldd	r24, Y+3	; 0x03
    32d8:	9c 81       	ldd	r25, Y+4	; 0x04
    32da:	01 97       	sbiw	r24, 0x01	; 1
    32dc:	9c 83       	std	Y+4, r25	; 0x04
    32de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    32e0:	eb 81       	ldd	r30, Y+3	; 0x03
    32e2:	fc 81       	ldd	r31, Y+4	; 0x04
    32e4:	82 e0       	ldi	r24, 0x02	; 2
    32e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    32e8:	8b 81       	ldd	r24, Y+3	; 0x03
    32ea:	9c 81       	ldd	r25, Y+4	; 0x04
    32ec:	01 97       	sbiw	r24, 0x01	; 1
    32ee:	9c 83       	std	Y+4, r25	; 0x04
    32f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    32f2:	eb 81       	ldd	r30, Y+3	; 0x03
    32f4:	fc 81       	ldd	r31, Y+4	; 0x04
    32f6:	83 e0       	ldi	r24, 0x03	; 3
    32f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    32fa:	8b 81       	ldd	r24, Y+3	; 0x03
    32fc:	9c 81       	ldd	r25, Y+4	; 0x04
    32fe:	01 97       	sbiw	r24, 0x01	; 1
    3300:	9c 83       	std	Y+4, r25	; 0x04
    3302:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    3304:	eb 81       	ldd	r30, Y+3	; 0x03
    3306:	fc 81       	ldd	r31, Y+4	; 0x04
    3308:	84 e0       	ldi	r24, 0x04	; 4
    330a:	80 83       	st	Z, r24
	pxTopOfStack--;
    330c:	8b 81       	ldd	r24, Y+3	; 0x03
    330e:	9c 81       	ldd	r25, Y+4	; 0x04
    3310:	01 97       	sbiw	r24, 0x01	; 1
    3312:	9c 83       	std	Y+4, r25	; 0x04
    3314:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    3316:	eb 81       	ldd	r30, Y+3	; 0x03
    3318:	fc 81       	ldd	r31, Y+4	; 0x04
    331a:	85 e0       	ldi	r24, 0x05	; 5
    331c:	80 83       	st	Z, r24
	pxTopOfStack--;
    331e:	8b 81       	ldd	r24, Y+3	; 0x03
    3320:	9c 81       	ldd	r25, Y+4	; 0x04
    3322:	01 97       	sbiw	r24, 0x01	; 1
    3324:	9c 83       	std	Y+4, r25	; 0x04
    3326:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3328:	eb 81       	ldd	r30, Y+3	; 0x03
    332a:	fc 81       	ldd	r31, Y+4	; 0x04
    332c:	86 e0       	ldi	r24, 0x06	; 6
    332e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3330:	8b 81       	ldd	r24, Y+3	; 0x03
    3332:	9c 81       	ldd	r25, Y+4	; 0x04
    3334:	01 97       	sbiw	r24, 0x01	; 1
    3336:	9c 83       	std	Y+4, r25	; 0x04
    3338:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    333a:	eb 81       	ldd	r30, Y+3	; 0x03
    333c:	fc 81       	ldd	r31, Y+4	; 0x04
    333e:	87 e0       	ldi	r24, 0x07	; 7
    3340:	80 83       	st	Z, r24
	pxTopOfStack--;
    3342:	8b 81       	ldd	r24, Y+3	; 0x03
    3344:	9c 81       	ldd	r25, Y+4	; 0x04
    3346:	01 97       	sbiw	r24, 0x01	; 1
    3348:	9c 83       	std	Y+4, r25	; 0x04
    334a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    334c:	eb 81       	ldd	r30, Y+3	; 0x03
    334e:	fc 81       	ldd	r31, Y+4	; 0x04
    3350:	88 e0       	ldi	r24, 0x08	; 8
    3352:	80 83       	st	Z, r24
	pxTopOfStack--;
    3354:	8b 81       	ldd	r24, Y+3	; 0x03
    3356:	9c 81       	ldd	r25, Y+4	; 0x04
    3358:	01 97       	sbiw	r24, 0x01	; 1
    335a:	9c 83       	std	Y+4, r25	; 0x04
    335c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    335e:	eb 81       	ldd	r30, Y+3	; 0x03
    3360:	fc 81       	ldd	r31, Y+4	; 0x04
    3362:	89 e0       	ldi	r24, 0x09	; 9
    3364:	80 83       	st	Z, r24
	pxTopOfStack--;
    3366:	8b 81       	ldd	r24, Y+3	; 0x03
    3368:	9c 81       	ldd	r25, Y+4	; 0x04
    336a:	01 97       	sbiw	r24, 0x01	; 1
    336c:	9c 83       	std	Y+4, r25	; 0x04
    336e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3370:	eb 81       	ldd	r30, Y+3	; 0x03
    3372:	fc 81       	ldd	r31, Y+4	; 0x04
    3374:	80 e1       	ldi	r24, 0x10	; 16
    3376:	80 83       	st	Z, r24
	pxTopOfStack--;
    3378:	8b 81       	ldd	r24, Y+3	; 0x03
    337a:	9c 81       	ldd	r25, Y+4	; 0x04
    337c:	01 97       	sbiw	r24, 0x01	; 1
    337e:	9c 83       	std	Y+4, r25	; 0x04
    3380:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3382:	eb 81       	ldd	r30, Y+3	; 0x03
    3384:	fc 81       	ldd	r31, Y+4	; 0x04
    3386:	81 e1       	ldi	r24, 0x11	; 17
    3388:	80 83       	st	Z, r24
	pxTopOfStack--;
    338a:	8b 81       	ldd	r24, Y+3	; 0x03
    338c:	9c 81       	ldd	r25, Y+4	; 0x04
    338e:	01 97       	sbiw	r24, 0x01	; 1
    3390:	9c 83       	std	Y+4, r25	; 0x04
    3392:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3394:	eb 81       	ldd	r30, Y+3	; 0x03
    3396:	fc 81       	ldd	r31, Y+4	; 0x04
    3398:	82 e1       	ldi	r24, 0x12	; 18
    339a:	80 83       	st	Z, r24
	pxTopOfStack--;
    339c:	8b 81       	ldd	r24, Y+3	; 0x03
    339e:	9c 81       	ldd	r25, Y+4	; 0x04
    33a0:	01 97       	sbiw	r24, 0x01	; 1
    33a2:	9c 83       	std	Y+4, r25	; 0x04
    33a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    33a6:	eb 81       	ldd	r30, Y+3	; 0x03
    33a8:	fc 81       	ldd	r31, Y+4	; 0x04
    33aa:	83 e1       	ldi	r24, 0x13	; 19
    33ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    33ae:	8b 81       	ldd	r24, Y+3	; 0x03
    33b0:	9c 81       	ldd	r25, Y+4	; 0x04
    33b2:	01 97       	sbiw	r24, 0x01	; 1
    33b4:	9c 83       	std	Y+4, r25	; 0x04
    33b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    33b8:	eb 81       	ldd	r30, Y+3	; 0x03
    33ba:	fc 81       	ldd	r31, Y+4	; 0x04
    33bc:	84 e1       	ldi	r24, 0x14	; 20
    33be:	80 83       	st	Z, r24
	pxTopOfStack--;
    33c0:	8b 81       	ldd	r24, Y+3	; 0x03
    33c2:	9c 81       	ldd	r25, Y+4	; 0x04
    33c4:	01 97       	sbiw	r24, 0x01	; 1
    33c6:	9c 83       	std	Y+4, r25	; 0x04
    33c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    33ca:	eb 81       	ldd	r30, Y+3	; 0x03
    33cc:	fc 81       	ldd	r31, Y+4	; 0x04
    33ce:	85 e1       	ldi	r24, 0x15	; 21
    33d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    33d2:	8b 81       	ldd	r24, Y+3	; 0x03
    33d4:	9c 81       	ldd	r25, Y+4	; 0x04
    33d6:	01 97       	sbiw	r24, 0x01	; 1
    33d8:	9c 83       	std	Y+4, r25	; 0x04
    33da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    33dc:	eb 81       	ldd	r30, Y+3	; 0x03
    33de:	fc 81       	ldd	r31, Y+4	; 0x04
    33e0:	86 e1       	ldi	r24, 0x16	; 22
    33e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    33e4:	8b 81       	ldd	r24, Y+3	; 0x03
    33e6:	9c 81       	ldd	r25, Y+4	; 0x04
    33e8:	01 97       	sbiw	r24, 0x01	; 1
    33ea:	9c 83       	std	Y+4, r25	; 0x04
    33ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    33ee:	eb 81       	ldd	r30, Y+3	; 0x03
    33f0:	fc 81       	ldd	r31, Y+4	; 0x04
    33f2:	87 e1       	ldi	r24, 0x17	; 23
    33f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    33f6:	8b 81       	ldd	r24, Y+3	; 0x03
    33f8:	9c 81       	ldd	r25, Y+4	; 0x04
    33fa:	01 97       	sbiw	r24, 0x01	; 1
    33fc:	9c 83       	std	Y+4, r25	; 0x04
    33fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3400:	eb 81       	ldd	r30, Y+3	; 0x03
    3402:	fc 81       	ldd	r31, Y+4	; 0x04
    3404:	88 e1       	ldi	r24, 0x18	; 24
    3406:	80 83       	st	Z, r24
	pxTopOfStack--;
    3408:	8b 81       	ldd	r24, Y+3	; 0x03
    340a:	9c 81       	ldd	r25, Y+4	; 0x04
    340c:	01 97       	sbiw	r24, 0x01	; 1
    340e:	9c 83       	std	Y+4, r25	; 0x04
    3410:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    3412:	eb 81       	ldd	r30, Y+3	; 0x03
    3414:	fc 81       	ldd	r31, Y+4	; 0x04
    3416:	89 e1       	ldi	r24, 0x19	; 25
    3418:	80 83       	st	Z, r24
	pxTopOfStack--;
    341a:	8b 81       	ldd	r24, Y+3	; 0x03
    341c:	9c 81       	ldd	r25, Y+4	; 0x04
    341e:	01 97       	sbiw	r24, 0x01	; 1
    3420:	9c 83       	std	Y+4, r25	; 0x04
    3422:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    3424:	eb 81       	ldd	r30, Y+3	; 0x03
    3426:	fc 81       	ldd	r31, Y+4	; 0x04
    3428:	80 e2       	ldi	r24, 0x20	; 32
    342a:	80 83       	st	Z, r24
	pxTopOfStack--;
    342c:	8b 81       	ldd	r24, Y+3	; 0x03
    342e:	9c 81       	ldd	r25, Y+4	; 0x04
    3430:	01 97       	sbiw	r24, 0x01	; 1
    3432:	9c 83       	std	Y+4, r25	; 0x04
    3434:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    3436:	eb 81       	ldd	r30, Y+3	; 0x03
    3438:	fc 81       	ldd	r31, Y+4	; 0x04
    343a:	81 e2       	ldi	r24, 0x21	; 33
    343c:	80 83       	st	Z, r24
	pxTopOfStack--;
    343e:	8b 81       	ldd	r24, Y+3	; 0x03
    3440:	9c 81       	ldd	r25, Y+4	; 0x04
    3442:	01 97       	sbiw	r24, 0x01	; 1
    3444:	9c 83       	std	Y+4, r25	; 0x04
    3446:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3448:	eb 81       	ldd	r30, Y+3	; 0x03
    344a:	fc 81       	ldd	r31, Y+4	; 0x04
    344c:	82 e2       	ldi	r24, 0x22	; 34
    344e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3450:	8b 81       	ldd	r24, Y+3	; 0x03
    3452:	9c 81       	ldd	r25, Y+4	; 0x04
    3454:	01 97       	sbiw	r24, 0x01	; 1
    3456:	9c 83       	std	Y+4, r25	; 0x04
    3458:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    345a:	eb 81       	ldd	r30, Y+3	; 0x03
    345c:	fc 81       	ldd	r31, Y+4	; 0x04
    345e:	83 e2       	ldi	r24, 0x23	; 35
    3460:	80 83       	st	Z, r24
	pxTopOfStack--;
    3462:	8b 81       	ldd	r24, Y+3	; 0x03
    3464:	9c 81       	ldd	r25, Y+4	; 0x04
    3466:	01 97       	sbiw	r24, 0x01	; 1
    3468:	9c 83       	std	Y+4, r25	; 0x04
    346a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    346c:	8f 81       	ldd	r24, Y+7	; 0x07
    346e:	98 85       	ldd	r25, Y+8	; 0x08
    3470:	9a 83       	std	Y+2, r25	; 0x02
    3472:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3474:	89 81       	ldd	r24, Y+1	; 0x01
    3476:	eb 81       	ldd	r30, Y+3	; 0x03
    3478:	fc 81       	ldd	r31, Y+4	; 0x04
    347a:	80 83       	st	Z, r24
	pxTopOfStack--;
    347c:	8b 81       	ldd	r24, Y+3	; 0x03
    347e:	9c 81       	ldd	r25, Y+4	; 0x04
    3480:	01 97       	sbiw	r24, 0x01	; 1
    3482:	9c 83       	std	Y+4, r25	; 0x04
    3484:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3486:	89 81       	ldd	r24, Y+1	; 0x01
    3488:	9a 81       	ldd	r25, Y+2	; 0x02
    348a:	89 2f       	mov	r24, r25
    348c:	99 27       	eor	r25, r25
    348e:	9a 83       	std	Y+2, r25	; 0x02
    3490:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3492:	89 81       	ldd	r24, Y+1	; 0x01
    3494:	eb 81       	ldd	r30, Y+3	; 0x03
    3496:	fc 81       	ldd	r31, Y+4	; 0x04
    3498:	80 83       	st	Z, r24
	pxTopOfStack--;
    349a:	8b 81       	ldd	r24, Y+3	; 0x03
    349c:	9c 81       	ldd	r25, Y+4	; 0x04
    349e:	01 97       	sbiw	r24, 0x01	; 1
    34a0:	9c 83       	std	Y+4, r25	; 0x04
    34a2:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    34a4:	eb 81       	ldd	r30, Y+3	; 0x03
    34a6:	fc 81       	ldd	r31, Y+4	; 0x04
    34a8:	86 e2       	ldi	r24, 0x26	; 38
    34aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    34ac:	8b 81       	ldd	r24, Y+3	; 0x03
    34ae:	9c 81       	ldd	r25, Y+4	; 0x04
    34b0:	01 97       	sbiw	r24, 0x01	; 1
    34b2:	9c 83       	std	Y+4, r25	; 0x04
    34b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    34b6:	eb 81       	ldd	r30, Y+3	; 0x03
    34b8:	fc 81       	ldd	r31, Y+4	; 0x04
    34ba:	87 e2       	ldi	r24, 0x27	; 39
    34bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    34be:	8b 81       	ldd	r24, Y+3	; 0x03
    34c0:	9c 81       	ldd	r25, Y+4	; 0x04
    34c2:	01 97       	sbiw	r24, 0x01	; 1
    34c4:	9c 83       	std	Y+4, r25	; 0x04
    34c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    34c8:	eb 81       	ldd	r30, Y+3	; 0x03
    34ca:	fc 81       	ldd	r31, Y+4	; 0x04
    34cc:	88 e2       	ldi	r24, 0x28	; 40
    34ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    34d0:	8b 81       	ldd	r24, Y+3	; 0x03
    34d2:	9c 81       	ldd	r25, Y+4	; 0x04
    34d4:	01 97       	sbiw	r24, 0x01	; 1
    34d6:	9c 83       	std	Y+4, r25	; 0x04
    34d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    34da:	eb 81       	ldd	r30, Y+3	; 0x03
    34dc:	fc 81       	ldd	r31, Y+4	; 0x04
    34de:	89 e2       	ldi	r24, 0x29	; 41
    34e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    34e2:	8b 81       	ldd	r24, Y+3	; 0x03
    34e4:	9c 81       	ldd	r25, Y+4	; 0x04
    34e6:	01 97       	sbiw	r24, 0x01	; 1
    34e8:	9c 83       	std	Y+4, r25	; 0x04
    34ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    34ec:	eb 81       	ldd	r30, Y+3	; 0x03
    34ee:	fc 81       	ldd	r31, Y+4	; 0x04
    34f0:	80 e3       	ldi	r24, 0x30	; 48
    34f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    34f4:	8b 81       	ldd	r24, Y+3	; 0x03
    34f6:	9c 81       	ldd	r25, Y+4	; 0x04
    34f8:	01 97       	sbiw	r24, 0x01	; 1
    34fa:	9c 83       	std	Y+4, r25	; 0x04
    34fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    34fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3500:	fc 81       	ldd	r31, Y+4	; 0x04
    3502:	81 e3       	ldi	r24, 0x31	; 49
    3504:	80 83       	st	Z, r24
	pxTopOfStack--;
    3506:	8b 81       	ldd	r24, Y+3	; 0x03
    3508:	9c 81       	ldd	r25, Y+4	; 0x04
    350a:	01 97       	sbiw	r24, 0x01	; 1
    350c:	9c 83       	std	Y+4, r25	; 0x04
    350e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3510:	8b 81       	ldd	r24, Y+3	; 0x03
    3512:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3514:	28 96       	adiw	r28, 0x08	; 8
    3516:	0f b6       	in	r0, 0x3f	; 63
    3518:	f8 94       	cli
    351a:	de bf       	out	0x3e, r29	; 62
    351c:	0f be       	out	0x3f, r0	; 63
    351e:	cd bf       	out	0x3d, r28	; 61
    3520:	cf 91       	pop	r28
    3522:	df 91       	pop	r29
    3524:	08 95       	ret

00003526 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    3526:	df 93       	push	r29
    3528:	cf 93       	push	r28
    352a:	cd b7       	in	r28, 0x3d	; 61
    352c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    352e:	0e 94 85 1b 	call	0x370a	; 0x370a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3532:	a0 91 56 07 	lds	r26, 0x0756
    3536:	b0 91 57 07 	lds	r27, 0x0757
    353a:	cd 91       	ld	r28, X+
    353c:	cd bf       	out	0x3d, r28	; 61
    353e:	dd 91       	ld	r29, X+
    3540:	de bf       	out	0x3e, r29	; 62
    3542:	ff 91       	pop	r31
    3544:	ef 91       	pop	r30
    3546:	df 91       	pop	r29
    3548:	cf 91       	pop	r28
    354a:	bf 91       	pop	r27
    354c:	af 91       	pop	r26
    354e:	9f 91       	pop	r25
    3550:	8f 91       	pop	r24
    3552:	7f 91       	pop	r23
    3554:	6f 91       	pop	r22
    3556:	5f 91       	pop	r21
    3558:	4f 91       	pop	r20
    355a:	3f 91       	pop	r19
    355c:	2f 91       	pop	r18
    355e:	1f 91       	pop	r17
    3560:	0f 91       	pop	r16
    3562:	ff 90       	pop	r15
    3564:	ef 90       	pop	r14
    3566:	df 90       	pop	r13
    3568:	cf 90       	pop	r12
    356a:	bf 90       	pop	r11
    356c:	af 90       	pop	r10
    356e:	9f 90       	pop	r9
    3570:	8f 90       	pop	r8
    3572:	7f 90       	pop	r7
    3574:	6f 90       	pop	r6
    3576:	5f 90       	pop	r5
    3578:	4f 90       	pop	r4
    357a:	3f 90       	pop	r3
    357c:	2f 90       	pop	r2
    357e:	1f 90       	pop	r1
    3580:	0f 90       	pop	r0
    3582:	0f be       	out	0x3f, r0	; 63
    3584:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3586:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3588:	81 e0       	ldi	r24, 0x01	; 1
}
    358a:	cf 91       	pop	r28
    358c:	df 91       	pop	r29
    358e:	08 95       	ret

00003590 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3590:	df 93       	push	r29
    3592:	cf 93       	push	r28
    3594:	cd b7       	in	r28, 0x3d	; 61
    3596:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3598:	cf 91       	pop	r28
    359a:	df 91       	pop	r29
    359c:	08 95       	ret

0000359e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    359e:	0f 92       	push	r0
    35a0:	0f b6       	in	r0, 0x3f	; 63
    35a2:	f8 94       	cli
    35a4:	0f 92       	push	r0
    35a6:	1f 92       	push	r1
    35a8:	11 24       	eor	r1, r1
    35aa:	2f 92       	push	r2
    35ac:	3f 92       	push	r3
    35ae:	4f 92       	push	r4
    35b0:	5f 92       	push	r5
    35b2:	6f 92       	push	r6
    35b4:	7f 92       	push	r7
    35b6:	8f 92       	push	r8
    35b8:	9f 92       	push	r9
    35ba:	af 92       	push	r10
    35bc:	bf 92       	push	r11
    35be:	cf 92       	push	r12
    35c0:	df 92       	push	r13
    35c2:	ef 92       	push	r14
    35c4:	ff 92       	push	r15
    35c6:	0f 93       	push	r16
    35c8:	1f 93       	push	r17
    35ca:	2f 93       	push	r18
    35cc:	3f 93       	push	r19
    35ce:	4f 93       	push	r20
    35d0:	5f 93       	push	r21
    35d2:	6f 93       	push	r22
    35d4:	7f 93       	push	r23
    35d6:	8f 93       	push	r24
    35d8:	9f 93       	push	r25
    35da:	af 93       	push	r26
    35dc:	bf 93       	push	r27
    35de:	cf 93       	push	r28
    35e0:	df 93       	push	r29
    35e2:	ef 93       	push	r30
    35e4:	ff 93       	push	r31
    35e6:	a0 91 56 07 	lds	r26, 0x0756
    35ea:	b0 91 57 07 	lds	r27, 0x0757
    35ee:	0d b6       	in	r0, 0x3d	; 61
    35f0:	0d 92       	st	X+, r0
    35f2:	0e b6       	in	r0, 0x3e	; 62
    35f4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    35f6:	0e 94 09 35 	call	0x6a12	; 0x6a12 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    35fa:	a0 91 56 07 	lds	r26, 0x0756
    35fe:	b0 91 57 07 	lds	r27, 0x0757
    3602:	cd 91       	ld	r28, X+
    3604:	cd bf       	out	0x3d, r28	; 61
    3606:	dd 91       	ld	r29, X+
    3608:	de bf       	out	0x3e, r29	; 62
    360a:	ff 91       	pop	r31
    360c:	ef 91       	pop	r30
    360e:	df 91       	pop	r29
    3610:	cf 91       	pop	r28
    3612:	bf 91       	pop	r27
    3614:	af 91       	pop	r26
    3616:	9f 91       	pop	r25
    3618:	8f 91       	pop	r24
    361a:	7f 91       	pop	r23
    361c:	6f 91       	pop	r22
    361e:	5f 91       	pop	r21
    3620:	4f 91       	pop	r20
    3622:	3f 91       	pop	r19
    3624:	2f 91       	pop	r18
    3626:	1f 91       	pop	r17
    3628:	0f 91       	pop	r16
    362a:	ff 90       	pop	r15
    362c:	ef 90       	pop	r14
    362e:	df 90       	pop	r13
    3630:	cf 90       	pop	r12
    3632:	bf 90       	pop	r11
    3634:	af 90       	pop	r10
    3636:	9f 90       	pop	r9
    3638:	8f 90       	pop	r8
    363a:	7f 90       	pop	r7
    363c:	6f 90       	pop	r6
    363e:	5f 90       	pop	r5
    3640:	4f 90       	pop	r4
    3642:	3f 90       	pop	r3
    3644:	2f 90       	pop	r2
    3646:	1f 90       	pop	r1
    3648:	0f 90       	pop	r0
    364a:	0f be       	out	0x3f, r0	; 63
    364c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    364e:	08 95       	ret

00003650 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3650:	0f 92       	push	r0
    3652:	0f b6       	in	r0, 0x3f	; 63
    3654:	f8 94       	cli
    3656:	0f 92       	push	r0
    3658:	1f 92       	push	r1
    365a:	11 24       	eor	r1, r1
    365c:	2f 92       	push	r2
    365e:	3f 92       	push	r3
    3660:	4f 92       	push	r4
    3662:	5f 92       	push	r5
    3664:	6f 92       	push	r6
    3666:	7f 92       	push	r7
    3668:	8f 92       	push	r8
    366a:	9f 92       	push	r9
    366c:	af 92       	push	r10
    366e:	bf 92       	push	r11
    3670:	cf 92       	push	r12
    3672:	df 92       	push	r13
    3674:	ef 92       	push	r14
    3676:	ff 92       	push	r15
    3678:	0f 93       	push	r16
    367a:	1f 93       	push	r17
    367c:	2f 93       	push	r18
    367e:	3f 93       	push	r19
    3680:	4f 93       	push	r20
    3682:	5f 93       	push	r21
    3684:	6f 93       	push	r22
    3686:	7f 93       	push	r23
    3688:	8f 93       	push	r24
    368a:	9f 93       	push	r25
    368c:	af 93       	push	r26
    368e:	bf 93       	push	r27
    3690:	cf 93       	push	r28
    3692:	df 93       	push	r29
    3694:	ef 93       	push	r30
    3696:	ff 93       	push	r31
    3698:	a0 91 56 07 	lds	r26, 0x0756
    369c:	b0 91 57 07 	lds	r27, 0x0757
    36a0:	0d b6       	in	r0, 0x3d	; 61
    36a2:	0d 92       	st	X+, r0
    36a4:	0e b6       	in	r0, 0x3e	; 62
    36a6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    36a8:	0e 94 72 33 	call	0x66e4	; 0x66e4 <xTaskIncrementTick>
    36ac:	88 23       	and	r24, r24
    36ae:	11 f0       	breq	.+4      	; 0x36b4 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    36b0:	0e 94 09 35 	call	0x6a12	; 0x6a12 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    36b4:	a0 91 56 07 	lds	r26, 0x0756
    36b8:	b0 91 57 07 	lds	r27, 0x0757
    36bc:	cd 91       	ld	r28, X+
    36be:	cd bf       	out	0x3d, r28	; 61
    36c0:	dd 91       	ld	r29, X+
    36c2:	de bf       	out	0x3e, r29	; 62
    36c4:	ff 91       	pop	r31
    36c6:	ef 91       	pop	r30
    36c8:	df 91       	pop	r29
    36ca:	cf 91       	pop	r28
    36cc:	bf 91       	pop	r27
    36ce:	af 91       	pop	r26
    36d0:	9f 91       	pop	r25
    36d2:	8f 91       	pop	r24
    36d4:	7f 91       	pop	r23
    36d6:	6f 91       	pop	r22
    36d8:	5f 91       	pop	r21
    36da:	4f 91       	pop	r20
    36dc:	3f 91       	pop	r19
    36de:	2f 91       	pop	r18
    36e0:	1f 91       	pop	r17
    36e2:	0f 91       	pop	r16
    36e4:	ff 90       	pop	r15
    36e6:	ef 90       	pop	r14
    36e8:	df 90       	pop	r13
    36ea:	cf 90       	pop	r12
    36ec:	bf 90       	pop	r11
    36ee:	af 90       	pop	r10
    36f0:	9f 90       	pop	r9
    36f2:	8f 90       	pop	r8
    36f4:	7f 90       	pop	r7
    36f6:	6f 90       	pop	r6
    36f8:	5f 90       	pop	r5
    36fa:	4f 90       	pop	r4
    36fc:	3f 90       	pop	r3
    36fe:	2f 90       	pop	r2
    3700:	1f 90       	pop	r1
    3702:	0f 90       	pop	r0
    3704:	0f be       	out	0x3f, r0	; 63
    3706:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3708:	08 95       	ret

0000370a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    370a:	df 93       	push	r29
    370c:	cf 93       	push	r28
    370e:	00 d0       	rcall	.+0      	; 0x3710 <prvSetupTimerInterrupt+0x6>
    3710:	00 d0       	rcall	.+0      	; 0x3712 <prvSetupTimerInterrupt+0x8>
    3712:	00 d0       	rcall	.+0      	; 0x3714 <prvSetupTimerInterrupt+0xa>
    3714:	cd b7       	in	r28, 0x3d	; 61
    3716:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3718:	80 e4       	ldi	r24, 0x40	; 64
    371a:	9f e1       	ldi	r25, 0x1F	; 31
    371c:	a0 e0       	ldi	r26, 0x00	; 0
    371e:	b0 e0       	ldi	r27, 0x00	; 0
    3720:	8b 83       	std	Y+3, r24	; 0x03
    3722:	9c 83       	std	Y+4, r25	; 0x04
    3724:	ad 83       	std	Y+5, r26	; 0x05
    3726:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3728:	8b 81       	ldd	r24, Y+3	; 0x03
    372a:	9c 81       	ldd	r25, Y+4	; 0x04
    372c:	ad 81       	ldd	r26, Y+5	; 0x05
    372e:	be 81       	ldd	r27, Y+6	; 0x06
    3730:	68 94       	set
    3732:	15 f8       	bld	r1, 5
    3734:	b6 95       	lsr	r27
    3736:	a7 95       	ror	r26
    3738:	97 95       	ror	r25
    373a:	87 95       	ror	r24
    373c:	16 94       	lsr	r1
    373e:	d1 f7       	brne	.-12     	; 0x3734 <prvSetupTimerInterrupt+0x2a>
    3740:	8b 83       	std	Y+3, r24	; 0x03
    3742:	9c 83       	std	Y+4, r25	; 0x04
    3744:	ad 83       	std	Y+5, r26	; 0x05
    3746:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    3748:	8b 81       	ldd	r24, Y+3	; 0x03
    374a:	9c 81       	ldd	r25, Y+4	; 0x04
    374c:	ad 81       	ldd	r26, Y+5	; 0x05
    374e:	be 81       	ldd	r27, Y+6	; 0x06
    3750:	01 97       	sbiw	r24, 0x01	; 1
    3752:	a1 09       	sbc	r26, r1
    3754:	b1 09       	sbc	r27, r1
    3756:	8b 83       	std	Y+3, r24	; 0x03
    3758:	9c 83       	std	Y+4, r25	; 0x04
    375a:	ad 83       	std	Y+5, r26	; 0x05
    375c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    375e:	8b 81       	ldd	r24, Y+3	; 0x03
    3760:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3762:	8b 81       	ldd	r24, Y+3	; 0x03
    3764:	9c 81       	ldd	r25, Y+4	; 0x04
    3766:	ad 81       	ldd	r26, Y+5	; 0x05
    3768:	be 81       	ldd	r27, Y+6	; 0x06
    376a:	89 2f       	mov	r24, r25
    376c:	9a 2f       	mov	r25, r26
    376e:	ab 2f       	mov	r26, r27
    3770:	bb 27       	eor	r27, r27
    3772:	8b 83       	std	Y+3, r24	; 0x03
    3774:	9c 83       	std	Y+4, r25	; 0x04
    3776:	ad 83       	std	Y+5, r26	; 0x05
    3778:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    377a:	8b 81       	ldd	r24, Y+3	; 0x03
    377c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    377e:	eb e4       	ldi	r30, 0x4B	; 75
    3780:	f0 e0       	ldi	r31, 0x00	; 0
    3782:	8a 81       	ldd	r24, Y+2	; 0x02
    3784:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3786:	ea e4       	ldi	r30, 0x4A	; 74
    3788:	f0 e0       	ldi	r31, 0x00	; 0
    378a:	89 81       	ldd	r24, Y+1	; 0x01
    378c:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    378e:	8b e0       	ldi	r24, 0x0B	; 11
    3790:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3792:	ee e4       	ldi	r30, 0x4E	; 78
    3794:	f0 e0       	ldi	r31, 0x00	; 0
    3796:	89 81       	ldd	r24, Y+1	; 0x01
    3798:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    379a:	e7 e5       	ldi	r30, 0x57	; 87
    379c:	f0 e0       	ldi	r31, 0x00	; 0
    379e:	80 81       	ld	r24, Z
    37a0:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    37a2:	89 81       	ldd	r24, Y+1	; 0x01
    37a4:	80 61       	ori	r24, 0x10	; 16
    37a6:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    37a8:	e7 e5       	ldi	r30, 0x57	; 87
    37aa:	f0 e0       	ldi	r31, 0x00	; 0
    37ac:	89 81       	ldd	r24, Y+1	; 0x01
    37ae:	80 83       	st	Z, r24
}
    37b0:	26 96       	adiw	r28, 0x06	; 6
    37b2:	0f b6       	in	r0, 0x3f	; 63
    37b4:	f8 94       	cli
    37b6:	de bf       	out	0x3e, r29	; 62
    37b8:	0f be       	out	0x3f, r0	; 63
    37ba:	cd bf       	out	0x3d, r28	; 61
    37bc:	cf 91       	pop	r28
    37be:	df 91       	pop	r29
    37c0:	08 95       	ret

000037c2 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    37c2:	0e 94 28 1b 	call	0x3650	; 0x3650 <vPortYieldFromTick>
		asm volatile ( "reti" );
    37c6:	18 95       	reti

000037c8 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    37c8:	df 93       	push	r29
    37ca:	cf 93       	push	r28
    37cc:	00 d0       	rcall	.+0      	; 0x37ce <xQueueGenericReset+0x6>
    37ce:	00 d0       	rcall	.+0      	; 0x37d0 <xQueueGenericReset+0x8>
    37d0:	00 d0       	rcall	.+0      	; 0x37d2 <xQueueGenericReset+0xa>
    37d2:	cd b7       	in	r28, 0x3d	; 61
    37d4:	de b7       	in	r29, 0x3e	; 62
    37d6:	9d 83       	std	Y+5, r25	; 0x05
    37d8:	8c 83       	std	Y+4, r24	; 0x04
    37da:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    37dc:	81 e0       	ldi	r24, 0x01	; 1
    37de:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    37e0:	8c 81       	ldd	r24, Y+4	; 0x04
    37e2:	9d 81       	ldd	r25, Y+5	; 0x05
    37e4:	9a 83       	std	Y+2, r25	; 0x02
    37e6:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    37e8:	89 81       	ldd	r24, Y+1	; 0x01
    37ea:	9a 81       	ldd	r25, Y+2	; 0x02
    37ec:	00 97       	sbiw	r24, 0x00	; 0
    37ee:	09 f4       	brne	.+2      	; 0x37f2 <xQueueGenericReset+0x2a>
    37f0:	8b c0       	rjmp	.+278    	; 0x3908 <xQueueGenericReset+0x140>
    37f2:	e9 81       	ldd	r30, Y+1	; 0x01
    37f4:	fa 81       	ldd	r31, Y+2	; 0x02
    37f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    37f8:	88 23       	and	r24, r24
    37fa:	09 f4       	brne	.+2      	; 0x37fe <xQueueGenericReset+0x36>
    37fc:	85 c0       	rjmp	.+266    	; 0x3908 <xQueueGenericReset+0x140>
    37fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3800:	fa 81       	ldd	r31, Y+2	; 0x02
    3802:	83 8d       	ldd	r24, Z+27	; 0x1b
    3804:	28 2f       	mov	r18, r24
    3806:	30 e0       	ldi	r19, 0x00	; 0
    3808:	8f ef       	ldi	r24, 0xFF	; 255
    380a:	9f e7       	ldi	r25, 0x7F	; 127
    380c:	b9 01       	movw	r22, r18
    380e:	0e 94 eb 4c 	call	0x99d6	; 0x99d6 <__udivmodhi4>
    3812:	cb 01       	movw	r24, r22
    3814:	9c 01       	movw	r18, r24
    3816:	e9 81       	ldd	r30, Y+1	; 0x01
    3818:	fa 81       	ldd	r31, Y+2	; 0x02
    381a:	84 8d       	ldd	r24, Z+28	; 0x1c
    381c:	88 2f       	mov	r24, r24
    381e:	90 e0       	ldi	r25, 0x00	; 0
    3820:	28 17       	cp	r18, r24
    3822:	39 07       	cpc	r19, r25
    3824:	08 f4       	brcc	.+2      	; 0x3828 <xQueueGenericReset+0x60>
    3826:	70 c0       	rjmp	.+224    	; 0x3908 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    3828:	0f b6       	in	r0, 0x3f	; 63
    382a:	f8 94       	cli
    382c:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    382e:	e9 81       	ldd	r30, Y+1	; 0x01
    3830:	fa 81       	ldd	r31, Y+2	; 0x02
    3832:	40 81       	ld	r20, Z
    3834:	51 81       	ldd	r21, Z+1	; 0x01
    3836:	e9 81       	ldd	r30, Y+1	; 0x01
    3838:	fa 81       	ldd	r31, Y+2	; 0x02
    383a:	83 8d       	ldd	r24, Z+27	; 0x1b
    383c:	28 2f       	mov	r18, r24
    383e:	30 e0       	ldi	r19, 0x00	; 0
    3840:	e9 81       	ldd	r30, Y+1	; 0x01
    3842:	fa 81       	ldd	r31, Y+2	; 0x02
    3844:	84 8d       	ldd	r24, Z+28	; 0x1c
    3846:	88 2f       	mov	r24, r24
    3848:	90 e0       	ldi	r25, 0x00	; 0
    384a:	bc 01       	movw	r22, r24
    384c:	26 9f       	mul	r18, r22
    384e:	c0 01       	movw	r24, r0
    3850:	27 9f       	mul	r18, r23
    3852:	90 0d       	add	r25, r0
    3854:	36 9f       	mul	r19, r22
    3856:	90 0d       	add	r25, r0
    3858:	11 24       	eor	r1, r1
    385a:	84 0f       	add	r24, r20
    385c:	95 1f       	adc	r25, r21
    385e:	e9 81       	ldd	r30, Y+1	; 0x01
    3860:	fa 81       	ldd	r31, Y+2	; 0x02
    3862:	95 83       	std	Z+5, r25	; 0x05
    3864:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3866:	e9 81       	ldd	r30, Y+1	; 0x01
    3868:	fa 81       	ldd	r31, Y+2	; 0x02
    386a:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    386c:	e9 81       	ldd	r30, Y+1	; 0x01
    386e:	fa 81       	ldd	r31, Y+2	; 0x02
    3870:	80 81       	ld	r24, Z
    3872:	91 81       	ldd	r25, Z+1	; 0x01
    3874:	e9 81       	ldd	r30, Y+1	; 0x01
    3876:	fa 81       	ldd	r31, Y+2	; 0x02
    3878:	93 83       	std	Z+3, r25	; 0x03
    387a:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    387c:	e9 81       	ldd	r30, Y+1	; 0x01
    387e:	fa 81       	ldd	r31, Y+2	; 0x02
    3880:	40 81       	ld	r20, Z
    3882:	51 81       	ldd	r21, Z+1	; 0x01
    3884:	e9 81       	ldd	r30, Y+1	; 0x01
    3886:	fa 81       	ldd	r31, Y+2	; 0x02
    3888:	83 8d       	ldd	r24, Z+27	; 0x1b
    388a:	88 2f       	mov	r24, r24
    388c:	90 e0       	ldi	r25, 0x00	; 0
    388e:	9c 01       	movw	r18, r24
    3890:	21 50       	subi	r18, 0x01	; 1
    3892:	30 40       	sbci	r19, 0x00	; 0
    3894:	e9 81       	ldd	r30, Y+1	; 0x01
    3896:	fa 81       	ldd	r31, Y+2	; 0x02
    3898:	84 8d       	ldd	r24, Z+28	; 0x1c
    389a:	88 2f       	mov	r24, r24
    389c:	90 e0       	ldi	r25, 0x00	; 0
    389e:	bc 01       	movw	r22, r24
    38a0:	26 9f       	mul	r18, r22
    38a2:	c0 01       	movw	r24, r0
    38a4:	27 9f       	mul	r18, r23
    38a6:	90 0d       	add	r25, r0
    38a8:	36 9f       	mul	r19, r22
    38aa:	90 0d       	add	r25, r0
    38ac:	11 24       	eor	r1, r1
    38ae:	84 0f       	add	r24, r20
    38b0:	95 1f       	adc	r25, r21
    38b2:	e9 81       	ldd	r30, Y+1	; 0x01
    38b4:	fa 81       	ldd	r31, Y+2	; 0x02
    38b6:	97 83       	std	Z+7, r25	; 0x07
    38b8:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    38ba:	e9 81       	ldd	r30, Y+1	; 0x01
    38bc:	fa 81       	ldd	r31, Y+2	; 0x02
    38be:	8f ef       	ldi	r24, 0xFF	; 255
    38c0:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    38c2:	e9 81       	ldd	r30, Y+1	; 0x01
    38c4:	fa 81       	ldd	r31, Y+2	; 0x02
    38c6:	8f ef       	ldi	r24, 0xFF	; 255
    38c8:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    38ca:	8e 81       	ldd	r24, Y+6	; 0x06
    38cc:	88 23       	and	r24, r24
    38ce:	79 f4       	brne	.+30     	; 0x38ee <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    38d0:	e9 81       	ldd	r30, Y+1	; 0x01
    38d2:	fa 81       	ldd	r31, Y+2	; 0x02
    38d4:	80 85       	ldd	r24, Z+8	; 0x08
    38d6:	88 23       	and	r24, r24
    38d8:	a1 f0       	breq	.+40     	; 0x3902 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    38da:	89 81       	ldd	r24, Y+1	; 0x01
    38dc:	9a 81       	ldd	r25, Y+2	; 0x02
    38de:	08 96       	adiw	r24, 0x08	; 8
    38e0:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    38e4:	88 23       	and	r24, r24
    38e6:	69 f0       	breq	.+26     	; 0x3902 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    38e8:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    38ec:	0a c0       	rjmp	.+20     	; 0x3902 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    38ee:	89 81       	ldd	r24, Y+1	; 0x01
    38f0:	9a 81       	ldd	r25, Y+2	; 0x02
    38f2:	08 96       	adiw	r24, 0x08	; 8
    38f4:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    38f8:	89 81       	ldd	r24, Y+1	; 0x01
    38fa:	9a 81       	ldd	r25, Y+2	; 0x02
    38fc:	41 96       	adiw	r24, 0x11	; 17
    38fe:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    3902:	0f 90       	pop	r0
    3904:	0f be       	out	0x3f, r0	; 63
    3906:	01 c0       	rjmp	.+2      	; 0x390a <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    3908:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    390a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    390c:	26 96       	adiw	r28, 0x06	; 6
    390e:	0f b6       	in	r0, 0x3f	; 63
    3910:	f8 94       	cli
    3912:	de bf       	out	0x3e, r29	; 62
    3914:	0f be       	out	0x3f, r0	; 63
    3916:	cd bf       	out	0x3d, r28	; 61
    3918:	cf 91       	pop	r28
    391a:	df 91       	pop	r29
    391c:	08 95       	ret

0000391e <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    391e:	0f 93       	push	r16
    3920:	1f 93       	push	r17
    3922:	df 93       	push	r29
    3924:	cf 93       	push	r28
    3926:	cd b7       	in	r28, 0x3d	; 61
    3928:	de b7       	in	r29, 0x3e	; 62
    392a:	29 97       	sbiw	r28, 0x09	; 9
    392c:	0f b6       	in	r0, 0x3f	; 63
    392e:	f8 94       	cli
    3930:	de bf       	out	0x3e, r29	; 62
    3932:	0f be       	out	0x3f, r0	; 63
    3934:	cd bf       	out	0x3d, r28	; 61
    3936:	8f 83       	std	Y+7, r24	; 0x07
    3938:	68 87       	std	Y+8, r22	; 0x08
    393a:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    393c:	1e 82       	std	Y+6, r1	; 0x06
    393e:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    3940:	8f 81       	ldd	r24, Y+7	; 0x07
    3942:	88 23       	and	r24, r24
    3944:	09 f4       	brne	.+2      	; 0x3948 <xQueueGenericCreate+0x2a>
    3946:	52 c0       	rjmp	.+164    	; 0x39ec <xQueueGenericCreate+0xce>
    3948:	8f 81       	ldd	r24, Y+7	; 0x07
    394a:	28 2f       	mov	r18, r24
    394c:	30 e0       	ldi	r19, 0x00	; 0
    394e:	8f ef       	ldi	r24, 0xFF	; 255
    3950:	9f e7       	ldi	r25, 0x7F	; 127
    3952:	b9 01       	movw	r22, r18
    3954:	0e 94 eb 4c 	call	0x99d6	; 0x99d6 <__udivmodhi4>
    3958:	cb 01       	movw	r24, r22
    395a:	9c 01       	movw	r18, r24
    395c:	88 85       	ldd	r24, Y+8	; 0x08
    395e:	88 2f       	mov	r24, r24
    3960:	90 e0       	ldi	r25, 0x00	; 0
    3962:	28 17       	cp	r18, r24
    3964:	39 07       	cpc	r19, r25
    3966:	08 f4       	brcc	.+2      	; 0x396a <xQueueGenericCreate+0x4c>
    3968:	41 c0       	rjmp	.+130    	; 0x39ec <xQueueGenericCreate+0xce>
    396a:	8f 81       	ldd	r24, Y+7	; 0x07
    396c:	28 2f       	mov	r18, r24
    396e:	30 e0       	ldi	r19, 0x00	; 0
    3970:	88 85       	ldd	r24, Y+8	; 0x08
    3972:	88 2f       	mov	r24, r24
    3974:	90 e0       	ldi	r25, 0x00	; 0
    3976:	ac 01       	movw	r20, r24
    3978:	24 9f       	mul	r18, r20
    397a:	c0 01       	movw	r24, r0
    397c:	25 9f       	mul	r18, r21
    397e:	90 0d       	add	r25, r0
    3980:	34 9f       	mul	r19, r20
    3982:	90 0d       	add	r25, r0
    3984:	11 24       	eor	r1, r1
    3986:	5f e7       	ldi	r21, 0x7F	; 127
    3988:	81 3e       	cpi	r24, 0xE1	; 225
    398a:	95 07       	cpc	r25, r21
    398c:	78 f5       	brcc	.+94     	; 0x39ec <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    398e:	8f 81       	ldd	r24, Y+7	; 0x07
    3990:	28 2f       	mov	r18, r24
    3992:	30 e0       	ldi	r19, 0x00	; 0
    3994:	88 85       	ldd	r24, Y+8	; 0x08
    3996:	88 2f       	mov	r24, r24
    3998:	90 e0       	ldi	r25, 0x00	; 0
    399a:	ac 01       	movw	r20, r24
    399c:	24 9f       	mul	r18, r20
    399e:	c0 01       	movw	r24, r0
    39a0:	25 9f       	mul	r18, r21
    39a2:	90 0d       	add	r25, r0
    39a4:	34 9f       	mul	r19, r20
    39a6:	90 0d       	add	r25, r0
    39a8:	11 24       	eor	r1, r1
    39aa:	9c 83       	std	Y+4, r25	; 0x04
    39ac:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    39ae:	8b 81       	ldd	r24, Y+3	; 0x03
    39b0:	9c 81       	ldd	r25, Y+4	; 0x04
    39b2:	4f 96       	adiw	r24, 0x1f	; 31
    39b4:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <pvPortMalloc>
    39b8:	9e 83       	std	Y+6, r25	; 0x06
    39ba:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    39bc:	8d 81       	ldd	r24, Y+5	; 0x05
    39be:	9e 81       	ldd	r25, Y+6	; 0x06
    39c0:	00 97       	sbiw	r24, 0x00	; 0
    39c2:	a1 f0       	breq	.+40     	; 0x39ec <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    39c4:	8d 81       	ldd	r24, Y+5	; 0x05
    39c6:	9e 81       	ldd	r25, Y+6	; 0x06
    39c8:	9a 83       	std	Y+2, r25	; 0x02
    39ca:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    39cc:	89 81       	ldd	r24, Y+1	; 0x01
    39ce:	9a 81       	ldd	r25, Y+2	; 0x02
    39d0:	4f 96       	adiw	r24, 0x1f	; 31
    39d2:	9a 83       	std	Y+2, r25	; 0x02
    39d4:	89 83       	std	Y+1, r24	; 0x01
                     * deleted. */
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
                }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    39d6:	29 81       	ldd	r18, Y+1	; 0x01
    39d8:	3a 81       	ldd	r19, Y+2	; 0x02
    39da:	ed 81       	ldd	r30, Y+5	; 0x05
    39dc:	fe 81       	ldd	r31, Y+6	; 0x06
    39de:	8f 81       	ldd	r24, Y+7	; 0x07
    39e0:	68 85       	ldd	r22, Y+8	; 0x08
    39e2:	a9 01       	movw	r20, r18
    39e4:	29 85       	ldd	r18, Y+9	; 0x09
    39e6:	8f 01       	movw	r16, r30
    39e8:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    39ec:	8d 81       	ldd	r24, Y+5	; 0x05
    39ee:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    39f0:	29 96       	adiw	r28, 0x09	; 9
    39f2:	0f b6       	in	r0, 0x3f	; 63
    39f4:	f8 94       	cli
    39f6:	de bf       	out	0x3e, r29	; 62
    39f8:	0f be       	out	0x3f, r0	; 63
    39fa:	cd bf       	out	0x3d, r28	; 61
    39fc:	cf 91       	pop	r28
    39fe:	df 91       	pop	r29
    3a00:	1f 91       	pop	r17
    3a02:	0f 91       	pop	r16
    3a04:	08 95       	ret

00003a06 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    3a06:	0f 93       	push	r16
    3a08:	1f 93       	push	r17
    3a0a:	df 93       	push	r29
    3a0c:	cf 93       	push	r28
    3a0e:	cd b7       	in	r28, 0x3d	; 61
    3a10:	de b7       	in	r29, 0x3e	; 62
    3a12:	27 97       	sbiw	r28, 0x07	; 7
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	f8 94       	cli
    3a18:	de bf       	out	0x3e, r29	; 62
    3a1a:	0f be       	out	0x3f, r0	; 63
    3a1c:	cd bf       	out	0x3d, r28	; 61
    3a1e:	89 83       	std	Y+1, r24	; 0x01
    3a20:	6a 83       	std	Y+2, r22	; 0x02
    3a22:	5c 83       	std	Y+4, r21	; 0x04
    3a24:	4b 83       	std	Y+3, r20	; 0x03
    3a26:	2d 83       	std	Y+5, r18	; 0x05
    3a28:	1f 83       	std	Y+7, r17	; 0x07
    3a2a:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    3a2c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a2e:	88 23       	and	r24, r24
    3a30:	39 f4       	brne	.+14     	; 0x3a40 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3a32:	8e 81       	ldd	r24, Y+6	; 0x06
    3a34:	9f 81       	ldd	r25, Y+7	; 0x07
    3a36:	ee 81       	ldd	r30, Y+6	; 0x06
    3a38:	ff 81       	ldd	r31, Y+7	; 0x07
    3a3a:	91 83       	std	Z+1, r25	; 0x01
    3a3c:	80 83       	st	Z, r24
    3a3e:	06 c0       	rjmp	.+12     	; 0x3a4c <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3a40:	8b 81       	ldd	r24, Y+3	; 0x03
    3a42:	9c 81       	ldd	r25, Y+4	; 0x04
    3a44:	ee 81       	ldd	r30, Y+6	; 0x06
    3a46:	ff 81       	ldd	r31, Y+7	; 0x07
    3a48:	91 83       	std	Z+1, r25	; 0x01
    3a4a:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    3a4c:	ee 81       	ldd	r30, Y+6	; 0x06
    3a4e:	ff 81       	ldd	r31, Y+7	; 0x07
    3a50:	89 81       	ldd	r24, Y+1	; 0x01
    3a52:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    3a54:	ee 81       	ldd	r30, Y+6	; 0x06
    3a56:	ff 81       	ldd	r31, Y+7	; 0x07
    3a58:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5a:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3a5c:	8e 81       	ldd	r24, Y+6	; 0x06
    3a5e:	9f 81       	ldd	r25, Y+7	; 0x07
    3a60:	61 e0       	ldi	r22, 0x01	; 1
    3a62:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
    }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    3a66:	27 96       	adiw	r28, 0x07	; 7
    3a68:	0f b6       	in	r0, 0x3f	; 63
    3a6a:	f8 94       	cli
    3a6c:	de bf       	out	0x3e, r29	; 62
    3a6e:	0f be       	out	0x3f, r0	; 63
    3a70:	cd bf       	out	0x3d, r28	; 61
    3a72:	cf 91       	pop	r28
    3a74:	df 91       	pop	r29
    3a76:	1f 91       	pop	r17
    3a78:	0f 91       	pop	r16
    3a7a:	08 95       	ret

00003a7c <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static void prvInitialiseMutex( Queue_t * pxNewQueue )
    {
    3a7c:	df 93       	push	r29
    3a7e:	cf 93       	push	r28
    3a80:	00 d0       	rcall	.+0      	; 0x3a82 <prvInitialiseMutex+0x6>
    3a82:	cd b7       	in	r28, 0x3d	; 61
    3a84:	de b7       	in	r29, 0x3e	; 62
    3a86:	9a 83       	std	Y+2, r25	; 0x02
    3a88:	89 83       	std	Y+1, r24	; 0x01
        if( pxNewQueue != NULL )
    3a8a:	89 81       	ldd	r24, Y+1	; 0x01
    3a8c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a8e:	00 97       	sbiw	r24, 0x00	; 0
    3a90:	a1 f0       	breq	.+40     	; 0x3aba <prvInitialiseMutex+0x3e>
        {
            /* The queue create function will set all the queue structure members
            * correctly for a generic queue, but this function is creating a
            * mutex.  Overwrite those members that need to be set differently -
            * in particular the information required for priority inheritance. */
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    3a92:	e9 81       	ldd	r30, Y+1	; 0x01
    3a94:	fa 81       	ldd	r31, Y+2	; 0x02
    3a96:	15 82       	std	Z+5, r1	; 0x05
    3a98:	14 82       	std	Z+4, r1	; 0x04
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    3a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a9e:	11 82       	std	Z+1, r1	; 0x01
    3aa0:	10 82       	st	Z, r1

            /* In case this is a recursive mutex. */
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    3aa2:	e9 81       	ldd	r30, Y+1	; 0x01
    3aa4:	fa 81       	ldd	r31, Y+2	; 0x02
    3aa6:	16 82       	std	Z+6, r1	; 0x06

            traceCREATE_MUTEX( pxNewQueue );

            /* Start with the semaphore in the expected state. */
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    3aa8:	89 81       	ldd	r24, Y+1	; 0x01
    3aaa:	9a 81       	ldd	r25, Y+2	; 0x02
    3aac:	60 e0       	ldi	r22, 0x00	; 0
    3aae:	70 e0       	ldi	r23, 0x00	; 0
    3ab0:	40 e0       	ldi	r20, 0x00	; 0
    3ab2:	50 e0       	ldi	r21, 0x00	; 0
    3ab4:	20 e0       	ldi	r18, 0x00	; 0
    3ab6:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <xQueueGenericSend>
        }
        else
        {
            traceCREATE_MUTEX_FAILED();
        }
    }
    3aba:	0f 90       	pop	r0
    3abc:	0f 90       	pop	r0
    3abe:	cf 91       	pop	r28
    3ac0:	df 91       	pop	r29
    3ac2:	08 95       	ret

00003ac4 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    {
    3ac4:	df 93       	push	r29
    3ac6:	cf 93       	push	r28
    3ac8:	00 d0       	rcall	.+0      	; 0x3aca <xQueueCreateMutex+0x6>
    3aca:	00 d0       	rcall	.+0      	; 0x3acc <xQueueCreateMutex+0x8>
    3acc:	0f 92       	push	r0
    3ace:	cd b7       	in	r28, 0x3d	; 61
    3ad0:	de b7       	in	r29, 0x3e	; 62
    3ad2:	8d 83       	std	Y+5, r24	; 0x05
        QueueHandle_t xNewQueue;
        const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    3ad4:	81 e0       	ldi	r24, 0x01	; 1
    3ad6:	8a 83       	std	Y+2, r24	; 0x02
    3ad8:	19 82       	std	Y+1, r1	; 0x01

        xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    3ada:	8a 81       	ldd	r24, Y+2	; 0x02
    3adc:	69 81       	ldd	r22, Y+1	; 0x01
    3ade:	4d 81       	ldd	r20, Y+5	; 0x05
    3ae0:	0e 94 8f 1c 	call	0x391e	; 0x391e <xQueueGenericCreate>
    3ae4:	9c 83       	std	Y+4, r25	; 0x04
    3ae6:	8b 83       	std	Y+3, r24	; 0x03
        prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    3ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    3aea:	9c 81       	ldd	r25, Y+4	; 0x04
    3aec:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <prvInitialiseMutex>

        return xNewQueue;
    3af0:	8b 81       	ldd	r24, Y+3	; 0x03
    3af2:	9c 81       	ldd	r25, Y+4	; 0x04
    }
    3af4:	0f 90       	pop	r0
    3af6:	0f 90       	pop	r0
    3af8:	0f 90       	pop	r0
    3afa:	0f 90       	pop	r0
    3afc:	0f 90       	pop	r0
    3afe:	cf 91       	pop	r28
    3b00:	df 91       	pop	r29
    3b02:	08 95       	ret

00003b04 <xQueueCreateCountingSemaphore>:

#if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
                                                 const UBaseType_t uxInitialCount )
    {
    3b04:	df 93       	push	r29
    3b06:	cf 93       	push	r28
    3b08:	00 d0       	rcall	.+0      	; 0x3b0a <xQueueCreateCountingSemaphore+0x6>
    3b0a:	00 d0       	rcall	.+0      	; 0x3b0c <xQueueCreateCountingSemaphore+0x8>
    3b0c:	cd b7       	in	r28, 0x3d	; 61
    3b0e:	de b7       	in	r29, 0x3e	; 62
    3b10:	8b 83       	std	Y+3, r24	; 0x03
    3b12:	6c 83       	std	Y+4, r22	; 0x04
        QueueHandle_t xHandle = NULL;
    3b14:	1a 82       	std	Y+2, r1	; 0x02
    3b16:	19 82       	std	Y+1, r1	; 0x01

        if( ( uxMaxCount != 0 ) &&
    3b18:	8b 81       	ldd	r24, Y+3	; 0x03
    3b1a:	88 23       	and	r24, r24
    3b1c:	99 f0       	breq	.+38     	; 0x3b44 <xQueueCreateCountingSemaphore+0x40>
    3b1e:	9c 81       	ldd	r25, Y+4	; 0x04
    3b20:	8b 81       	ldd	r24, Y+3	; 0x03
    3b22:	89 17       	cp	r24, r25
    3b24:	78 f0       	brcs	.+30     	; 0x3b44 <xQueueCreateCountingSemaphore+0x40>
            ( uxInitialCount <= uxMaxCount ) )
        {
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    3b26:	8b 81       	ldd	r24, Y+3	; 0x03
    3b28:	60 e0       	ldi	r22, 0x00	; 0
    3b2a:	42 e0       	ldi	r20, 0x02	; 2
    3b2c:	0e 94 8f 1c 	call	0x391e	; 0x391e <xQueueGenericCreate>
    3b30:	9a 83       	std	Y+2, r25	; 0x02
    3b32:	89 83       	std	Y+1, r24	; 0x01

            if( xHandle != NULL )
    3b34:	89 81       	ldd	r24, Y+1	; 0x01
    3b36:	9a 81       	ldd	r25, Y+2	; 0x02
    3b38:	00 97       	sbiw	r24, 0x00	; 0
    3b3a:	21 f0       	breq	.+8      	; 0x3b44 <xQueueCreateCountingSemaphore+0x40>
            {
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    3b3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b40:	8c 81       	ldd	r24, Y+4	; 0x04
    3b42:	82 8f       	std	Z+26, r24	; 0x1a
        {
            configASSERT( xHandle );
            mtCOVERAGE_TEST_MARKER();
        }

        return xHandle;
    3b44:	89 81       	ldd	r24, Y+1	; 0x01
    3b46:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    3b48:	0f 90       	pop	r0
    3b4a:	0f 90       	pop	r0
    3b4c:	0f 90       	pop	r0
    3b4e:	0f 90       	pop	r0
    3b50:	cf 91       	pop	r28
    3b52:	df 91       	pop	r29
    3b54:	08 95       	ret

00003b56 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    3b56:	df 93       	push	r29
    3b58:	cf 93       	push	r28
    3b5a:	cd b7       	in	r28, 0x3d	; 61
    3b5c:	de b7       	in	r29, 0x3e	; 62
    3b5e:	2f 97       	sbiw	r28, 0x0f	; 15
    3b60:	0f b6       	in	r0, 0x3f	; 63
    3b62:	f8 94       	cli
    3b64:	de bf       	out	0x3e, r29	; 62
    3b66:	0f be       	out	0x3f, r0	; 63
    3b68:	cd bf       	out	0x3d, r28	; 61
    3b6a:	99 87       	std	Y+9, r25	; 0x09
    3b6c:	88 87       	std	Y+8, r24	; 0x08
    3b6e:	7b 87       	std	Y+11, r23	; 0x0b
    3b70:	6a 87       	std	Y+10, r22	; 0x0a
    3b72:	5d 87       	std	Y+13, r21	; 0x0d
    3b74:	4c 87       	std	Y+12, r20	; 0x0c
    3b76:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3b78:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    3b7a:	88 85       	ldd	r24, Y+8	; 0x08
    3b7c:	99 85       	ldd	r25, Y+9	; 0x09
    3b7e:	9a 83       	std	Y+2, r25	; 0x02
    3b80:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3b82:	0f b6       	in	r0, 0x3f	; 63
    3b84:	f8 94       	cli
    3b86:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3b88:	e9 81       	ldd	r30, Y+1	; 0x01
    3b8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3b8c:	92 8d       	ldd	r25, Z+26	; 0x1a
    3b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3b90:	fa 81       	ldd	r31, Y+2	; 0x02
    3b92:	83 8d       	ldd	r24, Z+27	; 0x1b
    3b94:	98 17       	cp	r25, r24
    3b96:	18 f0       	brcs	.+6      	; 0x3b9e <xQueueGenericSend+0x48>
    3b98:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b9a:	82 30       	cpi	r24, 0x02	; 2
    3b9c:	11 f5       	brne	.+68     	; 0x3be2 <xQueueGenericSend+0x8c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3b9e:	89 81       	ldd	r24, Y+1	; 0x01
    3ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ba2:	2a 85       	ldd	r18, Y+10	; 0x0a
    3ba4:	3b 85       	ldd	r19, Y+11	; 0x0b
    3ba6:	b9 01       	movw	r22, r18
    3ba8:	4e 85       	ldd	r20, Y+14	; 0x0e
    3baa:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <prvCopyDataToQueue>
    3bae:	8b 83       	std	Y+3, r24	; 0x03

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3bb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3bb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3bb4:	81 89       	ldd	r24, Z+17	; 0x11
    3bb6:	88 23       	and	r24, r24
    3bb8:	51 f0       	breq	.+20     	; 0x3bce <xQueueGenericSend+0x78>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3bba:	89 81       	ldd	r24, Y+1	; 0x01
    3bbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3bbe:	41 96       	adiw	r24, 0x11	; 17
    3bc0:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    3bc4:	88 23       	and	r24, r24
    3bc6:	41 f0       	breq	.+16     	; 0x3bd8 <xQueueGenericSend+0x82>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    3bc8:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    3bcc:	05 c0       	rjmp	.+10     	; 0x3bd8 <xQueueGenericSend+0x82>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    3bce:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd0:	88 23       	and	r24, r24
    3bd2:	11 f0       	breq	.+4      	; 0x3bd8 <xQueueGenericSend+0x82>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    3bd4:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    3bd8:	0f 90       	pop	r0
    3bda:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3bdc:	81 e0       	ldi	r24, 0x01	; 1
    3bde:	8f 87       	std	Y+15, r24	; 0x0f
    3be0:	5c c0       	rjmp	.+184    	; 0x3c9a <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3be2:	8c 85       	ldd	r24, Y+12	; 0x0c
    3be4:	9d 85       	ldd	r25, Y+13	; 0x0d
    3be6:	00 97       	sbiw	r24, 0x00	; 0
    3be8:	21 f4       	brne	.+8      	; 0x3bf2 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3bea:	0f 90       	pop	r0
    3bec:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    3bee:	1f 86       	std	Y+15, r1	; 0x0f
    3bf0:	54 c0       	rjmp	.+168    	; 0x3c9a <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    3bf2:	8c 81       	ldd	r24, Y+4	; 0x04
    3bf4:	88 23       	and	r24, r24
    3bf6:	31 f4       	brne	.+12     	; 0x3c04 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3bf8:	ce 01       	movw	r24, r28
    3bfa:	05 96       	adiw	r24, 0x05	; 5
    3bfc:	0e 94 6d 38 	call	0x70da	; 0x70da <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3c00:	81 e0       	ldi	r24, 0x01	; 1
    3c02:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3c04:	0f 90       	pop	r0
    3c06:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3c08:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3c0c:	0f b6       	in	r0, 0x3f	; 63
    3c0e:	f8 94       	cli
    3c10:	0f 92       	push	r0
    3c12:	e9 81       	ldd	r30, Y+1	; 0x01
    3c14:	fa 81       	ldd	r31, Y+2	; 0x02
    3c16:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c18:	8f 3f       	cpi	r24, 0xFF	; 255
    3c1a:	19 f4       	brne	.+6      	; 0x3c22 <xQueueGenericSend+0xcc>
    3c1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c20:	15 8e       	std	Z+29, r1	; 0x1d
    3c22:	e9 81       	ldd	r30, Y+1	; 0x01
    3c24:	fa 81       	ldd	r31, Y+2	; 0x02
    3c26:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c28:	8f 3f       	cpi	r24, 0xFF	; 255
    3c2a:	19 f4       	brne	.+6      	; 0x3c32 <xQueueGenericSend+0xdc>
    3c2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3c2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3c30:	16 8e       	std	Z+30, r1	; 0x1e
    3c32:	0f 90       	pop	r0
    3c34:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3c36:	ce 01       	movw	r24, r28
    3c38:	05 96       	adiw	r24, 0x05	; 5
    3c3a:	9e 01       	movw	r18, r28
    3c3c:	24 5f       	subi	r18, 0xF4	; 244
    3c3e:	3f 4f       	sbci	r19, 0xFF	; 255
    3c40:	b9 01       	movw	r22, r18
    3c42:	0e 94 86 38 	call	0x710c	; 0x710c <xTaskCheckForTimeOut>
    3c46:	88 23       	and	r24, r24
    3c48:	09 f5       	brne	.+66     	; 0x3c8c <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3c4a:	89 81       	ldd	r24, Y+1	; 0x01
    3c4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c4e:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <prvIsQueueFull>
    3c52:	88 23       	and	r24, r24
    3c54:	a1 f0       	breq	.+40     	; 0x3c7e <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3c56:	89 81       	ldd	r24, Y+1	; 0x01
    3c58:	9a 81       	ldd	r25, Y+2	; 0x02
    3c5a:	08 96       	adiw	r24, 0x08	; 8
    3c5c:	2c 85       	ldd	r18, Y+12	; 0x0c
    3c5e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3c60:	b9 01       	movw	r22, r18
    3c62:	0e 94 76 35 	call	0x6aec	; 0x6aec <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    3c66:	89 81       	ldd	r24, Y+1	; 0x01
    3c68:	9a 81       	ldd	r25, Y+2	; 0x02
    3c6a:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    3c6e:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    3c72:	88 23       	and	r24, r24
    3c74:	09 f0       	breq	.+2      	; 0x3c78 <xQueueGenericSend+0x122>
    3c76:	85 cf       	rjmp	.-246    	; 0x3b82 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    3c78:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    3c7c:	82 cf       	rjmp	.-252    	; 0x3b82 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    3c7e:	89 81       	ldd	r24, Y+1	; 0x01
    3c80:	9a 81       	ldd	r25, Y+2	; 0x02
    3c82:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3c86:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    3c8a:	7b cf       	rjmp	.-266    	; 0x3b82 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    3c8c:	89 81       	ldd	r24, Y+1	; 0x01
    3c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c90:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3c94:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    3c98:	1f 86       	std	Y+15, r1	; 0x0f
    3c9a:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    3c9c:	2f 96       	adiw	r28, 0x0f	; 15
    3c9e:	0f b6       	in	r0, 0x3f	; 63
    3ca0:	f8 94       	cli
    3ca2:	de bf       	out	0x3e, r29	; 62
    3ca4:	0f be       	out	0x3f, r0	; 63
    3ca6:	cd bf       	out	0x3d, r28	; 61
    3ca8:	cf 91       	pop	r28
    3caa:	df 91       	pop	r29
    3cac:	08 95       	ret

00003cae <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    3cae:	df 93       	push	r29
    3cb0:	cf 93       	push	r28
    3cb2:	cd b7       	in	r28, 0x3d	; 61
    3cb4:	de b7       	in	r29, 0x3e	; 62
    3cb6:	2e 97       	sbiw	r28, 0x0e	; 14
    3cb8:	0f b6       	in	r0, 0x3f	; 63
    3cba:	f8 94       	cli
    3cbc:	de bf       	out	0x3e, r29	; 62
    3cbe:	0f be       	out	0x3f, r0	; 63
    3cc0:	cd bf       	out	0x3d, r28	; 61
    3cc2:	99 87       	std	Y+9, r25	; 0x09
    3cc4:	88 87       	std	Y+8, r24	; 0x08
    3cc6:	7b 87       	std	Y+11, r23	; 0x0b
    3cc8:	6a 87       	std	Y+10, r22	; 0x0a
    3cca:	5d 87       	std	Y+13, r21	; 0x0d
    3ccc:	4c 87       	std	Y+12, r20	; 0x0c
    3cce:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3cd0:	88 85       	ldd	r24, Y+8	; 0x08
    3cd2:	99 85       	ldd	r25, Y+9	; 0x09
    3cd4:	9d 83       	std	Y+5, r25	; 0x05
    3cd6:	8c 83       	std	Y+4, r24	; 0x04
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3cd8:	1e 82       	std	Y+6, r1	; 0x06
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3cda:	ec 81       	ldd	r30, Y+4	; 0x04
    3cdc:	fd 81       	ldd	r31, Y+5	; 0x05
    3cde:	92 8d       	ldd	r25, Z+26	; 0x1a
    3ce0:	ec 81       	ldd	r30, Y+4	; 0x04
    3ce2:	fd 81       	ldd	r31, Y+5	; 0x05
    3ce4:	83 8d       	ldd	r24, Z+27	; 0x1b
    3ce6:	98 17       	cp	r25, r24
    3ce8:	18 f0       	brcs	.+6      	; 0x3cf0 <xQueueGenericSendFromISR+0x42>
    3cea:	8e 85       	ldd	r24, Y+14	; 0x0e
    3cec:	82 30       	cpi	r24, 0x02	; 2
    3cee:	b9 f5       	brne	.+110    	; 0x3d5e <xQueueGenericSendFromISR+0xb0>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    3cf0:	ec 81       	ldd	r30, Y+4	; 0x04
    3cf2:	fd 81       	ldd	r31, Y+5	; 0x05
    3cf4:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cf6:	8b 83       	std	Y+3, r24	; 0x03
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    3cf8:	ec 81       	ldd	r30, Y+4	; 0x04
    3cfa:	fd 81       	ldd	r31, Y+5	; 0x05
    3cfc:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cfe:	8a 83       	std	Y+2, r24	; 0x02
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3d00:	8c 81       	ldd	r24, Y+4	; 0x04
    3d02:	9d 81       	ldd	r25, Y+5	; 0x05
    3d04:	2a 85       	ldd	r18, Y+10	; 0x0a
    3d06:	3b 85       	ldd	r19, Y+11	; 0x0b
    3d08:	b9 01       	movw	r22, r18
    3d0a:	4e 85       	ldd	r20, Y+14	; 0x0e
    3d0c:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    3d10:	8b 81       	ldd	r24, Y+3	; 0x03
    3d12:	8f 3f       	cpi	r24, 0xFF	; 255
    3d14:	a9 f4       	brne	.+42     	; 0x3d40 <xQueueGenericSendFromISR+0x92>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3d16:	ec 81       	ldd	r30, Y+4	; 0x04
    3d18:	fd 81       	ldd	r31, Y+5	; 0x05
    3d1a:	81 89       	ldd	r24, Z+17	; 0x11
    3d1c:	88 23       	and	r24, r24
    3d1e:	e1 f0       	breq	.+56     	; 0x3d58 <xQueueGenericSendFromISR+0xaa>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3d20:	8c 81       	ldd	r24, Y+4	; 0x04
    3d22:	9d 81       	ldd	r25, Y+5	; 0x05
    3d24:	41 96       	adiw	r24, 0x11	; 17
    3d26:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    3d2a:	88 23       	and	r24, r24
    3d2c:	a9 f0       	breq	.+42     	; 0x3d58 <xQueueGenericSendFromISR+0xaa>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    3d2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d30:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d32:	00 97       	sbiw	r24, 0x00	; 0
    3d34:	89 f0       	breq	.+34     	; 0x3d58 <xQueueGenericSendFromISR+0xaa>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    3d36:	ec 85       	ldd	r30, Y+12	; 0x0c
    3d38:	fd 85       	ldd	r31, Y+13	; 0x0d
    3d3a:	81 e0       	ldi	r24, 0x01	; 1
    3d3c:	80 83       	st	Z, r24
    3d3e:	0c c0       	rjmp	.+24     	; 0x3d58 <xQueueGenericSendFromISR+0xaa>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    3d40:	0e 94 1c 33 	call	0x6638	; 0x6638 <uxTaskGetNumberOfTasks>
    3d44:	89 83       	std	Y+1, r24	; 0x01
    3d46:	9b 81       	ldd	r25, Y+3	; 0x03
    3d48:	89 81       	ldd	r24, Y+1	; 0x01
    3d4a:	98 17       	cp	r25, r24
    3d4c:	28 f4       	brcc	.+10     	; 0x3d58 <xQueueGenericSendFromISR+0xaa>
    3d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d50:	8f 5f       	subi	r24, 0xFF	; 255
    3d52:	ec 81       	ldd	r30, Y+4	; 0x04
    3d54:	fd 81       	ldd	r31, Y+5	; 0x05
    3d56:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    3d58:	81 e0       	ldi	r24, 0x01	; 1
    3d5a:	8f 83       	std	Y+7, r24	; 0x07
    3d5c:	01 c0       	rjmp	.+2      	; 0x3d60 <xQueueGenericSendFromISR+0xb2>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    3d5e:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3d60:	8f 81       	ldd	r24, Y+7	; 0x07
}
    3d62:	2e 96       	adiw	r28, 0x0e	; 14
    3d64:	0f b6       	in	r0, 0x3f	; 63
    3d66:	f8 94       	cli
    3d68:	de bf       	out	0x3e, r29	; 62
    3d6a:	0f be       	out	0x3f, r0	; 63
    3d6c:	cd bf       	out	0x3d, r28	; 61
    3d6e:	cf 91       	pop	r28
    3d70:	df 91       	pop	r29
    3d72:	08 95       	ret

00003d74 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    3d74:	df 93       	push	r29
    3d76:	cf 93       	push	r28
    3d78:	cd b7       	in	r28, 0x3d	; 61
    3d7a:	de b7       	in	r29, 0x3e	; 62
    3d7c:	2b 97       	sbiw	r28, 0x0b	; 11
    3d7e:	0f b6       	in	r0, 0x3f	; 63
    3d80:	f8 94       	cli
    3d82:	de bf       	out	0x3e, r29	; 62
    3d84:	0f be       	out	0x3f, r0	; 63
    3d86:	cd bf       	out	0x3d, r28	; 61
    3d88:	99 87       	std	Y+9, r25	; 0x09
    3d8a:	88 87       	std	Y+8, r24	; 0x08
    3d8c:	7b 87       	std	Y+11, r23	; 0x0b
    3d8e:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    3d90:	88 85       	ldd	r24, Y+8	; 0x08
    3d92:	99 85       	ldd	r25, Y+9	; 0x09
    3d94:	9d 83       	std	Y+5, r25	; 0x05
    3d96:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3d98:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3d9a:	ec 81       	ldd	r30, Y+4	; 0x04
    3d9c:	fd 81       	ldd	r31, Y+5	; 0x05
    3d9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3da0:	8b 83       	std	Y+3, r24	; 0x03

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    3da2:	ec 81       	ldd	r30, Y+4	; 0x04
    3da4:	fd 81       	ldd	r31, Y+5	; 0x05
    3da6:	93 8d       	ldd	r25, Z+27	; 0x1b
    3da8:	8b 81       	ldd	r24, Y+3	; 0x03
    3daa:	89 17       	cp	r24, r25
    3dac:	80 f5       	brcc	.+96     	; 0x3e0e <xQueueGiveFromISR+0x9a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    3dae:	ec 81       	ldd	r30, Y+4	; 0x04
    3db0:	fd 81       	ldd	r31, Y+5	; 0x05
    3db2:	86 8d       	ldd	r24, Z+30	; 0x1e
    3db4:	8a 83       	std	Y+2, r24	; 0x02
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3db6:	8b 81       	ldd	r24, Y+3	; 0x03
    3db8:	8f 5f       	subi	r24, 0xFF	; 255
    3dba:	ec 81       	ldd	r30, Y+4	; 0x04
    3dbc:	fd 81       	ldd	r31, Y+5	; 0x05
    3dbe:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    3dc0:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc2:	8f 3f       	cpi	r24, 0xFF	; 255
    3dc4:	a9 f4       	brne	.+42     	; 0x3df0 <xQueueGiveFromISR+0x7c>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3dc6:	ec 81       	ldd	r30, Y+4	; 0x04
    3dc8:	fd 81       	ldd	r31, Y+5	; 0x05
    3dca:	81 89       	ldd	r24, Z+17	; 0x11
    3dcc:	88 23       	and	r24, r24
    3dce:	e1 f0       	breq	.+56     	; 0x3e08 <xQueueGiveFromISR+0x94>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3dd0:	8c 81       	ldd	r24, Y+4	; 0x04
    3dd2:	9d 81       	ldd	r25, Y+5	; 0x05
    3dd4:	41 96       	adiw	r24, 0x11	; 17
    3dd6:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    3dda:	88 23       	and	r24, r24
    3ddc:	a9 f0       	breq	.+42     	; 0x3e08 <xQueueGiveFromISR+0x94>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    3dde:	8a 85       	ldd	r24, Y+10	; 0x0a
    3de0:	9b 85       	ldd	r25, Y+11	; 0x0b
    3de2:	00 97       	sbiw	r24, 0x00	; 0
    3de4:	89 f0       	breq	.+34     	; 0x3e08 <xQueueGiveFromISR+0x94>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    3de6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3de8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dea:	81 e0       	ldi	r24, 0x01	; 1
    3dec:	80 83       	st	Z, r24
    3dee:	0c c0       	rjmp	.+24     	; 0x3e08 <xQueueGiveFromISR+0x94>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    3df0:	0e 94 1c 33 	call	0x6638	; 0x6638 <uxTaskGetNumberOfTasks>
    3df4:	89 83       	std	Y+1, r24	; 0x01
    3df6:	9a 81       	ldd	r25, Y+2	; 0x02
    3df8:	89 81       	ldd	r24, Y+1	; 0x01
    3dfa:	98 17       	cp	r25, r24
    3dfc:	28 f4       	brcc	.+10     	; 0x3e08 <xQueueGiveFromISR+0x94>
    3dfe:	8a 81       	ldd	r24, Y+2	; 0x02
    3e00:	8f 5f       	subi	r24, 0xFF	; 255
    3e02:	ec 81       	ldd	r30, Y+4	; 0x04
    3e04:	fd 81       	ldd	r31, Y+5	; 0x05
    3e06:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    3e08:	81 e0       	ldi	r24, 0x01	; 1
    3e0a:	8f 83       	std	Y+7, r24	; 0x07
    3e0c:	01 c0       	rjmp	.+2      	; 0x3e10 <xQueueGiveFromISR+0x9c>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    3e0e:	1f 82       	std	Y+7, r1	; 0x07
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3e10:	8f 81       	ldd	r24, Y+7	; 0x07
}
    3e12:	2b 96       	adiw	r28, 0x0b	; 11
    3e14:	0f b6       	in	r0, 0x3f	; 63
    3e16:	f8 94       	cli
    3e18:	de bf       	out	0x3e, r29	; 62
    3e1a:	0f be       	out	0x3f, r0	; 63
    3e1c:	cd bf       	out	0x3d, r28	; 61
    3e1e:	cf 91       	pop	r28
    3e20:	df 91       	pop	r29
    3e22:	08 95       	ret

00003e24 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    3e24:	df 93       	push	r29
    3e26:	cf 93       	push	r28
    3e28:	cd b7       	in	r28, 0x3d	; 61
    3e2a:	de b7       	in	r29, 0x3e	; 62
    3e2c:	2e 97       	sbiw	r28, 0x0e	; 14
    3e2e:	0f b6       	in	r0, 0x3f	; 63
    3e30:	f8 94       	cli
    3e32:	de bf       	out	0x3e, r29	; 62
    3e34:	0f be       	out	0x3f, r0	; 63
    3e36:	cd bf       	out	0x3d, r28	; 61
    3e38:	99 87       	std	Y+9, r25	; 0x09
    3e3a:	88 87       	std	Y+8, r24	; 0x08
    3e3c:	7b 87       	std	Y+11, r23	; 0x0b
    3e3e:	6a 87       	std	Y+10, r22	; 0x0a
    3e40:	5d 87       	std	Y+13, r21	; 0x0d
    3e42:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    3e44:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    3e46:	88 85       	ldd	r24, Y+8	; 0x08
    3e48:	99 85       	ldd	r25, Y+9	; 0x09
    3e4a:	9b 83       	std	Y+3, r25	; 0x03
    3e4c:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3e4e:	0f b6       	in	r0, 0x3f	; 63
    3e50:	f8 94       	cli
    3e52:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3e54:	ea 81       	ldd	r30, Y+2	; 0x02
    3e56:	fb 81       	ldd	r31, Y+3	; 0x03
    3e58:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e5a:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3e5c:	89 81       	ldd	r24, Y+1	; 0x01
    3e5e:	88 23       	and	r24, r24
    3e60:	f9 f0       	breq	.+62     	; 0x3ea0 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3e62:	8a 81       	ldd	r24, Y+2	; 0x02
    3e64:	9b 81       	ldd	r25, Y+3	; 0x03
    3e66:	2a 85       	ldd	r18, Y+10	; 0x0a
    3e68:	3b 85       	ldd	r19, Y+11	; 0x0b
    3e6a:	b9 01       	movw	r22, r18
    3e6c:	0e 94 22 23 	call	0x4644	; 0x4644 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	81 50       	subi	r24, 0x01	; 1
    3e74:	ea 81       	ldd	r30, Y+2	; 0x02
    3e76:	fb 81       	ldd	r31, Y+3	; 0x03
    3e78:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e7a:	ea 81       	ldd	r30, Y+2	; 0x02
    3e7c:	fb 81       	ldd	r31, Y+3	; 0x03
    3e7e:	80 85       	ldd	r24, Z+8	; 0x08
    3e80:	88 23       	and	r24, r24
    3e82:	49 f0       	breq	.+18     	; 0x3e96 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e84:	8a 81       	ldd	r24, Y+2	; 0x02
    3e86:	9b 81       	ldd	r25, Y+3	; 0x03
    3e88:	08 96       	adiw	r24, 0x08	; 8
    3e8a:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    3e8e:	88 23       	and	r24, r24
    3e90:	11 f0       	breq	.+4      	; 0x3e96 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3e92:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3e96:	0f 90       	pop	r0
    3e98:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3e9a:	81 e0       	ldi	r24, 0x01	; 1
    3e9c:	8e 87       	std	Y+14, r24	; 0x0e
    3e9e:	63 c0       	rjmp	.+198    	; 0x3f66 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3ea0:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ea2:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ea4:	00 97       	sbiw	r24, 0x00	; 0
    3ea6:	21 f4       	brne	.+8      	; 0x3eb0 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3ea8:	0f 90       	pop	r0
    3eaa:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    3eac:	1e 86       	std	Y+14, r1	; 0x0e
    3eae:	5b c0       	rjmp	.+182    	; 0x3f66 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    3eb0:	8c 81       	ldd	r24, Y+4	; 0x04
    3eb2:	88 23       	and	r24, r24
    3eb4:	31 f4       	brne	.+12     	; 0x3ec2 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3eb6:	ce 01       	movw	r24, r28
    3eb8:	05 96       	adiw	r24, 0x05	; 5
    3eba:	0e 94 6d 38 	call	0x70da	; 0x70da <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    3ebe:	81 e0       	ldi	r24, 0x01	; 1
    3ec0:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3ec2:	0f 90       	pop	r0
    3ec4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3ec6:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3eca:	0f b6       	in	r0, 0x3f	; 63
    3ecc:	f8 94       	cli
    3ece:	0f 92       	push	r0
    3ed0:	ea 81       	ldd	r30, Y+2	; 0x02
    3ed2:	fb 81       	ldd	r31, Y+3	; 0x03
    3ed4:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ed6:	8f 3f       	cpi	r24, 0xFF	; 255
    3ed8:	19 f4       	brne	.+6      	; 0x3ee0 <xQueueReceive+0xbc>
    3eda:	ea 81       	ldd	r30, Y+2	; 0x02
    3edc:	fb 81       	ldd	r31, Y+3	; 0x03
    3ede:	15 8e       	std	Z+29, r1	; 0x1d
    3ee0:	ea 81       	ldd	r30, Y+2	; 0x02
    3ee2:	fb 81       	ldd	r31, Y+3	; 0x03
    3ee4:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ee6:	8f 3f       	cpi	r24, 0xFF	; 255
    3ee8:	19 f4       	brne	.+6      	; 0x3ef0 <xQueueReceive+0xcc>
    3eea:	ea 81       	ldd	r30, Y+2	; 0x02
    3eec:	fb 81       	ldd	r31, Y+3	; 0x03
    3eee:	16 8e       	std	Z+30, r1	; 0x1e
    3ef0:	0f 90       	pop	r0
    3ef2:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3ef4:	ce 01       	movw	r24, r28
    3ef6:	05 96       	adiw	r24, 0x05	; 5
    3ef8:	9e 01       	movw	r18, r28
    3efa:	24 5f       	subi	r18, 0xF4	; 244
    3efc:	3f 4f       	sbci	r19, 0xFF	; 255
    3efe:	b9 01       	movw	r22, r18
    3f00:	0e 94 86 38 	call	0x710c	; 0x710c <xTaskCheckForTimeOut>
    3f04:	88 23       	and	r24, r24
    3f06:	09 f5       	brne	.+66     	; 0x3f4a <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3f08:	8a 81       	ldd	r24, Y+2	; 0x02
    3f0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3f0c:	0e 94 bc 23 	call	0x4778	; 0x4778 <prvIsQueueEmpty>
    3f10:	88 23       	and	r24, r24
    3f12:	a1 f0       	breq	.+40     	; 0x3f3c <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3f14:	8a 81       	ldd	r24, Y+2	; 0x02
    3f16:	9b 81       	ldd	r25, Y+3	; 0x03
    3f18:	41 96       	adiw	r24, 0x11	; 17
    3f1a:	2c 85       	ldd	r18, Y+12	; 0x0c
    3f1c:	3d 85       	ldd	r19, Y+13	; 0x0d
    3f1e:	b9 01       	movw	r22, r18
    3f20:	0e 94 76 35 	call	0x6aec	; 0x6aec <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3f24:	8a 81       	ldd	r24, Y+2	; 0x02
    3f26:	9b 81       	ldd	r25, Y+3	; 0x03
    3f28:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3f2c:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    3f30:	88 23       	and	r24, r24
    3f32:	09 f0       	breq	.+2      	; 0x3f36 <xQueueReceive+0x112>
    3f34:	8c cf       	rjmp	.-232    	; 0x3e4e <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    3f36:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    3f3a:	89 cf       	rjmp	.-238    	; 0x3e4e <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    3f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f3e:	9b 81       	ldd	r25, Y+3	; 0x03
    3f40:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3f44:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    3f48:	82 cf       	rjmp	.-252    	; 0x3e4e <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    3f4a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f4c:	9b 81       	ldd	r25, Y+3	; 0x03
    3f4e:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3f52:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3f56:	8a 81       	ldd	r24, Y+2	; 0x02
    3f58:	9b 81       	ldd	r25, Y+3	; 0x03
    3f5a:	0e 94 bc 23 	call	0x4778	; 0x4778 <prvIsQueueEmpty>
    3f5e:	88 23       	and	r24, r24
    3f60:	09 f4       	brne	.+2      	; 0x3f64 <xQueueReceive+0x140>
    3f62:	75 cf       	rjmp	.-278    	; 0x3e4e <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    3f64:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    3f66:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    3f68:	2e 96       	adiw	r28, 0x0e	; 14
    3f6a:	0f b6       	in	r0, 0x3f	; 63
    3f6c:	f8 94       	cli
    3f6e:	de bf       	out	0x3e, r29	; 62
    3f70:	0f be       	out	0x3f, r0	; 63
    3f72:	cd bf       	out	0x3d, r28	; 61
    3f74:	cf 91       	pop	r28
    3f76:	df 91       	pop	r29
    3f78:	08 95       	ret

00003f7a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    3f7a:	df 93       	push	r29
    3f7c:	cf 93       	push	r28
    3f7e:	cd b7       	in	r28, 0x3d	; 61
    3f80:	de b7       	in	r29, 0x3e	; 62
    3f82:	2e 97       	sbiw	r28, 0x0e	; 14
    3f84:	0f b6       	in	r0, 0x3f	; 63
    3f86:	f8 94       	cli
    3f88:	de bf       	out	0x3e, r29	; 62
    3f8a:	0f be       	out	0x3f, r0	; 63
    3f8c:	cd bf       	out	0x3d, r28	; 61
    3f8e:	9b 87       	std	Y+11, r25	; 0x0b
    3f90:	8a 87       	std	Y+10, r24	; 0x0a
    3f92:	7d 87       	std	Y+13, r23	; 0x0d
    3f94:	6c 87       	std	Y+12, r22	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    3f96:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    3f98:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f9a:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f9c:	9d 83       	std	Y+5, r25	; 0x05
    3f9e:	8c 83       	std	Y+4, r24	; 0x04

    #if ( configUSE_MUTEXES == 1 )
        BaseType_t xInheritanceOccurred = pdFALSE;
    3fa0:	1b 82       	std	Y+3, r1	; 0x03
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3fa2:	0f b6       	in	r0, 0x3f	; 63
    3fa4:	f8 94       	cli
    3fa6:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3fa8:	ec 81       	ldd	r30, Y+4	; 0x04
    3faa:	fd 81       	ldd	r31, Y+5	; 0x05
    3fac:	82 8d       	ldd	r24, Z+26	; 0x1a
    3fae:	8a 83       	std	Y+2, r24	; 0x02

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3fb0:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb2:	88 23       	and	r24, r24
    3fb4:	21 f1       	breq	.+72     	; 0x3ffe <xQueueSemaphoreTake+0x84>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3fb6:	8a 81       	ldd	r24, Y+2	; 0x02
    3fb8:	81 50       	subi	r24, 0x01	; 1
    3fba:	ec 81       	ldd	r30, Y+4	; 0x04
    3fbc:	fd 81       	ldd	r31, Y+5	; 0x05
    3fbe:	82 8f       	std	Z+26, r24	; 0x1a

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3fc0:	ec 81       	ldd	r30, Y+4	; 0x04
    3fc2:	fd 81       	ldd	r31, Y+5	; 0x05
    3fc4:	80 81       	ld	r24, Z
    3fc6:	91 81       	ldd	r25, Z+1	; 0x01
    3fc8:	00 97       	sbiw	r24, 0x00	; 0
    3fca:	31 f4       	brne	.+12     	; 0x3fd8 <xQueueSemaphoreTake+0x5e>
                    {
                        /* Record the information required to implement
                         * priority inheritance should it become necessary. */
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    3fcc:	0e 94 67 3c 	call	0x78ce	; 0x78ce <pvTaskIncrementMutexHeldCount>
    3fd0:	ec 81       	ldd	r30, Y+4	; 0x04
    3fd2:	fd 81       	ldd	r31, Y+5	; 0x05
    3fd4:	95 83       	std	Z+5, r25	; 0x05
    3fd6:	84 83       	std	Z+4, r24	; 0x04
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3fd8:	ec 81       	ldd	r30, Y+4	; 0x04
    3fda:	fd 81       	ldd	r31, Y+5	; 0x05
    3fdc:	80 85       	ldd	r24, Z+8	; 0x08
    3fde:	88 23       	and	r24, r24
    3fe0:	49 f0       	breq	.+18     	; 0x3ff4 <xQueueSemaphoreTake+0x7a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3fe2:	8c 81       	ldd	r24, Y+4	; 0x04
    3fe4:	9d 81       	ldd	r25, Y+5	; 0x05
    3fe6:	08 96       	adiw	r24, 0x08	; 8
    3fe8:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    3fec:	88 23       	and	r24, r24
    3fee:	11 f0       	breq	.+4      	; 0x3ff4 <xQueueSemaphoreTake+0x7a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3ff0:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3ff4:	0f 90       	pop	r0
    3ff6:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    3ff8:	81 e0       	ldi	r24, 0x01	; 1
    3ffa:	8e 87       	std	Y+14, r24	; 0x0e
    3ffc:	89 c0       	rjmp	.+274    	; 0x4110 <xQueueSemaphoreTake+0x196>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3ffe:	8c 85       	ldd	r24, Y+12	; 0x0c
    4000:	9d 85       	ldd	r25, Y+13	; 0x0d
    4002:	00 97       	sbiw	r24, 0x00	; 0
    4004:	21 f4       	brne	.+8      	; 0x400e <xQueueSemaphoreTake+0x94>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    4006:	0f 90       	pop	r0
    4008:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    400a:	1e 86       	std	Y+14, r1	; 0x0e
    400c:	81 c0       	rjmp	.+258    	; 0x4110 <xQueueSemaphoreTake+0x196>
                }
                else if( xEntryTimeSet == pdFALSE )
    400e:	8e 81       	ldd	r24, Y+6	; 0x06
    4010:	88 23       	and	r24, r24
    4012:	31 f4       	brne	.+12     	; 0x4020 <xQueueSemaphoreTake+0xa6>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    4014:	ce 01       	movw	r24, r28
    4016:	07 96       	adiw	r24, 0x07	; 7
    4018:	0e 94 6d 38 	call	0x70da	; 0x70da <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    401c:	81 e0       	ldi	r24, 0x01	; 1
    401e:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    4020:	0f 90       	pop	r0
    4022:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    4024:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    4028:	0f b6       	in	r0, 0x3f	; 63
    402a:	f8 94       	cli
    402c:	0f 92       	push	r0
    402e:	ec 81       	ldd	r30, Y+4	; 0x04
    4030:	fd 81       	ldd	r31, Y+5	; 0x05
    4032:	85 8d       	ldd	r24, Z+29	; 0x1d
    4034:	8f 3f       	cpi	r24, 0xFF	; 255
    4036:	19 f4       	brne	.+6      	; 0x403e <xQueueSemaphoreTake+0xc4>
    4038:	ec 81       	ldd	r30, Y+4	; 0x04
    403a:	fd 81       	ldd	r31, Y+5	; 0x05
    403c:	15 8e       	std	Z+29, r1	; 0x1d
    403e:	ec 81       	ldd	r30, Y+4	; 0x04
    4040:	fd 81       	ldd	r31, Y+5	; 0x05
    4042:	86 8d       	ldd	r24, Z+30	; 0x1e
    4044:	8f 3f       	cpi	r24, 0xFF	; 255
    4046:	19 f4       	brne	.+6      	; 0x404e <xQueueSemaphoreTake+0xd4>
    4048:	ec 81       	ldd	r30, Y+4	; 0x04
    404a:	fd 81       	ldd	r31, Y+5	; 0x05
    404c:	16 8e       	std	Z+30, r1	; 0x1e
    404e:	0f 90       	pop	r0
    4050:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4052:	ce 01       	movw	r24, r28
    4054:	07 96       	adiw	r24, 0x07	; 7
    4056:	9e 01       	movw	r18, r28
    4058:	24 5f       	subi	r18, 0xF4	; 244
    405a:	3f 4f       	sbci	r19, 0xFF	; 255
    405c:	b9 01       	movw	r22, r18
    405e:	0e 94 86 38 	call	0x710c	; 0x710c <xTaskCheckForTimeOut>
    4062:	88 23       	and	r24, r24
    4064:	99 f5       	brne	.+102    	; 0x40cc <xQueueSemaphoreTake+0x152>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4066:	8c 81       	ldd	r24, Y+4	; 0x04
    4068:	9d 81       	ldd	r25, Y+5	; 0x05
    406a:	0e 94 bc 23 	call	0x4778	; 0x4778 <prvIsQueueEmpty>
    406e:	88 23       	and	r24, r24
    4070:	31 f1       	breq	.+76     	; 0x40be <xQueueSemaphoreTake+0x144>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

                #if ( configUSE_MUTEXES == 1 )
                {
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4072:	ec 81       	ldd	r30, Y+4	; 0x04
    4074:	fd 81       	ldd	r31, Y+5	; 0x05
    4076:	80 81       	ld	r24, Z
    4078:	91 81       	ldd	r25, Z+1	; 0x01
    407a:	00 97       	sbiw	r24, 0x00	; 0
    407c:	61 f4       	brne	.+24     	; 0x4096 <xQueueSemaphoreTake+0x11c>
                    {
                        taskENTER_CRITICAL();
    407e:	0f b6       	in	r0, 0x3f	; 63
    4080:	f8 94       	cli
    4082:	0f 92       	push	r0
                        {
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    4084:	ec 81       	ldd	r30, Y+4	; 0x04
    4086:	fd 81       	ldd	r31, Y+5	; 0x05
    4088:	84 81       	ldd	r24, Z+4	; 0x04
    408a:	95 81       	ldd	r25, Z+5	; 0x05
    408c:	0e 94 cb 39 	call	0x7396	; 0x7396 <xTaskPriorityInherit>
    4090:	8b 83       	std	Y+3, r24	; 0x03
                        }
                        taskEXIT_CRITICAL();
    4092:	0f 90       	pop	r0
    4094:	0f be       	out	0x3f, r0	; 63
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4096:	8c 81       	ldd	r24, Y+4	; 0x04
    4098:	9d 81       	ldd	r25, Y+5	; 0x05
    409a:	41 96       	adiw	r24, 0x11	; 17
    409c:	2c 85       	ldd	r18, Y+12	; 0x0c
    409e:	3d 85       	ldd	r19, Y+13	; 0x0d
    40a0:	b9 01       	movw	r22, r18
    40a2:	0e 94 76 35 	call	0x6aec	; 0x6aec <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    40a6:	8c 81       	ldd	r24, Y+4	; 0x04
    40a8:	9d 81       	ldd	r25, Y+5	; 0x05
    40aa:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    40ae:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    40b2:	88 23       	and	r24, r24
    40b4:	09 f0       	breq	.+2      	; 0x40b8 <xQueueSemaphoreTake+0x13e>
    40b6:	75 cf       	rjmp	.-278    	; 0x3fa2 <xQueueSemaphoreTake+0x28>
                {
                    portYIELD_WITHIN_API();
    40b8:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    40bc:	72 cf       	rjmp	.-284    	; 0x3fa2 <xQueueSemaphoreTake+0x28>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    40be:	8c 81       	ldd	r24, Y+4	; 0x04
    40c0:	9d 81       	ldd	r25, Y+5	; 0x05
    40c2:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    40c6:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    40ca:	6b cf       	rjmp	.-298    	; 0x3fa2 <xQueueSemaphoreTake+0x28>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    40cc:	8c 81       	ldd	r24, Y+4	; 0x04
    40ce:	9d 81       	ldd	r25, Y+5	; 0x05
    40d0:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    40d4:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    40d8:	8c 81       	ldd	r24, Y+4	; 0x04
    40da:	9d 81       	ldd	r25, Y+5	; 0x05
    40dc:	0e 94 bc 23 	call	0x4778	; 0x4778 <prvIsQueueEmpty>
    40e0:	88 23       	and	r24, r24
    40e2:	09 f4       	brne	.+2      	; 0x40e6 <xQueueSemaphoreTake+0x16c>
    40e4:	5e cf       	rjmp	.-324    	; 0x3fa2 <xQueueSemaphoreTake+0x28>
                #if ( configUSE_MUTEXES == 1 )
                {
                    /* xInheritanceOccurred could only have be set if
                     * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
                     * test the mutex type again to check it is actually a mutex. */
                    if( xInheritanceOccurred != pdFALSE )
    40e6:	8b 81       	ldd	r24, Y+3	; 0x03
    40e8:	88 23       	and	r24, r24
    40ea:	89 f0       	breq	.+34     	; 0x410e <xQueueSemaphoreTake+0x194>
                    {
                        taskENTER_CRITICAL();
    40ec:	0f b6       	in	r0, 0x3f	; 63
    40ee:	f8 94       	cli
    40f0:	0f 92       	push	r0
                            /* This task blocking on the mutex caused another
                             * task to inherit this task's priority.  Now this task
                             * has timed out the priority should be disinherited
                             * again, but only as low as the next highest priority
                             * task that is waiting for the same mutex. */
                            uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    40f2:	8c 81       	ldd	r24, Y+4	; 0x04
    40f4:	9d 81       	ldd	r25, Y+5	; 0x05
    40f6:	0e 94 49 22 	call	0x4492	; 0x4492 <prvGetDisinheritPriorityAfterTimeout>
    40fa:	89 83       	std	Y+1, r24	; 0x01
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    40fc:	ec 81       	ldd	r30, Y+4	; 0x04
    40fe:	fd 81       	ldd	r31, Y+5	; 0x05
    4100:	84 81       	ldd	r24, Z+4	; 0x04
    4102:	95 81       	ldd	r25, Z+5	; 0x05
    4104:	69 81       	ldd	r22, Y+1	; 0x01
    4106:	0e 94 68 3b 	call	0x76d0	; 0x76d0 <vTaskPriorityDisinheritAfterTimeout>
                        }
                        taskEXIT_CRITICAL();
    410a:	0f 90       	pop	r0
    410c:	0f be       	out	0x3f, r0	; 63
                    }
                }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    410e:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    4110:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    4112:	2e 96       	adiw	r28, 0x0e	; 14
    4114:	0f b6       	in	r0, 0x3f	; 63
    4116:	f8 94       	cli
    4118:	de bf       	out	0x3e, r29	; 62
    411a:	0f be       	out	0x3f, r0	; 63
    411c:	cd bf       	out	0x3d, r28	; 61
    411e:	cf 91       	pop	r28
    4120:	df 91       	pop	r29
    4122:	08 95       	ret

00004124 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    4124:	df 93       	push	r29
    4126:	cf 93       	push	r28
    4128:	cd b7       	in	r28, 0x3d	; 61
    412a:	de b7       	in	r29, 0x3e	; 62
    412c:	60 97       	sbiw	r28, 0x10	; 16
    412e:	0f b6       	in	r0, 0x3f	; 63
    4130:	f8 94       	cli
    4132:	de bf       	out	0x3e, r29	; 62
    4134:	0f be       	out	0x3f, r0	; 63
    4136:	cd bf       	out	0x3d, r28	; 61
    4138:	9b 87       	std	Y+11, r25	; 0x0b
    413a:	8a 87       	std	Y+10, r24	; 0x0a
    413c:	7d 87       	std	Y+13, r23	; 0x0d
    413e:	6c 87       	std	Y+12, r22	; 0x0c
    4140:	5f 87       	std	Y+15, r21	; 0x0f
    4142:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    4144:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    4146:	8a 85       	ldd	r24, Y+10	; 0x0a
    4148:	9b 85       	ldd	r25, Y+11	; 0x0b
    414a:	9b 83       	std	Y+3, r25	; 0x03
    414c:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    414e:	0f b6       	in	r0, 0x3f	; 63
    4150:	f8 94       	cli
    4152:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4154:	ea 81       	ldd	r30, Y+2	; 0x02
    4156:	fb 81       	ldd	r31, Y+3	; 0x03
    4158:	82 8d       	ldd	r24, Z+26	; 0x1a
    415a:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    415c:	89 81       	ldd	r24, Y+1	; 0x01
    415e:	88 23       	and	r24, r24
    4160:	31 f1       	breq	.+76     	; 0x41ae <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    4162:	ea 81       	ldd	r30, Y+2	; 0x02
    4164:	fb 81       	ldd	r31, Y+3	; 0x03
    4166:	86 81       	ldd	r24, Z+6	; 0x06
    4168:	97 81       	ldd	r25, Z+7	; 0x07
    416a:	9d 83       	std	Y+5, r25	; 0x05
    416c:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    416e:	8a 81       	ldd	r24, Y+2	; 0x02
    4170:	9b 81       	ldd	r25, Y+3	; 0x03
    4172:	2c 85       	ldd	r18, Y+12	; 0x0c
    4174:	3d 85       	ldd	r19, Y+13	; 0x0d
    4176:	b9 01       	movw	r22, r18
    4178:	0e 94 22 23 	call	0x4644	; 0x4644 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    417c:	ea 81       	ldd	r30, Y+2	; 0x02
    417e:	fb 81       	ldd	r31, Y+3	; 0x03
    4180:	8c 81       	ldd	r24, Y+4	; 0x04
    4182:	9d 81       	ldd	r25, Y+5	; 0x05
    4184:	97 83       	std	Z+7, r25	; 0x07
    4186:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4188:	ea 81       	ldd	r30, Y+2	; 0x02
    418a:	fb 81       	ldd	r31, Y+3	; 0x03
    418c:	81 89       	ldd	r24, Z+17	; 0x11
    418e:	88 23       	and	r24, r24
    4190:	49 f0       	breq	.+18     	; 0x41a4 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4192:	8a 81       	ldd	r24, Y+2	; 0x02
    4194:	9b 81       	ldd	r25, Y+3	; 0x03
    4196:	41 96       	adiw	r24, 0x11	; 17
    4198:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    419c:	88 23       	and	r24, r24
    419e:	11 f0       	breq	.+4      	; 0x41a4 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    41a0:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    41a4:	0f 90       	pop	r0
    41a6:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    41a8:	81 e0       	ldi	r24, 0x01	; 1
    41aa:	88 8b       	std	Y+16, r24	; 0x10
    41ac:	63 c0       	rjmp	.+198    	; 0x4274 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    41ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    41b0:	9f 85       	ldd	r25, Y+15	; 0x0f
    41b2:	00 97       	sbiw	r24, 0x00	; 0
    41b4:	21 f4       	brne	.+8      	; 0x41be <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    41b6:	0f 90       	pop	r0
    41b8:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    41ba:	18 8a       	std	Y+16, r1	; 0x10
    41bc:	5b c0       	rjmp	.+182    	; 0x4274 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    41be:	8e 81       	ldd	r24, Y+6	; 0x06
    41c0:	88 23       	and	r24, r24
    41c2:	31 f4       	brne	.+12     	; 0x41d0 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    41c4:	ce 01       	movw	r24, r28
    41c6:	07 96       	adiw	r24, 0x07	; 7
    41c8:	0e 94 6d 38 	call	0x70da	; 0x70da <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    41cc:	81 e0       	ldi	r24, 0x01	; 1
    41ce:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    41d0:	0f 90       	pop	r0
    41d2:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    41d4:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    41d8:	0f b6       	in	r0, 0x3f	; 63
    41da:	f8 94       	cli
    41dc:	0f 92       	push	r0
    41de:	ea 81       	ldd	r30, Y+2	; 0x02
    41e0:	fb 81       	ldd	r31, Y+3	; 0x03
    41e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    41e4:	8f 3f       	cpi	r24, 0xFF	; 255
    41e6:	19 f4       	brne	.+6      	; 0x41ee <xQueuePeek+0xca>
    41e8:	ea 81       	ldd	r30, Y+2	; 0x02
    41ea:	fb 81       	ldd	r31, Y+3	; 0x03
    41ec:	15 8e       	std	Z+29, r1	; 0x1d
    41ee:	ea 81       	ldd	r30, Y+2	; 0x02
    41f0:	fb 81       	ldd	r31, Y+3	; 0x03
    41f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    41f4:	8f 3f       	cpi	r24, 0xFF	; 255
    41f6:	19 f4       	brne	.+6      	; 0x41fe <xQueuePeek+0xda>
    41f8:	ea 81       	ldd	r30, Y+2	; 0x02
    41fa:	fb 81       	ldd	r31, Y+3	; 0x03
    41fc:	16 8e       	std	Z+30, r1	; 0x1e
    41fe:	0f 90       	pop	r0
    4200:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4202:	ce 01       	movw	r24, r28
    4204:	07 96       	adiw	r24, 0x07	; 7
    4206:	9e 01       	movw	r18, r28
    4208:	22 5f       	subi	r18, 0xF2	; 242
    420a:	3f 4f       	sbci	r19, 0xFF	; 255
    420c:	b9 01       	movw	r22, r18
    420e:	0e 94 86 38 	call	0x710c	; 0x710c <xTaskCheckForTimeOut>
    4212:	88 23       	and	r24, r24
    4214:	09 f5       	brne	.+66     	; 0x4258 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4216:	8a 81       	ldd	r24, Y+2	; 0x02
    4218:	9b 81       	ldd	r25, Y+3	; 0x03
    421a:	0e 94 bc 23 	call	0x4778	; 0x4778 <prvIsQueueEmpty>
    421e:	88 23       	and	r24, r24
    4220:	a1 f0       	breq	.+40     	; 0x424a <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4222:	8a 81       	ldd	r24, Y+2	; 0x02
    4224:	9b 81       	ldd	r25, Y+3	; 0x03
    4226:	41 96       	adiw	r24, 0x11	; 17
    4228:	2e 85       	ldd	r18, Y+14	; 0x0e
    422a:	3f 85       	ldd	r19, Y+15	; 0x0f
    422c:	b9 01       	movw	r22, r18
    422e:	0e 94 76 35 	call	0x6aec	; 0x6aec <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    4232:	8a 81       	ldd	r24, Y+2	; 0x02
    4234:	9b 81       	ldd	r25, Y+3	; 0x03
    4236:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    423a:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    423e:	88 23       	and	r24, r24
    4240:	09 f0       	breq	.+2      	; 0x4244 <xQueuePeek+0x120>
    4242:	85 cf       	rjmp	.-246    	; 0x414e <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    4244:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    4248:	82 cf       	rjmp	.-252    	; 0x414e <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    424a:	8a 81       	ldd	r24, Y+2	; 0x02
    424c:	9b 81       	ldd	r25, Y+3	; 0x03
    424e:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    4252:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    4256:	7b cf       	rjmp	.-266    	; 0x414e <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    4258:	8a 81       	ldd	r24, Y+2	; 0x02
    425a:	9b 81       	ldd	r25, Y+3	; 0x03
    425c:	0e 94 69 23 	call	0x46d2	; 0x46d2 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    4260:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4264:	8a 81       	ldd	r24, Y+2	; 0x02
    4266:	9b 81       	ldd	r25, Y+3	; 0x03
    4268:	0e 94 bc 23 	call	0x4778	; 0x4778 <prvIsQueueEmpty>
    426c:	88 23       	and	r24, r24
    426e:	09 f4       	brne	.+2      	; 0x4272 <xQueuePeek+0x14e>
    4270:	6e cf       	rjmp	.-292    	; 0x414e <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    4272:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    4274:	88 89       	ldd	r24, Y+16	; 0x10
}
    4276:	60 96       	adiw	r28, 0x10	; 16
    4278:	0f b6       	in	r0, 0x3f	; 63
    427a:	f8 94       	cli
    427c:	de bf       	out	0x3e, r29	; 62
    427e:	0f be       	out	0x3f, r0	; 63
    4280:	cd bf       	out	0x3d, r28	; 61
    4282:	cf 91       	pop	r28
    4284:	df 91       	pop	r29
    4286:	08 95       	ret

00004288 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    4288:	df 93       	push	r29
    428a:	cf 93       	push	r28
    428c:	cd b7       	in	r28, 0x3d	; 61
    428e:	de b7       	in	r29, 0x3e	; 62
    4290:	2d 97       	sbiw	r28, 0x0d	; 13
    4292:	0f b6       	in	r0, 0x3f	; 63
    4294:	f8 94       	cli
    4296:	de bf       	out	0x3e, r29	; 62
    4298:	0f be       	out	0x3f, r0	; 63
    429a:	cd bf       	out	0x3d, r28	; 61
    429c:	99 87       	std	Y+9, r25	; 0x09
    429e:	88 87       	std	Y+8, r24	; 0x08
    42a0:	7b 87       	std	Y+11, r23	; 0x0b
    42a2:	6a 87       	std	Y+10, r22	; 0x0a
    42a4:	5d 87       	std	Y+13, r21	; 0x0d
    42a6:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    42a8:	88 85       	ldd	r24, Y+8	; 0x08
    42aa:	99 85       	ldd	r25, Y+9	; 0x09
    42ac:	9d 83       	std	Y+5, r25	; 0x05
    42ae:	8c 83       	std	Y+4, r24	; 0x04
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    42b0:	1e 82       	std	Y+6, r1	; 0x06
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    42b2:	ec 81       	ldd	r30, Y+4	; 0x04
    42b4:	fd 81       	ldd	r31, Y+5	; 0x05
    42b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    42b8:	8b 83       	std	Y+3, r24	; 0x03

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    42ba:	8b 81       	ldd	r24, Y+3	; 0x03
    42bc:	88 23       	and	r24, r24
    42be:	b9 f1       	breq	.+110    	; 0x432e <xQueueReceiveFromISR+0xa6>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    42c0:	ec 81       	ldd	r30, Y+4	; 0x04
    42c2:	fd 81       	ldd	r31, Y+5	; 0x05
    42c4:	85 8d       	ldd	r24, Z+29	; 0x1d
    42c6:	8a 83       	std	Y+2, r24	; 0x02

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    42c8:	8c 81       	ldd	r24, Y+4	; 0x04
    42ca:	9d 81       	ldd	r25, Y+5	; 0x05
    42cc:	2a 85       	ldd	r18, Y+10	; 0x0a
    42ce:	3b 85       	ldd	r19, Y+11	; 0x0b
    42d0:	b9 01       	movw	r22, r18
    42d2:	0e 94 22 23 	call	0x4644	; 0x4644 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    42d6:	8b 81       	ldd	r24, Y+3	; 0x03
    42d8:	81 50       	subi	r24, 0x01	; 1
    42da:	ec 81       	ldd	r30, Y+4	; 0x04
    42dc:	fd 81       	ldd	r31, Y+5	; 0x05
    42de:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    42e0:	8a 81       	ldd	r24, Y+2	; 0x02
    42e2:	8f 3f       	cpi	r24, 0xFF	; 255
    42e4:	a9 f4       	brne	.+42     	; 0x4310 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    42e6:	ec 81       	ldd	r30, Y+4	; 0x04
    42e8:	fd 81       	ldd	r31, Y+5	; 0x05
    42ea:	80 85       	ldd	r24, Z+8	; 0x08
    42ec:	88 23       	and	r24, r24
    42ee:	e1 f0       	breq	.+56     	; 0x4328 <xQueueReceiveFromISR+0xa0>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    42f0:	8c 81       	ldd	r24, Y+4	; 0x04
    42f2:	9d 81       	ldd	r25, Y+5	; 0x05
    42f4:	08 96       	adiw	r24, 0x08	; 8
    42f6:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    42fa:	88 23       	and	r24, r24
    42fc:	a9 f0       	breq	.+42     	; 0x4328 <xQueueReceiveFromISR+0xa0>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    42fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    4300:	9d 85       	ldd	r25, Y+13	; 0x0d
    4302:	00 97       	sbiw	r24, 0x00	; 0
    4304:	89 f0       	breq	.+34     	; 0x4328 <xQueueReceiveFromISR+0xa0>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    4306:	ec 85       	ldd	r30, Y+12	; 0x0c
    4308:	fd 85       	ldd	r31, Y+13	; 0x0d
    430a:	81 e0       	ldi	r24, 0x01	; 1
    430c:	80 83       	st	Z, r24
    430e:	0c c0       	rjmp	.+24     	; 0x4328 <xQueueReceiveFromISR+0xa0>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    4310:	0e 94 1c 33 	call	0x6638	; 0x6638 <uxTaskGetNumberOfTasks>
    4314:	89 83       	std	Y+1, r24	; 0x01
    4316:	9a 81       	ldd	r25, Y+2	; 0x02
    4318:	89 81       	ldd	r24, Y+1	; 0x01
    431a:	98 17       	cp	r25, r24
    431c:	28 f4       	brcc	.+10     	; 0x4328 <xQueueReceiveFromISR+0xa0>
    431e:	8a 81       	ldd	r24, Y+2	; 0x02
    4320:	8f 5f       	subi	r24, 0xFF	; 255
    4322:	ec 81       	ldd	r30, Y+4	; 0x04
    4324:	fd 81       	ldd	r31, Y+5	; 0x05
    4326:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    4328:	81 e0       	ldi	r24, 0x01	; 1
    432a:	8f 83       	std	Y+7, r24	; 0x07
    432c:	01 c0       	rjmp	.+2      	; 0x4330 <xQueueReceiveFromISR+0xa8>
        }
        else
        {
            xReturn = pdFAIL;
    432e:	1f 82       	std	Y+7, r1	; 0x07
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    4330:	8f 81       	ldd	r24, Y+7	; 0x07
}
    4332:	2d 96       	adiw	r28, 0x0d	; 13
    4334:	0f b6       	in	r0, 0x3f	; 63
    4336:	f8 94       	cli
    4338:	de bf       	out	0x3e, r29	; 62
    433a:	0f be       	out	0x3f, r0	; 63
    433c:	cd bf       	out	0x3d, r28	; 61
    433e:	cf 91       	pop	r28
    4340:	df 91       	pop	r29
    4342:	08 95       	ret

00004344 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    4344:	df 93       	push	r29
    4346:	cf 93       	push	r28
    4348:	cd b7       	in	r28, 0x3d	; 61
    434a:	de b7       	in	r29, 0x3e	; 62
    434c:	2a 97       	sbiw	r28, 0x0a	; 10
    434e:	0f b6       	in	r0, 0x3f	; 63
    4350:	f8 94       	cli
    4352:	de bf       	out	0x3e, r29	; 62
    4354:	0f be       	out	0x3f, r0	; 63
    4356:	cd bf       	out	0x3d, r28	; 61
    4358:	98 87       	std	Y+8, r25	; 0x08
    435a:	8f 83       	std	Y+7, r24	; 0x07
    435c:	7a 87       	std	Y+10, r23	; 0x0a
    435e:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    4360:	8f 81       	ldd	r24, Y+7	; 0x07
    4362:	98 85       	ldd	r25, Y+8	; 0x08
    4364:	9a 83       	std	Y+2, r25	; 0x02
    4366:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4368:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    436a:	e9 81       	ldd	r30, Y+1	; 0x01
    436c:	fa 81       	ldd	r31, Y+2	; 0x02
    436e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4370:	88 23       	and	r24, r24
    4372:	b1 f0       	breq	.+44     	; 0x43a0 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    4374:	e9 81       	ldd	r30, Y+1	; 0x01
    4376:	fa 81       	ldd	r31, Y+2	; 0x02
    4378:	86 81       	ldd	r24, Z+6	; 0x06
    437a:	97 81       	ldd	r25, Z+7	; 0x07
    437c:	9c 83       	std	Y+4, r25	; 0x04
    437e:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    4380:	89 81       	ldd	r24, Y+1	; 0x01
    4382:	9a 81       	ldd	r25, Y+2	; 0x02
    4384:	29 85       	ldd	r18, Y+9	; 0x09
    4386:	3a 85       	ldd	r19, Y+10	; 0x0a
    4388:	b9 01       	movw	r22, r18
    438a:	0e 94 22 23 	call	0x4644	; 0x4644 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    438e:	e9 81       	ldd	r30, Y+1	; 0x01
    4390:	fa 81       	ldd	r31, Y+2	; 0x02
    4392:	8b 81       	ldd	r24, Y+3	; 0x03
    4394:	9c 81       	ldd	r25, Y+4	; 0x04
    4396:	97 83       	std	Z+7, r25	; 0x07
    4398:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    439a:	81 e0       	ldi	r24, 0x01	; 1
    439c:	8e 83       	std	Y+6, r24	; 0x06
    439e:	01 c0       	rjmp	.+2      	; 0x43a2 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    43a0:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    43a2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    43a4:	2a 96       	adiw	r28, 0x0a	; 10
    43a6:	0f b6       	in	r0, 0x3f	; 63
    43a8:	f8 94       	cli
    43aa:	de bf       	out	0x3e, r29	; 62
    43ac:	0f be       	out	0x3f, r0	; 63
    43ae:	cd bf       	out	0x3d, r28	; 61
    43b0:	cf 91       	pop	r28
    43b2:	df 91       	pop	r29
    43b4:	08 95       	ret

000043b6 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    43b6:	df 93       	push	r29
    43b8:	cf 93       	push	r28
    43ba:	00 d0       	rcall	.+0      	; 0x43bc <uxQueueMessagesWaiting+0x6>
    43bc:	0f 92       	push	r0
    43be:	cd b7       	in	r28, 0x3d	; 61
    43c0:	de b7       	in	r29, 0x3e	; 62
    43c2:	9b 83       	std	Y+3, r25	; 0x03
    43c4:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    43c6:	0f b6       	in	r0, 0x3f	; 63
    43c8:	f8 94       	cli
    43ca:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    43cc:	ea 81       	ldd	r30, Y+2	; 0x02
    43ce:	fb 81       	ldd	r31, Y+3	; 0x03
    43d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    43d2:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    43d4:	0f 90       	pop	r0
    43d6:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    43d8:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    43da:	0f 90       	pop	r0
    43dc:	0f 90       	pop	r0
    43de:	0f 90       	pop	r0
    43e0:	cf 91       	pop	r28
    43e2:	df 91       	pop	r29
    43e4:	08 95       	ret

000043e6 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    43e6:	df 93       	push	r29
    43e8:	cf 93       	push	r28
    43ea:	00 d0       	rcall	.+0      	; 0x43ec <uxQueueSpacesAvailable+0x6>
    43ec:	00 d0       	rcall	.+0      	; 0x43ee <uxQueueSpacesAvailable+0x8>
    43ee:	0f 92       	push	r0
    43f0:	cd b7       	in	r28, 0x3d	; 61
    43f2:	de b7       	in	r29, 0x3e	; 62
    43f4:	9d 83       	std	Y+5, r25	; 0x05
    43f6:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    43f8:	8c 81       	ldd	r24, Y+4	; 0x04
    43fa:	9d 81       	ldd	r25, Y+5	; 0x05
    43fc:	9a 83       	std	Y+2, r25	; 0x02
    43fe:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    4400:	0f b6       	in	r0, 0x3f	; 63
    4402:	f8 94       	cli
    4404:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    4406:	e9 81       	ldd	r30, Y+1	; 0x01
    4408:	fa 81       	ldd	r31, Y+2	; 0x02
    440a:	93 8d       	ldd	r25, Z+27	; 0x1b
    440c:	e9 81       	ldd	r30, Y+1	; 0x01
    440e:	fa 81       	ldd	r31, Y+2	; 0x02
    4410:	82 8d       	ldd	r24, Z+26	; 0x1a
    4412:	29 2f       	mov	r18, r25
    4414:	28 1b       	sub	r18, r24
    4416:	82 2f       	mov	r24, r18
    4418:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    441a:	0f 90       	pop	r0
    441c:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    441e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4420:	0f 90       	pop	r0
    4422:	0f 90       	pop	r0
    4424:	0f 90       	pop	r0
    4426:	0f 90       	pop	r0
    4428:	0f 90       	pop	r0
    442a:	cf 91       	pop	r28
    442c:	df 91       	pop	r29
    442e:	08 95       	ret

00004430 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    4430:	df 93       	push	r29
    4432:	cf 93       	push	r28
    4434:	00 d0       	rcall	.+0      	; 0x4436 <uxQueueMessagesWaitingFromISR+0x6>
    4436:	00 d0       	rcall	.+0      	; 0x4438 <uxQueueMessagesWaitingFromISR+0x8>
    4438:	0f 92       	push	r0
    443a:	cd b7       	in	r28, 0x3d	; 61
    443c:	de b7       	in	r29, 0x3e	; 62
    443e:	9d 83       	std	Y+5, r25	; 0x05
    4440:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    4442:	8c 81       	ldd	r24, Y+4	; 0x04
    4444:	9d 81       	ldd	r25, Y+5	; 0x05
    4446:	9a 83       	std	Y+2, r25	; 0x02
    4448:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    444a:	e9 81       	ldd	r30, Y+1	; 0x01
    444c:	fa 81       	ldd	r31, Y+2	; 0x02
    444e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4450:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    4452:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4454:	0f 90       	pop	r0
    4456:	0f 90       	pop	r0
    4458:	0f 90       	pop	r0
    445a:	0f 90       	pop	r0
    445c:	0f 90       	pop	r0
    445e:	cf 91       	pop	r28
    4460:	df 91       	pop	r29
    4462:	08 95       	ret

00004464 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    4464:	df 93       	push	r29
    4466:	cf 93       	push	r28
    4468:	00 d0       	rcall	.+0      	; 0x446a <vQueueDelete+0x6>
    446a:	00 d0       	rcall	.+0      	; 0x446c <vQueueDelete+0x8>
    446c:	cd b7       	in	r28, 0x3d	; 61
    446e:	de b7       	in	r29, 0x3e	; 62
    4470:	9c 83       	std	Y+4, r25	; 0x04
    4472:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    4474:	8b 81       	ldd	r24, Y+3	; 0x03
    4476:	9c 81       	ldd	r25, Y+4	; 0x04
    4478:	9a 83       	std	Y+2, r25	; 0x02
    447a:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    447c:	89 81       	ldd	r24, Y+1	; 0x01
    447e:	9a 81       	ldd	r25, Y+2	; 0x02
    4480:	0e 94 b4 17 	call	0x2f68	; 0x2f68 <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    4484:	0f 90       	pop	r0
    4486:	0f 90       	pop	r0
    4488:	0f 90       	pop	r0
    448a:	0f 90       	pop	r0
    448c:	cf 91       	pop	r28
    448e:	df 91       	pop	r29
    4490:	08 95       	ret

00004492 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
    {
    4492:	df 93       	push	r29
    4494:	cf 93       	push	r28
    4496:	00 d0       	rcall	.+0      	; 0x4498 <prvGetDisinheritPriorityAfterTimeout+0x6>
    4498:	0f 92       	push	r0
    449a:	cd b7       	in	r28, 0x3d	; 61
    449c:	de b7       	in	r29, 0x3e	; 62
    449e:	9b 83       	std	Y+3, r25	; 0x03
    44a0:	8a 83       	std	Y+2, r24	; 0x02
         * priority, but the waiting task times out, then the holder should
         * disinherit the priority - but only down to the highest priority of any
         * other tasks that are waiting for the same mutex.  For this purpose,
         * return the priority of the highest priority task that is waiting for the
         * mutex. */
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    44a2:	ea 81       	ldd	r30, Y+2	; 0x02
    44a4:	fb 81       	ldd	r31, Y+3	; 0x03
    44a6:	81 89       	ldd	r24, Z+17	; 0x11
    44a8:	88 23       	and	r24, r24
    44aa:	61 f0       	breq	.+24     	; 0x44c4 <prvGetDisinheritPriorityAfterTimeout+0x32>
        {
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    44ac:	ea 81       	ldd	r30, Y+2	; 0x02
    44ae:	fb 81       	ldd	r31, Y+3	; 0x03
    44b0:	06 88       	ldd	r0, Z+22	; 0x16
    44b2:	f7 89       	ldd	r31, Z+23	; 0x17
    44b4:	e0 2d       	mov	r30, r0
    44b6:	80 81       	ld	r24, Z
    44b8:	91 81       	ldd	r25, Z+1	; 0x01
    44ba:	98 2f       	mov	r25, r24
    44bc:	84 e0       	ldi	r24, 0x04	; 4
    44be:	89 1b       	sub	r24, r25
    44c0:	89 83       	std	Y+1, r24	; 0x01
    44c2:	01 c0       	rjmp	.+2      	; 0x44c6 <prvGetDisinheritPriorityAfterTimeout+0x34>
        }
        else
        {
            uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    44c4:	19 82       	std	Y+1, r1	; 0x01
        }

        return uxHighestPriorityOfWaitingTasks;
    44c6:	89 81       	ldd	r24, Y+1	; 0x01
    }
    44c8:	0f 90       	pop	r0
    44ca:	0f 90       	pop	r0
    44cc:	0f 90       	pop	r0
    44ce:	cf 91       	pop	r28
    44d0:	df 91       	pop	r29
    44d2:	08 95       	ret

000044d4 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    44d4:	df 93       	push	r29
    44d6:	cf 93       	push	r28
    44d8:	cd b7       	in	r28, 0x3d	; 61
    44da:	de b7       	in	r29, 0x3e	; 62
    44dc:	27 97       	sbiw	r28, 0x07	; 7
    44de:	0f b6       	in	r0, 0x3f	; 63
    44e0:	f8 94       	cli
    44e2:	de bf       	out	0x3e, r29	; 62
    44e4:	0f be       	out	0x3f, r0	; 63
    44e6:	cd bf       	out	0x3d, r28	; 61
    44e8:	9c 83       	std	Y+4, r25	; 0x04
    44ea:	8b 83       	std	Y+3, r24	; 0x03
    44ec:	7e 83       	std	Y+6, r23	; 0x06
    44ee:	6d 83       	std	Y+5, r22	; 0x05
    44f0:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    44f2:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    44f4:	eb 81       	ldd	r30, Y+3	; 0x03
    44f6:	fc 81       	ldd	r31, Y+4	; 0x04
    44f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    44fa:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    44fc:	eb 81       	ldd	r30, Y+3	; 0x03
    44fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4500:	84 8d       	ldd	r24, Z+28	; 0x1c
    4502:	88 23       	and	r24, r24
    4504:	99 f4       	brne	.+38     	; 0x452c <prvCopyDataToQueue+0x58>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4506:	eb 81       	ldd	r30, Y+3	; 0x03
    4508:	fc 81       	ldd	r31, Y+4	; 0x04
    450a:	80 81       	ld	r24, Z
    450c:	91 81       	ldd	r25, Z+1	; 0x01
    450e:	00 97       	sbiw	r24, 0x00	; 0
    4510:	09 f0       	breq	.+2      	; 0x4514 <prvCopyDataToQueue+0x40>
    4512:	89 c0       	rjmp	.+274    	; 0x4626 <prvCopyDataToQueue+0x152>
            {
                /* The mutex is no longer being held. */
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    4514:	eb 81       	ldd	r30, Y+3	; 0x03
    4516:	fc 81       	ldd	r31, Y+4	; 0x04
    4518:	84 81       	ldd	r24, Z+4	; 0x04
    451a:	95 81       	ldd	r25, Z+5	; 0x05
    451c:	0e 94 b0 3a 	call	0x7560	; 0x7560 <xTaskPriorityDisinherit>
    4520:	8a 83       	std	Y+2, r24	; 0x02
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
    4522:	eb 81       	ldd	r30, Y+3	; 0x03
    4524:	fc 81       	ldd	r31, Y+4	; 0x04
    4526:	15 82       	std	Z+5, r1	; 0x05
    4528:	14 82       	std	Z+4, r1	; 0x04
    452a:	7d c0       	rjmp	.+250    	; 0x4626 <prvCopyDataToQueue+0x152>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    452c:	8f 81       	ldd	r24, Y+7	; 0x07
    452e:	88 23       	and	r24, r24
    4530:	99 f5       	brne	.+102    	; 0x4598 <prvCopyDataToQueue+0xc4>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    4532:	eb 81       	ldd	r30, Y+3	; 0x03
    4534:	fc 81       	ldd	r31, Y+4	; 0x04
    4536:	62 81       	ldd	r22, Z+2	; 0x02
    4538:	73 81       	ldd	r23, Z+3	; 0x03
    453a:	eb 81       	ldd	r30, Y+3	; 0x03
    453c:	fc 81       	ldd	r31, Y+4	; 0x04
    453e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4540:	48 2f       	mov	r20, r24
    4542:	50 e0       	ldi	r21, 0x00	; 0
    4544:	2d 81       	ldd	r18, Y+5	; 0x05
    4546:	3e 81       	ldd	r19, Y+6	; 0x06
    4548:	cb 01       	movw	r24, r22
    454a:	b9 01       	movw	r22, r18
    454c:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    4550:	eb 81       	ldd	r30, Y+3	; 0x03
    4552:	fc 81       	ldd	r31, Y+4	; 0x04
    4554:	22 81       	ldd	r18, Z+2	; 0x02
    4556:	33 81       	ldd	r19, Z+3	; 0x03
    4558:	eb 81       	ldd	r30, Y+3	; 0x03
    455a:	fc 81       	ldd	r31, Y+4	; 0x04
    455c:	84 8d       	ldd	r24, Z+28	; 0x1c
    455e:	88 2f       	mov	r24, r24
    4560:	90 e0       	ldi	r25, 0x00	; 0
    4562:	82 0f       	add	r24, r18
    4564:	93 1f       	adc	r25, r19
    4566:	eb 81       	ldd	r30, Y+3	; 0x03
    4568:	fc 81       	ldd	r31, Y+4	; 0x04
    456a:	93 83       	std	Z+3, r25	; 0x03
    456c:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    456e:	eb 81       	ldd	r30, Y+3	; 0x03
    4570:	fc 81       	ldd	r31, Y+4	; 0x04
    4572:	22 81       	ldd	r18, Z+2	; 0x02
    4574:	33 81       	ldd	r19, Z+3	; 0x03
    4576:	eb 81       	ldd	r30, Y+3	; 0x03
    4578:	fc 81       	ldd	r31, Y+4	; 0x04
    457a:	84 81       	ldd	r24, Z+4	; 0x04
    457c:	95 81       	ldd	r25, Z+5	; 0x05
    457e:	28 17       	cp	r18, r24
    4580:	39 07       	cpc	r19, r25
    4582:	08 f4       	brcc	.+2      	; 0x4586 <prvCopyDataToQueue+0xb2>
    4584:	50 c0       	rjmp	.+160    	; 0x4626 <prvCopyDataToQueue+0x152>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    4586:	eb 81       	ldd	r30, Y+3	; 0x03
    4588:	fc 81       	ldd	r31, Y+4	; 0x04
    458a:	80 81       	ld	r24, Z
    458c:	91 81       	ldd	r25, Z+1	; 0x01
    458e:	eb 81       	ldd	r30, Y+3	; 0x03
    4590:	fc 81       	ldd	r31, Y+4	; 0x04
    4592:	93 83       	std	Z+3, r25	; 0x03
    4594:	82 83       	std	Z+2, r24	; 0x02
    4596:	47 c0       	rjmp	.+142    	; 0x4626 <prvCopyDataToQueue+0x152>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    4598:	eb 81       	ldd	r30, Y+3	; 0x03
    459a:	fc 81       	ldd	r31, Y+4	; 0x04
    459c:	66 81       	ldd	r22, Z+6	; 0x06
    459e:	77 81       	ldd	r23, Z+7	; 0x07
    45a0:	eb 81       	ldd	r30, Y+3	; 0x03
    45a2:	fc 81       	ldd	r31, Y+4	; 0x04
    45a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    45a6:	48 2f       	mov	r20, r24
    45a8:	50 e0       	ldi	r21, 0x00	; 0
    45aa:	2d 81       	ldd	r18, Y+5	; 0x05
    45ac:	3e 81       	ldd	r19, Y+6	; 0x06
    45ae:	cb 01       	movw	r24, r22
    45b0:	b9 01       	movw	r22, r18
    45b2:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    45b6:	eb 81       	ldd	r30, Y+3	; 0x03
    45b8:	fc 81       	ldd	r31, Y+4	; 0x04
    45ba:	26 81       	ldd	r18, Z+6	; 0x06
    45bc:	37 81       	ldd	r19, Z+7	; 0x07
    45be:	eb 81       	ldd	r30, Y+3	; 0x03
    45c0:	fc 81       	ldd	r31, Y+4	; 0x04
    45c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    45c4:	88 2f       	mov	r24, r24
    45c6:	90 e0       	ldi	r25, 0x00	; 0
    45c8:	90 95       	com	r25
    45ca:	81 95       	neg	r24
    45cc:	9f 4f       	sbci	r25, 0xFF	; 255
    45ce:	82 0f       	add	r24, r18
    45d0:	93 1f       	adc	r25, r19
    45d2:	eb 81       	ldd	r30, Y+3	; 0x03
    45d4:	fc 81       	ldd	r31, Y+4	; 0x04
    45d6:	97 83       	std	Z+7, r25	; 0x07
    45d8:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    45da:	eb 81       	ldd	r30, Y+3	; 0x03
    45dc:	fc 81       	ldd	r31, Y+4	; 0x04
    45de:	26 81       	ldd	r18, Z+6	; 0x06
    45e0:	37 81       	ldd	r19, Z+7	; 0x07
    45e2:	eb 81       	ldd	r30, Y+3	; 0x03
    45e4:	fc 81       	ldd	r31, Y+4	; 0x04
    45e6:	80 81       	ld	r24, Z
    45e8:	91 81       	ldd	r25, Z+1	; 0x01
    45ea:	28 17       	cp	r18, r24
    45ec:	39 07       	cpc	r19, r25
    45ee:	90 f4       	brcc	.+36     	; 0x4614 <prvCopyDataToQueue+0x140>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    45f0:	eb 81       	ldd	r30, Y+3	; 0x03
    45f2:	fc 81       	ldd	r31, Y+4	; 0x04
    45f4:	24 81       	ldd	r18, Z+4	; 0x04
    45f6:	35 81       	ldd	r19, Z+5	; 0x05
    45f8:	eb 81       	ldd	r30, Y+3	; 0x03
    45fa:	fc 81       	ldd	r31, Y+4	; 0x04
    45fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    45fe:	88 2f       	mov	r24, r24
    4600:	90 e0       	ldi	r25, 0x00	; 0
    4602:	90 95       	com	r25
    4604:	81 95       	neg	r24
    4606:	9f 4f       	sbci	r25, 0xFF	; 255
    4608:	82 0f       	add	r24, r18
    460a:	93 1f       	adc	r25, r19
    460c:	eb 81       	ldd	r30, Y+3	; 0x03
    460e:	fc 81       	ldd	r31, Y+4	; 0x04
    4610:	97 83       	std	Z+7, r25	; 0x07
    4612:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    4614:	8f 81       	ldd	r24, Y+7	; 0x07
    4616:	82 30       	cpi	r24, 0x02	; 2
    4618:	31 f4       	brne	.+12     	; 0x4626 <prvCopyDataToQueue+0x152>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    461a:	89 81       	ldd	r24, Y+1	; 0x01
    461c:	88 23       	and	r24, r24
    461e:	19 f0       	breq	.+6      	; 0x4626 <prvCopyDataToQueue+0x152>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    4620:	89 81       	ldd	r24, Y+1	; 0x01
    4622:	81 50       	subi	r24, 0x01	; 1
    4624:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    4626:	89 81       	ldd	r24, Y+1	; 0x01
    4628:	8f 5f       	subi	r24, 0xFF	; 255
    462a:	eb 81       	ldd	r30, Y+3	; 0x03
    462c:	fc 81       	ldd	r31, Y+4	; 0x04
    462e:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    4630:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4632:	27 96       	adiw	r28, 0x07	; 7
    4634:	0f b6       	in	r0, 0x3f	; 63
    4636:	f8 94       	cli
    4638:	de bf       	out	0x3e, r29	; 62
    463a:	0f be       	out	0x3f, r0	; 63
    463c:	cd bf       	out	0x3d, r28	; 61
    463e:	cf 91       	pop	r28
    4640:	df 91       	pop	r29
    4642:	08 95       	ret

00004644 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    4644:	df 93       	push	r29
    4646:	cf 93       	push	r28
    4648:	00 d0       	rcall	.+0      	; 0x464a <prvCopyDataFromQueue+0x6>
    464a:	00 d0       	rcall	.+0      	; 0x464c <prvCopyDataFromQueue+0x8>
    464c:	cd b7       	in	r28, 0x3d	; 61
    464e:	de b7       	in	r29, 0x3e	; 62
    4650:	9a 83       	std	Y+2, r25	; 0x02
    4652:	89 83       	std	Y+1, r24	; 0x01
    4654:	7c 83       	std	Y+4, r23	; 0x04
    4656:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    4658:	e9 81       	ldd	r30, Y+1	; 0x01
    465a:	fa 81       	ldd	r31, Y+2	; 0x02
    465c:	84 8d       	ldd	r24, Z+28	; 0x1c
    465e:	88 23       	and	r24, r24
    4660:	89 f1       	breq	.+98     	; 0x46c4 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    4662:	e9 81       	ldd	r30, Y+1	; 0x01
    4664:	fa 81       	ldd	r31, Y+2	; 0x02
    4666:	26 81       	ldd	r18, Z+6	; 0x06
    4668:	37 81       	ldd	r19, Z+7	; 0x07
    466a:	e9 81       	ldd	r30, Y+1	; 0x01
    466c:	fa 81       	ldd	r31, Y+2	; 0x02
    466e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4670:	88 2f       	mov	r24, r24
    4672:	90 e0       	ldi	r25, 0x00	; 0
    4674:	82 0f       	add	r24, r18
    4676:	93 1f       	adc	r25, r19
    4678:	e9 81       	ldd	r30, Y+1	; 0x01
    467a:	fa 81       	ldd	r31, Y+2	; 0x02
    467c:	97 83       	std	Z+7, r25	; 0x07
    467e:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    4680:	e9 81       	ldd	r30, Y+1	; 0x01
    4682:	fa 81       	ldd	r31, Y+2	; 0x02
    4684:	26 81       	ldd	r18, Z+6	; 0x06
    4686:	37 81       	ldd	r19, Z+7	; 0x07
    4688:	e9 81       	ldd	r30, Y+1	; 0x01
    468a:	fa 81       	ldd	r31, Y+2	; 0x02
    468c:	84 81       	ldd	r24, Z+4	; 0x04
    468e:	95 81       	ldd	r25, Z+5	; 0x05
    4690:	28 17       	cp	r18, r24
    4692:	39 07       	cpc	r19, r25
    4694:	40 f0       	brcs	.+16     	; 0x46a6 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    4696:	e9 81       	ldd	r30, Y+1	; 0x01
    4698:	fa 81       	ldd	r31, Y+2	; 0x02
    469a:	80 81       	ld	r24, Z
    469c:	91 81       	ldd	r25, Z+1	; 0x01
    469e:	e9 81       	ldd	r30, Y+1	; 0x01
    46a0:	fa 81       	ldd	r31, Y+2	; 0x02
    46a2:	97 83       	std	Z+7, r25	; 0x07
    46a4:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    46a6:	e9 81       	ldd	r30, Y+1	; 0x01
    46a8:	fa 81       	ldd	r31, Y+2	; 0x02
    46aa:	46 81       	ldd	r20, Z+6	; 0x06
    46ac:	57 81       	ldd	r21, Z+7	; 0x07
    46ae:	e9 81       	ldd	r30, Y+1	; 0x01
    46b0:	fa 81       	ldd	r31, Y+2	; 0x02
    46b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    46b4:	28 2f       	mov	r18, r24
    46b6:	30 e0       	ldi	r19, 0x00	; 0
    46b8:	8b 81       	ldd	r24, Y+3	; 0x03
    46ba:	9c 81       	ldd	r25, Y+4	; 0x04
    46bc:	ba 01       	movw	r22, r20
    46be:	a9 01       	movw	r20, r18
    46c0:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <memcpy>
    }
}
    46c4:	0f 90       	pop	r0
    46c6:	0f 90       	pop	r0
    46c8:	0f 90       	pop	r0
    46ca:	0f 90       	pop	r0
    46cc:	cf 91       	pop	r28
    46ce:	df 91       	pop	r29
    46d0:	08 95       	ret

000046d2 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    46d2:	df 93       	push	r29
    46d4:	cf 93       	push	r28
    46d6:	00 d0       	rcall	.+0      	; 0x46d8 <prvUnlockQueue+0x6>
    46d8:	00 d0       	rcall	.+0      	; 0x46da <prvUnlockQueue+0x8>
    46da:	cd b7       	in	r28, 0x3d	; 61
    46dc:	de b7       	in	r29, 0x3e	; 62
    46de:	9c 83       	std	Y+4, r25	; 0x04
    46e0:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    46e2:	0f b6       	in	r0, 0x3f	; 63
    46e4:	f8 94       	cli
    46e6:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    46e8:	eb 81       	ldd	r30, Y+3	; 0x03
    46ea:	fc 81       	ldd	r31, Y+4	; 0x04
    46ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    46ee:	8a 83       	std	Y+2, r24	; 0x02
    46f0:	11 c0       	rjmp	.+34     	; 0x4714 <prvUnlockQueue+0x42>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    46f2:	eb 81       	ldd	r30, Y+3	; 0x03
    46f4:	fc 81       	ldd	r31, Y+4	; 0x04
    46f6:	81 89       	ldd	r24, Z+17	; 0x11
    46f8:	88 23       	and	r24, r24
    46fa:	79 f0       	breq	.+30     	; 0x471a <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    46fc:	8b 81       	ldd	r24, Y+3	; 0x03
    46fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4700:	41 96       	adiw	r24, 0x11	; 17
    4702:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    4706:	88 23       	and	r24, r24
    4708:	11 f0       	breq	.+4      	; 0x470e <prvUnlockQueue+0x3c>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    470a:	0e 94 f7 38 	call	0x71ee	; 0x71ee <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    470e:	8a 81       	ldd	r24, Y+2	; 0x02
    4710:	81 50       	subi	r24, 0x01	; 1
    4712:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    4714:	8a 81       	ldd	r24, Y+2	; 0x02
    4716:	18 16       	cp	r1, r24
    4718:	64 f3       	brlt	.-40     	; 0x46f2 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    471a:	eb 81       	ldd	r30, Y+3	; 0x03
    471c:	fc 81       	ldd	r31, Y+4	; 0x04
    471e:	8f ef       	ldi	r24, 0xFF	; 255
    4720:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    4722:	0f 90       	pop	r0
    4724:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    4726:	0f b6       	in	r0, 0x3f	; 63
    4728:	f8 94       	cli
    472a:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    472c:	eb 81       	ldd	r30, Y+3	; 0x03
    472e:	fc 81       	ldd	r31, Y+4	; 0x04
    4730:	85 8d       	ldd	r24, Z+29	; 0x1d
    4732:	89 83       	std	Y+1, r24	; 0x01
    4734:	11 c0       	rjmp	.+34     	; 0x4758 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4736:	eb 81       	ldd	r30, Y+3	; 0x03
    4738:	fc 81       	ldd	r31, Y+4	; 0x04
    473a:	80 85       	ldd	r24, Z+8	; 0x08
    473c:	88 23       	and	r24, r24
    473e:	79 f0       	breq	.+30     	; 0x475e <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4740:	8b 81       	ldd	r24, Y+3	; 0x03
    4742:	9c 81       	ldd	r25, Y+4	; 0x04
    4744:	08 96       	adiw	r24, 0x08	; 8
    4746:	0e 94 fd 35 	call	0x6bfa	; 0x6bfa <xTaskRemoveFromEventList>
    474a:	88 23       	and	r24, r24
    474c:	11 f0       	breq	.+4      	; 0x4752 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    474e:	0e 94 f7 38 	call	0x71ee	; 0x71ee <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    4752:	89 81       	ldd	r24, Y+1	; 0x01
    4754:	81 50       	subi	r24, 0x01	; 1
    4756:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    4758:	89 81       	ldd	r24, Y+1	; 0x01
    475a:	18 16       	cp	r1, r24
    475c:	64 f3       	brlt	.-40     	; 0x4736 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    475e:	eb 81       	ldd	r30, Y+3	; 0x03
    4760:	fc 81       	ldd	r31, Y+4	; 0x04
    4762:	8f ef       	ldi	r24, 0xFF	; 255
    4764:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    4766:	0f 90       	pop	r0
    4768:	0f be       	out	0x3f, r0	; 63
}
    476a:	0f 90       	pop	r0
    476c:	0f 90       	pop	r0
    476e:	0f 90       	pop	r0
    4770:	0f 90       	pop	r0
    4772:	cf 91       	pop	r28
    4774:	df 91       	pop	r29
    4776:	08 95       	ret

00004778 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    4778:	df 93       	push	r29
    477a:	cf 93       	push	r28
    477c:	00 d0       	rcall	.+0      	; 0x477e <prvIsQueueEmpty+0x6>
    477e:	0f 92       	push	r0
    4780:	cd b7       	in	r28, 0x3d	; 61
    4782:	de b7       	in	r29, 0x3e	; 62
    4784:	9b 83       	std	Y+3, r25	; 0x03
    4786:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    4788:	0f b6       	in	r0, 0x3f	; 63
    478a:	f8 94       	cli
    478c:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    478e:	ea 81       	ldd	r30, Y+2	; 0x02
    4790:	fb 81       	ldd	r31, Y+3	; 0x03
    4792:	82 8d       	ldd	r24, Z+26	; 0x1a
    4794:	88 23       	and	r24, r24
    4796:	19 f4       	brne	.+6      	; 0x479e <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    4798:	81 e0       	ldi	r24, 0x01	; 1
    479a:	89 83       	std	Y+1, r24	; 0x01
    479c:	01 c0       	rjmp	.+2      	; 0x47a0 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    479e:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    47a0:	0f 90       	pop	r0
    47a2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    47a4:	89 81       	ldd	r24, Y+1	; 0x01
}
    47a6:	0f 90       	pop	r0
    47a8:	0f 90       	pop	r0
    47aa:	0f 90       	pop	r0
    47ac:	cf 91       	pop	r28
    47ae:	df 91       	pop	r29
    47b0:	08 95       	ret

000047b2 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    47b2:	df 93       	push	r29
    47b4:	cf 93       	push	r28
    47b6:	00 d0       	rcall	.+0      	; 0x47b8 <xQueueIsQueueEmptyFromISR+0x6>
    47b8:	00 d0       	rcall	.+0      	; 0x47ba <xQueueIsQueueEmptyFromISR+0x8>
    47ba:	0f 92       	push	r0
    47bc:	cd b7       	in	r28, 0x3d	; 61
    47be:	de b7       	in	r29, 0x3e	; 62
    47c0:	9d 83       	std	Y+5, r25	; 0x05
    47c2:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    47c4:	8c 81       	ldd	r24, Y+4	; 0x04
    47c6:	9d 81       	ldd	r25, Y+5	; 0x05
    47c8:	9a 83       	std	Y+2, r25	; 0x02
    47ca:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    47cc:	e9 81       	ldd	r30, Y+1	; 0x01
    47ce:	fa 81       	ldd	r31, Y+2	; 0x02
    47d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    47d2:	88 23       	and	r24, r24
    47d4:	19 f4       	brne	.+6      	; 0x47dc <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    47d6:	81 e0       	ldi	r24, 0x01	; 1
    47d8:	8b 83       	std	Y+3, r24	; 0x03
    47da:	01 c0       	rjmp	.+2      	; 0x47de <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    47dc:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    47de:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    47e0:	0f 90       	pop	r0
    47e2:	0f 90       	pop	r0
    47e4:	0f 90       	pop	r0
    47e6:	0f 90       	pop	r0
    47e8:	0f 90       	pop	r0
    47ea:	cf 91       	pop	r28
    47ec:	df 91       	pop	r29
    47ee:	08 95       	ret

000047f0 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    47f0:	df 93       	push	r29
    47f2:	cf 93       	push	r28
    47f4:	00 d0       	rcall	.+0      	; 0x47f6 <prvIsQueueFull+0x6>
    47f6:	0f 92       	push	r0
    47f8:	cd b7       	in	r28, 0x3d	; 61
    47fa:	de b7       	in	r29, 0x3e	; 62
    47fc:	9b 83       	std	Y+3, r25	; 0x03
    47fe:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    4800:	0f b6       	in	r0, 0x3f	; 63
    4802:	f8 94       	cli
    4804:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4806:	ea 81       	ldd	r30, Y+2	; 0x02
    4808:	fb 81       	ldd	r31, Y+3	; 0x03
    480a:	92 8d       	ldd	r25, Z+26	; 0x1a
    480c:	ea 81       	ldd	r30, Y+2	; 0x02
    480e:	fb 81       	ldd	r31, Y+3	; 0x03
    4810:	83 8d       	ldd	r24, Z+27	; 0x1b
    4812:	98 17       	cp	r25, r24
    4814:	19 f4       	brne	.+6      	; 0x481c <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    4816:	81 e0       	ldi	r24, 0x01	; 1
    4818:	89 83       	std	Y+1, r24	; 0x01
    481a:	01 c0       	rjmp	.+2      	; 0x481e <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    481c:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    481e:	0f 90       	pop	r0
    4820:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4822:	89 81       	ldd	r24, Y+1	; 0x01
}
    4824:	0f 90       	pop	r0
    4826:	0f 90       	pop	r0
    4828:	0f 90       	pop	r0
    482a:	cf 91       	pop	r28
    482c:	df 91       	pop	r29
    482e:	08 95       	ret

00004830 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    4830:	df 93       	push	r29
    4832:	cf 93       	push	r28
    4834:	00 d0       	rcall	.+0      	; 0x4836 <xQueueIsQueueFullFromISR+0x6>
    4836:	00 d0       	rcall	.+0      	; 0x4838 <xQueueIsQueueFullFromISR+0x8>
    4838:	0f 92       	push	r0
    483a:	cd b7       	in	r28, 0x3d	; 61
    483c:	de b7       	in	r29, 0x3e	; 62
    483e:	9d 83       	std	Y+5, r25	; 0x05
    4840:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    4842:	8c 81       	ldd	r24, Y+4	; 0x04
    4844:	9d 81       	ldd	r25, Y+5	; 0x05
    4846:	9a 83       	std	Y+2, r25	; 0x02
    4848:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    484a:	e9 81       	ldd	r30, Y+1	; 0x01
    484c:	fa 81       	ldd	r31, Y+2	; 0x02
    484e:	92 8d       	ldd	r25, Z+26	; 0x1a
    4850:	e9 81       	ldd	r30, Y+1	; 0x01
    4852:	fa 81       	ldd	r31, Y+2	; 0x02
    4854:	83 8d       	ldd	r24, Z+27	; 0x1b
    4856:	98 17       	cp	r25, r24
    4858:	19 f4       	brne	.+6      	; 0x4860 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    485a:	81 e0       	ldi	r24, 0x01	; 1
    485c:	8b 83       	std	Y+3, r24	; 0x03
    485e:	01 c0       	rjmp	.+2      	; 0x4862 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    4860:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    4862:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4864:	0f 90       	pop	r0
    4866:	0f 90       	pop	r0
    4868:	0f 90       	pop	r0
    486a:	0f 90       	pop	r0
    486c:	0f 90       	pop	r0
    486e:	cf 91       	pop	r28
    4870:	df 91       	pop	r29
    4872:	08 95       	ret

00004874 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    4874:	cf 92       	push	r12
    4876:	df 92       	push	r13
    4878:	ef 92       	push	r14
    487a:	ff 92       	push	r15
    487c:	0f 93       	push	r16
    487e:	1f 93       	push	r17
    4880:	df 93       	push	r29
    4882:	cf 93       	push	r28
    4884:	cd b7       	in	r28, 0x3d	; 61
    4886:	de b7       	in	r29, 0x3e	; 62
    4888:	2c 97       	sbiw	r28, 0x0c	; 12
    488a:	0f b6       	in	r0, 0x3f	; 63
    488c:	f8 94       	cli
    488e:	de bf       	out	0x3e, r29	; 62
    4890:	0f be       	out	0x3f, r0	; 63
    4892:	cd bf       	out	0x3d, r28	; 61
    4894:	9d 83       	std	Y+5, r25	; 0x05
    4896:	8c 83       	std	Y+4, r24	; 0x04
    4898:	7f 83       	std	Y+7, r23	; 0x07
    489a:	6e 83       	std	Y+6, r22	; 0x06
    489c:	48 87       	std	Y+8, r20	; 0x08
    489e:	3a 87       	std	Y+10, r19	; 0x0a
    48a0:	29 87       	std	Y+9, r18	; 0x09
    48a2:	1c 87       	std	Y+12, r17	; 0x0c
    48a4:	0b 87       	std	Y+11, r16	; 0x0b

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
    48a6:	88 85       	ldd	r24, Y+8	; 0x08
    48a8:	81 30       	cpi	r24, 0x01	; 1
    48aa:	19 f4       	brne	.+6      	; 0x48b2 <xStreamBufferGenericCreate+0x3e>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    48ac:	81 e0       	ldi	r24, 0x01	; 1
    48ae:	89 83       	std	Y+1, r24	; 0x01
    48b0:	01 c0       	rjmp	.+2      	; 0x48b4 <xStreamBufferGenericCreate+0x40>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
    48b2:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    48b4:	8e 81       	ldd	r24, Y+6	; 0x06
    48b6:	9f 81       	ldd	r25, Y+7	; 0x07
    48b8:	00 97       	sbiw	r24, 0x00	; 0
    48ba:	21 f4       	brne	.+8      	; 0x48c4 <xStreamBufferGenericCreate+0x50>
        {
            xTriggerLevelBytes = ( size_t ) 1;
    48bc:	81 e0       	ldi	r24, 0x01	; 1
    48be:	90 e0       	ldi	r25, 0x00	; 0
    48c0:	9f 83       	std	Y+7, r25	; 0x07
    48c2:	8e 83       	std	Y+6, r24	; 0x06
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    48c4:	8c 81       	ldd	r24, Y+4	; 0x04
    48c6:	9d 81       	ldd	r25, Y+5	; 0x05
    48c8:	9c 01       	movw	r18, r24
    48ca:	20 5f       	subi	r18, 0xF0	; 240
    48cc:	3f 4f       	sbci	r19, 0xFF	; 255
    48ce:	8c 81       	ldd	r24, Y+4	; 0x04
    48d0:	9d 81       	ldd	r25, Y+5	; 0x05
    48d2:	82 17       	cp	r24, r18
    48d4:	93 07       	cpc	r25, r19
    48d6:	68 f4       	brcc	.+26     	; 0x48f2 <xStreamBufferGenericCreate+0x7e>
        {
            xBufferSizeBytes++;
    48d8:	8c 81       	ldd	r24, Y+4	; 0x04
    48da:	9d 81       	ldd	r25, Y+5	; 0x05
    48dc:	01 96       	adiw	r24, 0x01	; 1
    48de:	9d 83       	std	Y+5, r25	; 0x05
    48e0:	8c 83       	std	Y+4, r24	; 0x04
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    48e2:	8c 81       	ldd	r24, Y+4	; 0x04
    48e4:	9d 81       	ldd	r25, Y+5	; 0x05
    48e6:	0f 96       	adiw	r24, 0x0f	; 15
    48e8:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <pvPortMalloc>
    48ec:	9b 83       	std	Y+3, r25	; 0x03
    48ee:	8a 83       	std	Y+2, r24	; 0x02
    48f0:	02 c0       	rjmp	.+4      	; 0x48f6 <xStreamBufferGenericCreate+0x82>
        }
        else
        {
            pucAllocatedMemory = NULL;
    48f2:	1b 82       	std	Y+3, r1	; 0x03
    48f4:	1a 82       	std	Y+2, r1	; 0x02
        }

        if( pucAllocatedMemory != NULL )
    48f6:	8a 81       	ldd	r24, Y+2	; 0x02
    48f8:	9b 81       	ldd	r25, Y+3	; 0x03
    48fa:	00 97       	sbiw	r24, 0x00	; 0
    48fc:	b1 f0       	breq	.+44     	; 0x492a <xStreamBufferGenericCreate+0xb6>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    48fe:	6a 81       	ldd	r22, Y+2	; 0x02
    4900:	7b 81       	ldd	r23, Y+3	; 0x03
    4902:	8a 81       	ldd	r24, Y+2	; 0x02
    4904:	9b 81       	ldd	r25, Y+3	; 0x03
    4906:	9c 01       	movw	r18, r24
    4908:	21 5f       	subi	r18, 0xF1	; 241
    490a:	3f 4f       	sbci	r19, 0xFF	; 255
    490c:	4c 81       	ldd	r20, Y+4	; 0x04
    490e:	5d 81       	ldd	r21, Y+5	; 0x05
    4910:	ee 81       	ldd	r30, Y+6	; 0x06
    4912:	ff 81       	ldd	r31, Y+7	; 0x07
    4914:	a9 85       	ldd	r26, Y+9	; 0x09
    4916:	ba 85       	ldd	r27, Y+10	; 0x0a
    4918:	cb 84       	ldd	r12, Y+11	; 0x0b
    491a:	dc 84       	ldd	r13, Y+12	; 0x0c
    491c:	cb 01       	movw	r24, r22
    491e:	b9 01       	movw	r22, r18
    4920:	9f 01       	movw	r18, r30
    4922:	09 81       	ldd	r16, Y+1	; 0x01
    4924:	7d 01       	movw	r14, r26
    4926:	0e 94 f2 2b 	call	0x57e4	; 0x57e4 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    492a:	8a 81       	ldd	r24, Y+2	; 0x02
    492c:	9b 81       	ldd	r25, Y+3	; 0x03
    }
    492e:	2c 96       	adiw	r28, 0x0c	; 12
    4930:	0f b6       	in	r0, 0x3f	; 63
    4932:	f8 94       	cli
    4934:	de bf       	out	0x3e, r29	; 62
    4936:	0f be       	out	0x3f, r0	; 63
    4938:	cd bf       	out	0x3d, r28	; 61
    493a:	cf 91       	pop	r28
    493c:	df 91       	pop	r29
    493e:	1f 91       	pop	r17
    4940:	0f 91       	pop	r16
    4942:	ff 90       	pop	r15
    4944:	ef 90       	pop	r14
    4946:	df 90       	pop	r13
    4948:	cf 90       	pop	r12
    494a:	08 95       	ret

0000494c <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    494c:	df 93       	push	r29
    494e:	cf 93       	push	r28
    4950:	00 d0       	rcall	.+0      	; 0x4952 <vStreamBufferDelete+0x6>
    4952:	00 d0       	rcall	.+0      	; 0x4954 <vStreamBufferDelete+0x8>
    4954:	cd b7       	in	r28, 0x3d	; 61
    4956:	de b7       	in	r29, 0x3e	; 62
    4958:	9c 83       	std	Y+4, r25	; 0x04
    495a:	8b 83       	std	Y+3, r24	; 0x03
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    495c:	8b 81       	ldd	r24, Y+3	; 0x03
    495e:	9c 81       	ldd	r25, Y+4	; 0x04
    4960:	9a 83       	std	Y+2, r25	; 0x02
    4962:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    4964:	e9 81       	ldd	r30, Y+1	; 0x01
    4966:	fa 81       	ldd	r31, Y+2	; 0x02
    4968:	86 85       	ldd	r24, Z+14	; 0x0e
    496a:	88 2f       	mov	r24, r24
    496c:	90 e0       	ldi	r25, 0x00	; 0
    496e:	82 70       	andi	r24, 0x02	; 2
    4970:	90 70       	andi	r25, 0x00	; 0
    4972:	00 97       	sbiw	r24, 0x00	; 0
    4974:	29 f4       	brne	.+10     	; 0x4980 <vStreamBufferDelete+0x34>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    4976:	89 81       	ldd	r24, Y+1	; 0x01
    4978:	9a 81       	ldd	r25, Y+2	; 0x02
    497a:	0e 94 b4 17 	call	0x2f68	; 0x2f68 <vPortFree>
    497e:	08 c0       	rjmp	.+16     	; 0x4990 <vStreamBufferDelete+0x44>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    4980:	89 81       	ldd	r24, Y+1	; 0x01
    4982:	9a 81       	ldd	r25, Y+2	; 0x02
    4984:	60 e0       	ldi	r22, 0x00	; 0
    4986:	70 e0       	ldi	r23, 0x00	; 0
    4988:	4f e0       	ldi	r20, 0x0F	; 15
    498a:	50 e0       	ldi	r21, 0x00	; 0
    498c:	0e 94 ad 4d 	call	0x9b5a	; 0x9b5a <memset>
    }
}
    4990:	0f 90       	pop	r0
    4992:	0f 90       	pop	r0
    4994:	0f 90       	pop	r0
    4996:	0f 90       	pop	r0
    4998:	cf 91       	pop	r28
    499a:	df 91       	pop	r29
    499c:	08 95       	ret

0000499e <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    499e:	cf 92       	push	r12
    49a0:	df 92       	push	r13
    49a2:	ef 92       	push	r14
    49a4:	ff 92       	push	r15
    49a6:	0f 93       	push	r16
    49a8:	1f 93       	push	r17
    49aa:	df 93       	push	r29
    49ac:	cf 93       	push	r28
    49ae:	cd b7       	in	r28, 0x3d	; 61
    49b0:	de b7       	in	r29, 0x3e	; 62
    49b2:	29 97       	sbiw	r28, 0x09	; 9
    49b4:	0f b6       	in	r0, 0x3f	; 63
    49b6:	f8 94       	cli
    49b8:	de bf       	out	0x3e, r29	; 62
    49ba:	0f be       	out	0x3f, r0	; 63
    49bc:	cd bf       	out	0x3d, r28	; 61
    49be:	99 87       	std	Y+9, r25	; 0x09
    49c0:	88 87       	std	Y+8, r24	; 0x08
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    49c2:	88 85       	ldd	r24, Y+8	; 0x08
    49c4:	99 85       	ldd	r25, Y+9	; 0x09
    49c6:	9f 83       	std	Y+7, r25	; 0x07
    49c8:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn = pdFAIL;
    49ca:	1d 82       	std	Y+5, r1	; 0x05
    StreamBufferCallbackFunction_t pxSendCallback = NULL, pxReceiveCallback = NULL;
    49cc:	1c 82       	std	Y+4, r1	; 0x04
    49ce:	1b 82       	std	Y+3, r1	; 0x03
    49d0:	1a 82       	std	Y+2, r1	; 0x02
    49d2:	19 82       	std	Y+1, r1	; 0x01
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    49d4:	0f b6       	in	r0, 0x3f	; 63
    49d6:	f8 94       	cli
    49d8:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    49da:	ee 81       	ldd	r30, Y+6	; 0x06
    49dc:	ff 81       	ldd	r31, Y+7	; 0x07
    49de:	80 85       	ldd	r24, Z+8	; 0x08
    49e0:	91 85       	ldd	r25, Z+9	; 0x09
    49e2:	00 97       	sbiw	r24, 0x00	; 0
    49e4:	21 f5       	brne	.+72     	; 0x4a2e <xStreamBufferReset+0x90>
    49e6:	ee 81       	ldd	r30, Y+6	; 0x06
    49e8:	ff 81       	ldd	r31, Y+7	; 0x07
    49ea:	82 85       	ldd	r24, Z+10	; 0x0a
    49ec:	93 85       	ldd	r25, Z+11	; 0x0b
    49ee:	00 97       	sbiw	r24, 0x00	; 0
    49f0:	f1 f4       	brne	.+60     	; 0x4a2e <xStreamBufferReset+0x90>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    49f2:	ee 81       	ldd	r30, Y+6	; 0x06
    49f4:	ff 81       	ldd	r31, Y+7	; 0x07
    49f6:	44 85       	ldd	r20, Z+12	; 0x0c
    49f8:	55 85       	ldd	r21, Z+13	; 0x0d
    49fa:	ee 81       	ldd	r30, Y+6	; 0x06
    49fc:	ff 81       	ldd	r31, Y+7	; 0x07
    49fe:	24 81       	ldd	r18, Z+4	; 0x04
    4a00:	35 81       	ldd	r19, Z+5	; 0x05
    4a02:	ee 81       	ldd	r30, Y+6	; 0x06
    4a04:	ff 81       	ldd	r31, Y+7	; 0x07
    4a06:	a6 81       	ldd	r26, Z+6	; 0x06
    4a08:	b7 81       	ldd	r27, Z+7	; 0x07
    4a0a:	ee 81       	ldd	r30, Y+6	; 0x06
    4a0c:	ff 81       	ldd	r31, Y+7	; 0x07
    4a0e:	16 85       	ldd	r17, Z+14	; 0x0e
    4a10:	8e 81       	ldd	r24, Y+6	; 0x06
    4a12:	9f 81       	ldd	r25, Y+7	; 0x07
    4a14:	eb 81       	ldd	r30, Y+3	; 0x03
    4a16:	fc 81       	ldd	r31, Y+4	; 0x04
    4a18:	c9 80       	ldd	r12, Y+1	; 0x01
    4a1a:	da 80       	ldd	r13, Y+2	; 0x02
    4a1c:	ba 01       	movw	r22, r20
    4a1e:	a9 01       	movw	r20, r18
    4a20:	9d 01       	movw	r18, r26
    4a22:	01 2f       	mov	r16, r17
    4a24:	7f 01       	movw	r14, r30
    4a26:	0e 94 f2 2b 	call	0x57e4	; 0x57e4 <prvInitialiseNewStreamBuffer>
            }
            #endif

            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
    4a2a:	81 e0       	ldi	r24, 0x01	; 1
    4a2c:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4a2e:	0f 90       	pop	r0
    4a30:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4a32:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4a34:	29 96       	adiw	r28, 0x09	; 9
    4a36:	0f b6       	in	r0, 0x3f	; 63
    4a38:	f8 94       	cli
    4a3a:	de bf       	out	0x3e, r29	; 62
    4a3c:	0f be       	out	0x3f, r0	; 63
    4a3e:	cd bf       	out	0x3d, r28	; 61
    4a40:	cf 91       	pop	r28
    4a42:	df 91       	pop	r29
    4a44:	1f 91       	pop	r17
    4a46:	0f 91       	pop	r16
    4a48:	ff 90       	pop	r15
    4a4a:	ef 90       	pop	r14
    4a4c:	df 90       	pop	r13
    4a4e:	cf 90       	pop	r12
    4a50:	08 95       	ret

00004a52 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    4a52:	df 93       	push	r29
    4a54:	cf 93       	push	r28
    4a56:	cd b7       	in	r28, 0x3d	; 61
    4a58:	de b7       	in	r29, 0x3e	; 62
    4a5a:	27 97       	sbiw	r28, 0x07	; 7
    4a5c:	0f b6       	in	r0, 0x3f	; 63
    4a5e:	f8 94       	cli
    4a60:	de bf       	out	0x3e, r29	; 62
    4a62:	0f be       	out	0x3f, r0	; 63
    4a64:	cd bf       	out	0x3d, r28	; 61
    4a66:	9d 83       	std	Y+5, r25	; 0x05
    4a68:	8c 83       	std	Y+4, r24	; 0x04
    4a6a:	7f 83       	std	Y+7, r23	; 0x07
    4a6c:	6e 83       	std	Y+6, r22	; 0x06
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4a6e:	8c 81       	ldd	r24, Y+4	; 0x04
    4a70:	9d 81       	ldd	r25, Y+5	; 0x05
    4a72:	9b 83       	std	Y+3, r25	; 0x03
    4a74:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    4a76:	8e 81       	ldd	r24, Y+6	; 0x06
    4a78:	9f 81       	ldd	r25, Y+7	; 0x07
    4a7a:	00 97       	sbiw	r24, 0x00	; 0
    4a7c:	21 f4       	brne	.+8      	; 0x4a86 <xStreamBufferSetTriggerLevel+0x34>
    {
        xTriggerLevel = ( size_t ) 1;
    4a7e:	81 e0       	ldi	r24, 0x01	; 1
    4a80:	90 e0       	ldi	r25, 0x00	; 0
    4a82:	9f 83       	std	Y+7, r25	; 0x07
    4a84:	8e 83       	std	Y+6, r24	; 0x06
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    4a86:	ea 81       	ldd	r30, Y+2	; 0x02
    4a88:	fb 81       	ldd	r31, Y+3	; 0x03
    4a8a:	24 81       	ldd	r18, Z+4	; 0x04
    4a8c:	35 81       	ldd	r19, Z+5	; 0x05
    4a8e:	8e 81       	ldd	r24, Y+6	; 0x06
    4a90:	9f 81       	ldd	r25, Y+7	; 0x07
    4a92:	82 17       	cp	r24, r18
    4a94:	93 07       	cpc	r25, r19
    4a96:	48 f4       	brcc	.+18     	; 0x4aaa <xStreamBufferSetTriggerLevel+0x58>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    4a98:	ea 81       	ldd	r30, Y+2	; 0x02
    4a9a:	fb 81       	ldd	r31, Y+3	; 0x03
    4a9c:	8e 81       	ldd	r24, Y+6	; 0x06
    4a9e:	9f 81       	ldd	r25, Y+7	; 0x07
    4aa0:	97 83       	std	Z+7, r25	; 0x07
    4aa2:	86 83       	std	Z+6, r24	; 0x06
        xReturn = pdPASS;
    4aa4:	81 e0       	ldi	r24, 0x01	; 1
    4aa6:	89 83       	std	Y+1, r24	; 0x01
    4aa8:	01 c0       	rjmp	.+2      	; 0x4aac <xStreamBufferSetTriggerLevel+0x5a>
    }
    else
    {
        xReturn = pdFALSE;
    4aaa:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    4aac:	89 81       	ldd	r24, Y+1	; 0x01
}
    4aae:	27 96       	adiw	r28, 0x07	; 7
    4ab0:	0f b6       	in	r0, 0x3f	; 63
    4ab2:	f8 94       	cli
    4ab4:	de bf       	out	0x3e, r29	; 62
    4ab6:	0f be       	out	0x3f, r0	; 63
    4ab8:	cd bf       	out	0x3d, r28	; 61
    4aba:	cf 91       	pop	r28
    4abc:	df 91       	pop	r29
    4abe:	08 95       	ret

00004ac0 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    4ac0:	df 93       	push	r29
    4ac2:	cf 93       	push	r28
    4ac4:	cd b7       	in	r28, 0x3d	; 61
    4ac6:	de b7       	in	r29, 0x3e	; 62
    4ac8:	28 97       	sbiw	r28, 0x08	; 8
    4aca:	0f b6       	in	r0, 0x3f	; 63
    4acc:	f8 94       	cli
    4ace:	de bf       	out	0x3e, r29	; 62
    4ad0:	0f be       	out	0x3f, r0	; 63
    4ad2:	cd bf       	out	0x3d, r28	; 61
    4ad4:	98 87       	std	Y+8, r25	; 0x08
    4ad6:	8f 83       	std	Y+7, r24	; 0x07
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4ad8:	8f 81       	ldd	r24, Y+7	; 0x07
    4ada:	98 85       	ldd	r25, Y+8	; 0x08
    4adc:	9e 83       	std	Y+6, r25	; 0x06
    4ade:	8d 83       	std	Y+5, r24	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    4ae0:	ed 81       	ldd	r30, Y+5	; 0x05
    4ae2:	fe 81       	ldd	r31, Y+6	; 0x06
    4ae4:	80 81       	ld	r24, Z
    4ae6:	91 81       	ldd	r25, Z+1	; 0x01
    4ae8:	9a 83       	std	Y+2, r25	; 0x02
    4aea:	89 83       	std	Y+1, r24	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    4aec:	ed 81       	ldd	r30, Y+5	; 0x05
    4aee:	fe 81       	ldd	r31, Y+6	; 0x06
    4af0:	24 81       	ldd	r18, Z+4	; 0x04
    4af2:	35 81       	ldd	r19, Z+5	; 0x05
    4af4:	ed 81       	ldd	r30, Y+5	; 0x05
    4af6:	fe 81       	ldd	r31, Y+6	; 0x06
    4af8:	80 81       	ld	r24, Z
    4afa:	91 81       	ldd	r25, Z+1	; 0x01
    4afc:	82 0f       	add	r24, r18
    4afe:	93 1f       	adc	r25, r19
    4b00:	9c 83       	std	Y+4, r25	; 0x04
    4b02:	8b 83       	std	Y+3, r24	; 0x03
        xSpace -= pxStreamBuffer->xHead;
    4b04:	ed 81       	ldd	r30, Y+5	; 0x05
    4b06:	fe 81       	ldd	r31, Y+6	; 0x06
    4b08:	22 81       	ldd	r18, Z+2	; 0x02
    4b0a:	33 81       	ldd	r19, Z+3	; 0x03
    4b0c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b0e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b10:	82 1b       	sub	r24, r18
    4b12:	93 0b       	sbc	r25, r19
    4b14:	9c 83       	std	Y+4, r25	; 0x04
    4b16:	8b 83       	std	Y+3, r24	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    4b18:	ed 81       	ldd	r30, Y+5	; 0x05
    4b1a:	fe 81       	ldd	r31, Y+6	; 0x06
    4b1c:	20 81       	ld	r18, Z
    4b1e:	31 81       	ldd	r19, Z+1	; 0x01
    4b20:	89 81       	ldd	r24, Y+1	; 0x01
    4b22:	9a 81       	ldd	r25, Y+2	; 0x02
    4b24:	28 17       	cp	r18, r24
    4b26:	39 07       	cpc	r19, r25
    4b28:	d9 f6       	brne	.-74     	; 0x4ae0 <xStreamBufferSpacesAvailable+0x20>

    xSpace -= ( size_t ) 1;
    4b2a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b2c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b2e:	01 97       	sbiw	r24, 0x01	; 1
    4b30:	9c 83       	std	Y+4, r25	; 0x04
    4b32:	8b 83       	std	Y+3, r24	; 0x03

    if( xSpace >= pxStreamBuffer->xLength )
    4b34:	ed 81       	ldd	r30, Y+5	; 0x05
    4b36:	fe 81       	ldd	r31, Y+6	; 0x06
    4b38:	24 81       	ldd	r18, Z+4	; 0x04
    4b3a:	35 81       	ldd	r19, Z+5	; 0x05
    4b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b40:	82 17       	cp	r24, r18
    4b42:	93 07       	cpc	r25, r19
    4b44:	50 f0       	brcs	.+20     	; 0x4b5a <xStreamBufferSpacesAvailable+0x9a>
    {
        xSpace -= pxStreamBuffer->xLength;
    4b46:	ed 81       	ldd	r30, Y+5	; 0x05
    4b48:	fe 81       	ldd	r31, Y+6	; 0x06
    4b4a:	24 81       	ldd	r18, Z+4	; 0x04
    4b4c:	35 81       	ldd	r19, Z+5	; 0x05
    4b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b50:	9c 81       	ldd	r25, Y+4	; 0x04
    4b52:	82 1b       	sub	r24, r18
    4b54:	93 0b       	sbc	r25, r19
    4b56:	9c 83       	std	Y+4, r25	; 0x04
    4b58:	8b 83       	std	Y+3, r24	; 0x03
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
    4b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b5c:	9c 81       	ldd	r25, Y+4	; 0x04
}
    4b5e:	28 96       	adiw	r28, 0x08	; 8
    4b60:	0f b6       	in	r0, 0x3f	; 63
    4b62:	f8 94       	cli
    4b64:	de bf       	out	0x3e, r29	; 62
    4b66:	0f be       	out	0x3f, r0	; 63
    4b68:	cd bf       	out	0x3d, r28	; 61
    4b6a:	cf 91       	pop	r28
    4b6c:	df 91       	pop	r29
    4b6e:	08 95       	ret

00004b70 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    4b70:	df 93       	push	r29
    4b72:	cf 93       	push	r28
    4b74:	00 d0       	rcall	.+0      	; 0x4b76 <xStreamBufferBytesAvailable+0x6>
    4b76:	00 d0       	rcall	.+0      	; 0x4b78 <xStreamBufferBytesAvailable+0x8>
    4b78:	00 d0       	rcall	.+0      	; 0x4b7a <xStreamBufferBytesAvailable+0xa>
    4b7a:	cd b7       	in	r28, 0x3d	; 61
    4b7c:	de b7       	in	r29, 0x3e	; 62
    4b7e:	9e 83       	std	Y+6, r25	; 0x06
    4b80:	8d 83       	std	Y+5, r24	; 0x05
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4b82:	8d 81       	ldd	r24, Y+5	; 0x05
    4b84:	9e 81       	ldd	r25, Y+6	; 0x06
    4b86:	9c 83       	std	Y+4, r25	; 0x04
    4b88:	8b 83       	std	Y+3, r24	; 0x03
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    4b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b8e:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvBytesInBuffer>
    4b92:	9a 83       	std	Y+2, r25	; 0x02
    4b94:	89 83       	std	Y+1, r24	; 0x01
    return xReturn;
    4b96:	89 81       	ldd	r24, Y+1	; 0x01
    4b98:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4b9a:	26 96       	adiw	r28, 0x06	; 6
    4b9c:	0f b6       	in	r0, 0x3f	; 63
    4b9e:	f8 94       	cli
    4ba0:	de bf       	out	0x3e, r29	; 62
    4ba2:	0f be       	out	0x3f, r0	; 63
    4ba4:	cd bf       	out	0x3d, r28	; 61
    4ba6:	cf 91       	pop	r28
    4ba8:	df 91       	pop	r29
    4baa:	08 95       	ret

00004bac <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    4bac:	cf 92       	push	r12
    4bae:	df 92       	push	r13
    4bb0:	ef 92       	push	r14
    4bb2:	ff 92       	push	r15
    4bb4:	0f 93       	push	r16
    4bb6:	1f 93       	push	r17
    4bb8:	df 93       	push	r29
    4bba:	cf 93       	push	r28
    4bbc:	cd b7       	in	r28, 0x3d	; 61
    4bbe:	de b7       	in	r29, 0x3e	; 62
    4bc0:	65 97       	sbiw	r28, 0x15	; 21
    4bc2:	0f b6       	in	r0, 0x3f	; 63
    4bc4:	f8 94       	cli
    4bc6:	de bf       	out	0x3e, r29	; 62
    4bc8:	0f be       	out	0x3f, r0	; 63
    4bca:	cd bf       	out	0x3d, r28	; 61
    4bcc:	9f 87       	std	Y+15, r25	; 0x0f
    4bce:	8e 87       	std	Y+14, r24	; 0x0e
    4bd0:	79 8b       	std	Y+17, r23	; 0x11
    4bd2:	68 8b       	std	Y+16, r22	; 0x10
    4bd4:	5b 8b       	std	Y+19, r21	; 0x13
    4bd6:	4a 8b       	std	Y+18, r20	; 0x12
    4bd8:	3d 8b       	std	Y+21, r19	; 0x15
    4bda:	2c 8b       	std	Y+20, r18	; 0x14
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4bdc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4bde:	9f 85       	ldd	r25, Y+15	; 0x0f
    4be0:	9a 87       	std	Y+10, r25	; 0x0a
    4be2:	89 87       	std	Y+9, r24	; 0x09
    size_t xReturn, xSpace = 0;
    4be4:	1e 82       	std	Y+6, r1	; 0x06
    4be6:	1d 82       	std	Y+5, r1	; 0x05
    size_t xRequiredSpace = xDataLengthBytes;
    4be8:	8a 89       	ldd	r24, Y+18	; 0x12
    4bea:	9b 89       	ldd	r25, Y+19	; 0x13
    4bec:	9c 83       	std	Y+4, r25	; 0x04
    4bee:	8b 83       	std	Y+3, r24	; 0x03
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
    4bf0:	1a 82       	std	Y+2, r1	; 0x02
    4bf2:	19 82       	std	Y+1, r1	; 0x01
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    4bf4:	e9 85       	ldd	r30, Y+9	; 0x09
    4bf6:	fa 85       	ldd	r31, Y+10	; 0x0a
    4bf8:	84 81       	ldd	r24, Z+4	; 0x04
    4bfa:	95 81       	ldd	r25, Z+5	; 0x05
    4bfc:	01 97       	sbiw	r24, 0x01	; 1
    4bfe:	9a 83       	std	Y+2, r25	; 0x02
    4c00:	89 83       	std	Y+1, r24	; 0x01

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4c02:	e9 85       	ldd	r30, Y+9	; 0x09
    4c04:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c06:	86 85       	ldd	r24, Z+14	; 0x0e
    4c08:	88 2f       	mov	r24, r24
    4c0a:	90 e0       	ldi	r25, 0x00	; 0
    4c0c:	81 70       	andi	r24, 0x01	; 1
    4c0e:	90 70       	andi	r25, 0x00	; 0
    4c10:	88 23       	and	r24, r24
    4c12:	79 f0       	breq	.+30     	; 0x4c32 <xStreamBufferSend+0x86>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4c14:	8b 81       	ldd	r24, Y+3	; 0x03
    4c16:	9c 81       	ldd	r25, Y+4	; 0x04
    4c18:	02 96       	adiw	r24, 0x02	; 2
    4c1a:	9c 83       	std	Y+4, r25	; 0x04
    4c1c:	8b 83       	std	Y+3, r24	; 0x03
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    4c1e:	2b 81       	ldd	r18, Y+3	; 0x03
    4c20:	3c 81       	ldd	r19, Y+4	; 0x04
    4c22:	89 81       	ldd	r24, Y+1	; 0x01
    4c24:	9a 81       	ldd	r25, Y+2	; 0x02
    4c26:	82 17       	cp	r24, r18
    4c28:	93 07       	cpc	r25, r19
    4c2a:	70 f4       	brcc	.+28     	; 0x4c48 <xStreamBufferSend+0x9c>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    4c2c:	1d 8a       	std	Y+21, r1	; 0x15
    4c2e:	1c 8a       	std	Y+20, r1	; 0x14
    4c30:	0b c0       	rjmp	.+22     	; 0x4c48 <xStreamBufferSend+0x9c>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    4c32:	2b 81       	ldd	r18, Y+3	; 0x03
    4c34:	3c 81       	ldd	r19, Y+4	; 0x04
    4c36:	89 81       	ldd	r24, Y+1	; 0x01
    4c38:	9a 81       	ldd	r25, Y+2	; 0x02
    4c3a:	82 17       	cp	r24, r18
    4c3c:	93 07       	cpc	r25, r19
    4c3e:	20 f4       	brcc	.+8      	; 0x4c48 <xStreamBufferSend+0x9c>
        {
            xRequiredSpace = xMaxReportedSpace;
    4c40:	89 81       	ldd	r24, Y+1	; 0x01
    4c42:	9a 81       	ldd	r25, Y+2	; 0x02
    4c44:	9c 83       	std	Y+4, r25	; 0x04
    4c46:	8b 83       	std	Y+3, r24	; 0x03
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    4c48:	8c 89       	ldd	r24, Y+20	; 0x14
    4c4a:	9d 89       	ldd	r25, Y+21	; 0x15
    4c4c:	00 97       	sbiw	r24, 0x00	; 0
    4c4e:	09 f4       	brne	.+2      	; 0x4c52 <xStreamBufferSend+0xa6>
    4c50:	43 c0       	rjmp	.+134    	; 0x4cd8 <xStreamBufferSend+0x12c>
    {
        vTaskSetTimeOutState( &xTimeOut );
    4c52:	ce 01       	movw	r24, r28
    4c54:	0b 96       	adiw	r24, 0x0b	; 11
    4c56:	0e 94 4f 38 	call	0x709e	; 0x709e <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    4c5a:	0f b6       	in	r0, 0x3f	; 63
    4c5c:	f8 94       	cli
    4c5e:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    4c60:	89 85       	ldd	r24, Y+9	; 0x09
    4c62:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c64:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <xStreamBufferSpacesAvailable>
    4c68:	9e 83       	std	Y+6, r25	; 0x06
    4c6a:	8d 83       	std	Y+5, r24	; 0x05

                if( xSpace < xRequiredSpace )
    4c6c:	2d 81       	ldd	r18, Y+5	; 0x05
    4c6e:	3e 81       	ldd	r19, Y+6	; 0x06
    4c70:	8b 81       	ldd	r24, Y+3	; 0x03
    4c72:	9c 81       	ldd	r25, Y+4	; 0x04
    4c74:	28 17       	cp	r18, r24
    4c76:	39 07       	cpc	r19, r25
    4c78:	68 f5       	brcc	.+90     	; 0x4cd4 <xStreamBufferSend+0x128>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    4c7a:	80 e0       	ldi	r24, 0x00	; 0
    4c7c:	90 e0       	ldi	r25, 0x00	; 0
    4c7e:	60 e0       	ldi	r22, 0x00	; 0
    4c80:	0e 94 39 43 	call	0x8672	; 0x8672 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    4c84:	0e 94 b9 39 	call	0x7372	; 0x7372 <xTaskGetCurrentTaskHandle>
    4c88:	e9 85       	ldd	r30, Y+9	; 0x09
    4c8a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c8c:	93 87       	std	Z+11, r25	; 0x0b
    4c8e:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    4c90:	0f 90       	pop	r0
    4c92:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    4c94:	ec 89       	ldd	r30, Y+20	; 0x14
    4c96:	fd 89       	ldd	r31, Y+21	; 0x15
    4c98:	80 e0       	ldi	r24, 0x00	; 0
    4c9a:	40 e0       	ldi	r20, 0x00	; 0
    4c9c:	50 e0       	ldi	r21, 0x00	; 0
    4c9e:	60 e0       	ldi	r22, 0x00	; 0
    4ca0:	70 e0       	ldi	r23, 0x00	; 0
    4ca2:	00 e0       	ldi	r16, 0x00	; 0
    4ca4:	10 e0       	ldi	r17, 0x00	; 0
    4ca6:	20 e0       	ldi	r18, 0x00	; 0
    4ca8:	30 e0       	ldi	r19, 0x00	; 0
    4caa:	ee 24       	eor	r14, r14
    4cac:	ff 24       	eor	r15, r15
    4cae:	6f 01       	movw	r12, r30
    4cb0:	0e 94 35 3d 	call	0x7a6a	; 0x7a6a <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    4cb4:	e9 85       	ldd	r30, Y+9	; 0x09
    4cb6:	fa 85       	ldd	r31, Y+10	; 0x0a
    4cb8:	13 86       	std	Z+11, r1	; 0x0b
    4cba:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    4cbc:	ce 01       	movw	r24, r28
    4cbe:	0b 96       	adiw	r24, 0x0b	; 11
    4cc0:	9e 01       	movw	r18, r28
    4cc2:	2c 5e       	subi	r18, 0xEC	; 236
    4cc4:	3f 4f       	sbci	r19, 0xFF	; 255
    4cc6:	b9 01       	movw	r22, r18
    4cc8:	0e 94 86 38 	call	0x710c	; 0x710c <xTaskCheckForTimeOut>
    4ccc:	88 23       	and	r24, r24
    4cce:	09 f4       	brne	.+2      	; 0x4cd2 <xStreamBufferSend+0x126>
    4cd0:	c4 cf       	rjmp	.-120    	; 0x4c5a <xStreamBufferSend+0xae>
    4cd2:	02 c0       	rjmp	.+4      	; 0x4cd8 <xStreamBufferSend+0x12c>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    4cd4:	0f 90       	pop	r0
    4cd6:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    4cd8:	8d 81       	ldd	r24, Y+5	; 0x05
    4cda:	9e 81       	ldd	r25, Y+6	; 0x06
    4cdc:	00 97       	sbiw	r24, 0x00	; 0
    4cde:	31 f4       	brne	.+12     	; 0x4cec <xStreamBufferSend+0x140>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    4ce0:	89 85       	ldd	r24, Y+9	; 0x09
    4ce2:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ce4:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <xStreamBufferSpacesAvailable>
    4ce8:	9e 83       	std	Y+6, r25	; 0x06
    4cea:	8d 83       	std	Y+5, r24	; 0x05
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    4cec:	89 85       	ldd	r24, Y+9	; 0x09
    4cee:	9a 85       	ldd	r25, Y+10	; 0x0a
    4cf0:	28 89       	ldd	r18, Y+16	; 0x10
    4cf2:	39 89       	ldd	r19, Y+17	; 0x11
    4cf4:	4a 89       	ldd	r20, Y+18	; 0x12
    4cf6:	5b 89       	ldd	r21, Y+19	; 0x13
    4cf8:	ed 81       	ldd	r30, Y+5	; 0x05
    4cfa:	fe 81       	ldd	r31, Y+6	; 0x06
    4cfc:	ab 81       	ldd	r26, Y+3	; 0x03
    4cfe:	bc 81       	ldd	r27, Y+4	; 0x04
    4d00:	b9 01       	movw	r22, r18
    4d02:	9f 01       	movw	r18, r30
    4d04:	8d 01       	movw	r16, r26
    4d06:	0e 94 46 27 	call	0x4e8c	; 0x4e8c <prvWriteMessageToBuffer>
    4d0a:	98 87       	std	Y+8, r25	; 0x08
    4d0c:	8f 83       	std	Y+7, r24	; 0x07

    if( xReturn > ( size_t ) 0 )
    4d0e:	8f 81       	ldd	r24, Y+7	; 0x07
    4d10:	98 85       	ldd	r25, Y+8	; 0x08
    4d12:	00 97       	sbiw	r24, 0x00	; 0
    4d14:	41 f1       	breq	.+80     	; 0x4d66 <xStreamBufferSend+0x1ba>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    4d16:	89 85       	ldd	r24, Y+9	; 0x09
    4d18:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d1a:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvBytesInBuffer>
    4d1e:	9c 01       	movw	r18, r24
    4d20:	e9 85       	ldd	r30, Y+9	; 0x09
    4d22:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d24:	86 81       	ldd	r24, Z+6	; 0x06
    4d26:	97 81       	ldd	r25, Z+7	; 0x07
    4d28:	28 17       	cp	r18, r24
    4d2a:	39 07       	cpc	r19, r25
    4d2c:	e0 f0       	brcs	.+56     	; 0x4d66 <xStreamBufferSend+0x1ba>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    4d2e:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
    4d32:	e9 85       	ldd	r30, Y+9	; 0x09
    4d34:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d36:	80 85       	ldd	r24, Z+8	; 0x08
    4d38:	91 85       	ldd	r25, Z+9	; 0x09
    4d3a:	00 97       	sbiw	r24, 0x00	; 0
    4d3c:	91 f0       	breq	.+36     	; 0x4d62 <xStreamBufferSend+0x1b6>
    4d3e:	e9 85       	ldd	r30, Y+9	; 0x09
    4d40:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d42:	80 85       	ldd	r24, Z+8	; 0x08
    4d44:	91 85       	ldd	r25, Z+9	; 0x09
    4d46:	60 e0       	ldi	r22, 0x00	; 0
    4d48:	20 e0       	ldi	r18, 0x00	; 0
    4d4a:	30 e0       	ldi	r19, 0x00	; 0
    4d4c:	40 e0       	ldi	r20, 0x00	; 0
    4d4e:	50 e0       	ldi	r21, 0x00	; 0
    4d50:	00 e0       	ldi	r16, 0x00	; 0
    4d52:	ee 24       	eor	r14, r14
    4d54:	ff 24       	eor	r15, r15
    4d56:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <xTaskGenericNotify>
    4d5a:	e9 85       	ldd	r30, Y+9	; 0x09
    4d5c:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d5e:	11 86       	std	Z+9, r1	; 0x09
    4d60:	10 86       	std	Z+8, r1	; 0x08
    4d62:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
    4d66:	8f 81       	ldd	r24, Y+7	; 0x07
    4d68:	98 85       	ldd	r25, Y+8	; 0x08
}
    4d6a:	65 96       	adiw	r28, 0x15	; 21
    4d6c:	0f b6       	in	r0, 0x3f	; 63
    4d6e:	f8 94       	cli
    4d70:	de bf       	out	0x3e, r29	; 62
    4d72:	0f be       	out	0x3f, r0	; 63
    4d74:	cd bf       	out	0x3d, r28	; 61
    4d76:	cf 91       	pop	r28
    4d78:	df 91       	pop	r29
    4d7a:	1f 91       	pop	r17
    4d7c:	0f 91       	pop	r16
    4d7e:	ff 90       	pop	r15
    4d80:	ef 90       	pop	r14
    4d82:	df 90       	pop	r13
    4d84:	cf 90       	pop	r12
    4d86:	08 95       	ret

00004d88 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    4d88:	cf 92       	push	r12
    4d8a:	df 92       	push	r13
    4d8c:	ef 92       	push	r14
    4d8e:	ff 92       	push	r15
    4d90:	0f 93       	push	r16
    4d92:	1f 93       	push	r17
    4d94:	df 93       	push	r29
    4d96:	cf 93       	push	r28
    4d98:	cd b7       	in	r28, 0x3d	; 61
    4d9a:	de b7       	in	r29, 0x3e	; 62
    4d9c:	61 97       	sbiw	r28, 0x11	; 17
    4d9e:	0f b6       	in	r0, 0x3f	; 63
    4da0:	f8 94       	cli
    4da2:	de bf       	out	0x3e, r29	; 62
    4da4:	0f be       	out	0x3f, r0	; 63
    4da6:	cd bf       	out	0x3d, r28	; 61
    4da8:	9b 87       	std	Y+11, r25	; 0x0b
    4daa:	8a 87       	std	Y+10, r24	; 0x0a
    4dac:	7d 87       	std	Y+13, r23	; 0x0d
    4dae:	6c 87       	std	Y+12, r22	; 0x0c
    4db0:	5f 87       	std	Y+15, r21	; 0x0f
    4db2:	4e 87       	std	Y+14, r20	; 0x0e
    4db4:	39 8b       	std	Y+17, r19	; 0x11
    4db6:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4db8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4dba:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dbc:	99 87       	std	Y+9, r25	; 0x09
    4dbe:	88 87       	std	Y+8, r24	; 0x08
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
    4dc0:	8e 85       	ldd	r24, Y+14	; 0x0e
    4dc2:	9f 85       	ldd	r25, Y+15	; 0x0f
    4dc4:	9b 83       	std	Y+3, r25	; 0x03
    4dc6:	8a 83       	std	Y+2, r24	; 0x02

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4dc8:	e8 85       	ldd	r30, Y+8	; 0x08
    4dca:	f9 85       	ldd	r31, Y+9	; 0x09
    4dcc:	86 85       	ldd	r24, Z+14	; 0x0e
    4dce:	88 2f       	mov	r24, r24
    4dd0:	90 e0       	ldi	r25, 0x00	; 0
    4dd2:	81 70       	andi	r24, 0x01	; 1
    4dd4:	90 70       	andi	r25, 0x00	; 0
    4dd6:	88 23       	and	r24, r24
    4dd8:	29 f0       	breq	.+10     	; 0x4de4 <xStreamBufferSendFromISR+0x5c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4dda:	8a 81       	ldd	r24, Y+2	; 0x02
    4ddc:	9b 81       	ldd	r25, Y+3	; 0x03
    4dde:	02 96       	adiw	r24, 0x02	; 2
    4de0:	9b 83       	std	Y+3, r25	; 0x03
    4de2:	8a 83       	std	Y+2, r24	; 0x02
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    4de4:	88 85       	ldd	r24, Y+8	; 0x08
    4de6:	99 85       	ldd	r25, Y+9	; 0x09
    4de8:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <xStreamBufferSpacesAvailable>
    4dec:	9d 83       	std	Y+5, r25	; 0x05
    4dee:	8c 83       	std	Y+4, r24	; 0x04
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    4df0:	88 85       	ldd	r24, Y+8	; 0x08
    4df2:	99 85       	ldd	r25, Y+9	; 0x09
    4df4:	2c 85       	ldd	r18, Y+12	; 0x0c
    4df6:	3d 85       	ldd	r19, Y+13	; 0x0d
    4df8:	4e 85       	ldd	r20, Y+14	; 0x0e
    4dfa:	5f 85       	ldd	r21, Y+15	; 0x0f
    4dfc:	ec 81       	ldd	r30, Y+4	; 0x04
    4dfe:	fd 81       	ldd	r31, Y+5	; 0x05
    4e00:	aa 81       	ldd	r26, Y+2	; 0x02
    4e02:	bb 81       	ldd	r27, Y+3	; 0x03
    4e04:	b9 01       	movw	r22, r18
    4e06:	9f 01       	movw	r18, r30
    4e08:	8d 01       	movw	r16, r26
    4e0a:	0e 94 46 27 	call	0x4e8c	; 0x4e8c <prvWriteMessageToBuffer>
    4e0e:	9f 83       	std	Y+7, r25	; 0x07
    4e10:	8e 83       	std	Y+6, r24	; 0x06

    if( xReturn > ( size_t ) 0 )
    4e12:	8e 81       	ldd	r24, Y+6	; 0x06
    4e14:	9f 81       	ldd	r25, Y+7	; 0x07
    4e16:	00 97       	sbiw	r24, 0x00	; 0
    4e18:	41 f1       	breq	.+80     	; 0x4e6a <xStreamBufferSendFromISR+0xe2>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    4e1a:	88 85       	ldd	r24, Y+8	; 0x08
    4e1c:	99 85       	ldd	r25, Y+9	; 0x09
    4e1e:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvBytesInBuffer>
    4e22:	9c 01       	movw	r18, r24
    4e24:	e8 85       	ldd	r30, Y+8	; 0x08
    4e26:	f9 85       	ldd	r31, Y+9	; 0x09
    4e28:	86 81       	ldd	r24, Z+6	; 0x06
    4e2a:	97 81       	ldd	r25, Z+7	; 0x07
    4e2c:	28 17       	cp	r18, r24
    4e2e:	39 07       	cpc	r19, r25
    4e30:	e0 f0       	brcs	.+56     	; 0x4e6a <xStreamBufferSendFromISR+0xe2>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4e32:	19 82       	std	Y+1, r1	; 0x01
    4e34:	e8 85       	ldd	r30, Y+8	; 0x08
    4e36:	f9 85       	ldd	r31, Y+9	; 0x09
    4e38:	80 85       	ldd	r24, Z+8	; 0x08
    4e3a:	91 85       	ldd	r25, Z+9	; 0x09
    4e3c:	00 97       	sbiw	r24, 0x00	; 0
    4e3e:	a9 f0       	breq	.+42     	; 0x4e6a <xStreamBufferSendFromISR+0xe2>
    4e40:	e8 85       	ldd	r30, Y+8	; 0x08
    4e42:	f9 85       	ldd	r31, Y+9	; 0x09
    4e44:	80 85       	ldd	r24, Z+8	; 0x08
    4e46:	91 85       	ldd	r25, Z+9	; 0x09
    4e48:	e8 89       	ldd	r30, Y+16	; 0x10
    4e4a:	f9 89       	ldd	r31, Y+17	; 0x11
    4e4c:	60 e0       	ldi	r22, 0x00	; 0
    4e4e:	20 e0       	ldi	r18, 0x00	; 0
    4e50:	30 e0       	ldi	r19, 0x00	; 0
    4e52:	40 e0       	ldi	r20, 0x00	; 0
    4e54:	50 e0       	ldi	r21, 0x00	; 0
    4e56:	00 e0       	ldi	r16, 0x00	; 0
    4e58:	ee 24       	eor	r14, r14
    4e5a:	ff 24       	eor	r15, r15
    4e5c:	6f 01       	movw	r12, r30
    4e5e:	0e 94 ea 3f 	call	0x7fd4	; 0x7fd4 <xTaskGenericNotifyFromISR>
    4e62:	e8 85       	ldd	r30, Y+8	; 0x08
    4e64:	f9 85       	ldd	r31, Y+9	; 0x09
    4e66:	11 86       	std	Z+9, r1	; 0x09
    4e68:	10 86       	std	Z+8, r1	; 0x08
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
    4e6a:	8e 81       	ldd	r24, Y+6	; 0x06
    4e6c:	9f 81       	ldd	r25, Y+7	; 0x07
}
    4e6e:	61 96       	adiw	r28, 0x11	; 17
    4e70:	0f b6       	in	r0, 0x3f	; 63
    4e72:	f8 94       	cli
    4e74:	de bf       	out	0x3e, r29	; 62
    4e76:	0f be       	out	0x3f, r0	; 63
    4e78:	cd bf       	out	0x3d, r28	; 61
    4e7a:	cf 91       	pop	r28
    4e7c:	df 91       	pop	r29
    4e7e:	1f 91       	pop	r17
    4e80:	0f 91       	pop	r16
    4e82:	ff 90       	pop	r15
    4e84:	ef 90       	pop	r14
    4e86:	df 90       	pop	r13
    4e88:	cf 90       	pop	r12
    4e8a:	08 95       	ret

00004e8c <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    4e8c:	0f 93       	push	r16
    4e8e:	1f 93       	push	r17
    4e90:	df 93       	push	r29
    4e92:	cf 93       	push	r28
    4e94:	cd b7       	in	r28, 0x3d	; 61
    4e96:	de b7       	in	r29, 0x3e	; 62
    4e98:	62 97       	sbiw	r28, 0x12	; 18
    4e9a:	0f b6       	in	r0, 0x3f	; 63
    4e9c:	f8 94       	cli
    4e9e:	de bf       	out	0x3e, r29	; 62
    4ea0:	0f be       	out	0x3f, r0	; 63
    4ea2:	cd bf       	out	0x3d, r28	; 61
    4ea4:	9e 83       	std	Y+6, r25	; 0x06
    4ea6:	8d 83       	std	Y+5, r24	; 0x05
    4ea8:	78 87       	std	Y+8, r23	; 0x08
    4eaa:	6f 83       	std	Y+7, r22	; 0x07
    4eac:	5a 87       	std	Y+10, r21	; 0x0a
    4eae:	49 87       	std	Y+9, r20	; 0x09
    4eb0:	3c 87       	std	Y+12, r19	; 0x0c
    4eb2:	2b 87       	std	Y+11, r18	; 0x0b
    4eb4:	1e 87       	std	Y+14, r17	; 0x0e
    4eb6:	0d 87       	std	Y+13, r16	; 0x0d
    size_t xNextHead = pxStreamBuffer->xHead;
    4eb8:	ed 81       	ldd	r30, Y+5	; 0x05
    4eba:	fe 81       	ldd	r31, Y+6	; 0x06
    4ebc:	82 81       	ldd	r24, Z+2	; 0x02
    4ebe:	93 81       	ldd	r25, Z+3	; 0x03
    4ec0:	9a 83       	std	Y+2, r25	; 0x02
    4ec2:	89 83       	std	Y+1, r24	; 0x01
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4ec4:	ed 81       	ldd	r30, Y+5	; 0x05
    4ec6:	fe 81       	ldd	r31, Y+6	; 0x06
    4ec8:	86 85       	ldd	r24, Z+14	; 0x0e
    4eca:	88 2f       	mov	r24, r24
    4ecc:	90 e0       	ldi	r25, 0x00	; 0
    4ece:	81 70       	andi	r24, 0x01	; 1
    4ed0:	90 70       	andi	r25, 0x00	; 0
    4ed2:	88 23       	and	r24, r24
    4ed4:	f1 f0       	breq	.+60     	; 0x4f12 <prvWriteMessageToBuffer+0x86>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    4ed6:	89 85       	ldd	r24, Y+9	; 0x09
    4ed8:	9a 85       	ldd	r25, Y+10	; 0x0a
    4eda:	9c 83       	std	Y+4, r25	; 0x04
    4edc:	8b 83       	std	Y+3, r24	; 0x03

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    4ede:	2b 85       	ldd	r18, Y+11	; 0x0b
    4ee0:	3c 85       	ldd	r19, Y+12	; 0x0c
    4ee2:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ee4:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ee6:	28 17       	cp	r18, r24
    4ee8:	39 07       	cpc	r19, r25
    4eea:	80 f0       	brcs	.+32     	; 0x4f0c <prvWriteMessageToBuffer+0x80>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    4eec:	9e 01       	movw	r18, r28
    4eee:	2d 5f       	subi	r18, 0xFD	; 253
    4ef0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ef2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ef4:	9e 81       	ldd	r25, Y+6	; 0x06
    4ef6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ef8:	fa 81       	ldd	r31, Y+2	; 0x02
    4efa:	b9 01       	movw	r22, r18
    4efc:	42 e0       	ldi	r20, 0x02	; 2
    4efe:	50 e0       	ldi	r21, 0x00	; 0
    4f00:	9f 01       	movw	r18, r30
    4f02:	0e 94 b0 2a 	call	0x5560	; 0x5560 <prvWriteBytesToBuffer>
    4f06:	9a 83       	std	Y+2, r25	; 0x02
    4f08:	89 83       	std	Y+1, r24	; 0x01
    4f0a:	1a c0       	rjmp	.+52     	; 0x4f40 <prvWriteMessageToBuffer+0xb4>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    4f0c:	1a 86       	std	Y+10, r1	; 0x0a
    4f0e:	19 86       	std	Y+9, r1	; 0x09
    4f10:	17 c0       	rjmp	.+46     	; 0x4f40 <prvWriteMessageToBuffer+0xb4>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    4f12:	29 85       	ldd	r18, Y+9	; 0x09
    4f14:	3a 85       	ldd	r19, Y+10	; 0x0a
    4f16:	3a 8b       	std	Y+18, r19	; 0x12
    4f18:	29 8b       	std	Y+17, r18	; 0x11
    4f1a:	8b 85       	ldd	r24, Y+11	; 0x0b
    4f1c:	9c 85       	ldd	r25, Y+12	; 0x0c
    4f1e:	98 8b       	std	Y+16, r25	; 0x10
    4f20:	8f 87       	std	Y+15, r24	; 0x0f
    4f22:	2f 85       	ldd	r18, Y+15	; 0x0f
    4f24:	38 89       	ldd	r19, Y+16	; 0x10
    4f26:	89 89       	ldd	r24, Y+17	; 0x11
    4f28:	9a 89       	ldd	r25, Y+18	; 0x12
    4f2a:	82 17       	cp	r24, r18
    4f2c:	93 07       	cpc	r25, r19
    4f2e:	20 f4       	brcc	.+8      	; 0x4f38 <prvWriteMessageToBuffer+0xac>
    4f30:	29 89       	ldd	r18, Y+17	; 0x11
    4f32:	3a 89       	ldd	r19, Y+18	; 0x12
    4f34:	38 8b       	std	Y+16, r19	; 0x10
    4f36:	2f 87       	std	Y+15, r18	; 0x0f
    4f38:	8f 85       	ldd	r24, Y+15	; 0x0f
    4f3a:	98 89       	ldd	r25, Y+16	; 0x10
    4f3c:	9a 87       	std	Y+10, r25	; 0x0a
    4f3e:	89 87       	std	Y+9, r24	; 0x09
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    4f40:	89 85       	ldd	r24, Y+9	; 0x09
    4f42:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f44:	00 97       	sbiw	r24, 0x00	; 0
    4f46:	89 f0       	breq	.+34     	; 0x4f6a <prvWriteMessageToBuffer+0xde>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    4f48:	4f 81       	ldd	r20, Y+7	; 0x07
    4f4a:	58 85       	ldd	r21, Y+8	; 0x08
    4f4c:	8d 81       	ldd	r24, Y+5	; 0x05
    4f4e:	9e 81       	ldd	r25, Y+6	; 0x06
    4f50:	29 85       	ldd	r18, Y+9	; 0x09
    4f52:	3a 85       	ldd	r19, Y+10	; 0x0a
    4f54:	e9 81       	ldd	r30, Y+1	; 0x01
    4f56:	fa 81       	ldd	r31, Y+2	; 0x02
    4f58:	ba 01       	movw	r22, r20
    4f5a:	a9 01       	movw	r20, r18
    4f5c:	9f 01       	movw	r18, r30
    4f5e:	0e 94 b0 2a 	call	0x5560	; 0x5560 <prvWriteBytesToBuffer>
    4f62:	ed 81       	ldd	r30, Y+5	; 0x05
    4f64:	fe 81       	ldd	r31, Y+6	; 0x06
    4f66:	93 83       	std	Z+3, r25	; 0x03
    4f68:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
    4f6a:	89 85       	ldd	r24, Y+9	; 0x09
    4f6c:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    4f6e:	62 96       	adiw	r28, 0x12	; 18
    4f70:	0f b6       	in	r0, 0x3f	; 63
    4f72:	f8 94       	cli
    4f74:	de bf       	out	0x3e, r29	; 62
    4f76:	0f be       	out	0x3f, r0	; 63
    4f78:	cd bf       	out	0x3d, r28	; 61
    4f7a:	cf 91       	pop	r28
    4f7c:	df 91       	pop	r29
    4f7e:	1f 91       	pop	r17
    4f80:	0f 91       	pop	r16
    4f82:	08 95       	ret

00004f84 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    4f84:	cf 92       	push	r12
    4f86:	df 92       	push	r13
    4f88:	ef 92       	push	r14
    4f8a:	ff 92       	push	r15
    4f8c:	0f 93       	push	r16
    4f8e:	1f 93       	push	r17
    4f90:	df 93       	push	r29
    4f92:	cf 93       	push	r28
    4f94:	cd b7       	in	r28, 0x3d	; 61
    4f96:	de b7       	in	r29, 0x3e	; 62
    4f98:	60 97       	sbiw	r28, 0x10	; 16
    4f9a:	0f b6       	in	r0, 0x3f	; 63
    4f9c:	f8 94       	cli
    4f9e:	de bf       	out	0x3e, r29	; 62
    4fa0:	0f be       	out	0x3f, r0	; 63
    4fa2:	cd bf       	out	0x3d, r28	; 61
    4fa4:	9a 87       	std	Y+10, r25	; 0x0a
    4fa6:	89 87       	std	Y+9, r24	; 0x09
    4fa8:	7c 87       	std	Y+12, r23	; 0x0c
    4faa:	6b 87       	std	Y+11, r22	; 0x0b
    4fac:	5e 87       	std	Y+14, r21	; 0x0e
    4fae:	4d 87       	std	Y+13, r20	; 0x0d
    4fb0:	38 8b       	std	Y+16, r19	; 0x10
    4fb2:	2f 87       	std	Y+15, r18	; 0x0f
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    4fb4:	89 85       	ldd	r24, Y+9	; 0x09
    4fb6:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fb8:	98 87       	std	Y+8, r25	; 0x08
    4fba:	8f 83       	std	Y+7, r24	; 0x07
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    4fbc:	1e 82       	std	Y+6, r1	; 0x06
    4fbe:	1d 82       	std	Y+5, r1	; 0x05
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4fc0:	ef 81       	ldd	r30, Y+7	; 0x07
    4fc2:	f8 85       	ldd	r31, Y+8	; 0x08
    4fc4:	86 85       	ldd	r24, Z+14	; 0x0e
    4fc6:	88 2f       	mov	r24, r24
    4fc8:	90 e0       	ldi	r25, 0x00	; 0
    4fca:	81 70       	andi	r24, 0x01	; 1
    4fcc:	90 70       	andi	r25, 0x00	; 0
    4fce:	88 23       	and	r24, r24
    4fd0:	29 f0       	breq	.+10     	; 0x4fdc <xStreamBufferReceive+0x58>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    4fd2:	82 e0       	ldi	r24, 0x02	; 2
    4fd4:	90 e0       	ldi	r25, 0x00	; 0
    4fd6:	9a 83       	std	Y+2, r25	; 0x02
    4fd8:	89 83       	std	Y+1, r24	; 0x01
    4fda:	02 c0       	rjmp	.+4      	; 0x4fe0 <xStreamBufferReceive+0x5c>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    4fdc:	1a 82       	std	Y+2, r1	; 0x02
    4fde:	19 82       	std	Y+1, r1	; 0x01
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    4fe0:	8f 85       	ldd	r24, Y+15	; 0x0f
    4fe2:	98 89       	ldd	r25, Y+16	; 0x10
    4fe4:	00 97       	sbiw	r24, 0x00	; 0
    4fe6:	09 f4       	brne	.+2      	; 0x4fea <xStreamBufferReceive+0x66>
    4fe8:	3f c0       	rjmp	.+126    	; 0x5068 <xStreamBufferReceive+0xe4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    4fea:	0f b6       	in	r0, 0x3f	; 63
    4fec:	f8 94       	cli
    4fee:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4ff0:	8f 81       	ldd	r24, Y+7	; 0x07
    4ff2:	98 85       	ldd	r25, Y+8	; 0x08
    4ff4:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvBytesInBuffer>
    4ff8:	9c 83       	std	Y+4, r25	; 0x04
    4ffa:	8b 83       	std	Y+3, r24	; 0x03
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    4ffc:	2b 81       	ldd	r18, Y+3	; 0x03
    4ffe:	3c 81       	ldd	r19, Y+4	; 0x04
    5000:	89 81       	ldd	r24, Y+1	; 0x01
    5002:	9a 81       	ldd	r25, Y+2	; 0x02
    5004:	82 17       	cp	r24, r18
    5006:	93 07       	cpc	r25, r19
    5008:	58 f0       	brcs	.+22     	; 0x5020 <xStreamBufferReceive+0x9c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    500a:	80 e0       	ldi	r24, 0x00	; 0
    500c:	90 e0       	ldi	r25, 0x00	; 0
    500e:	60 e0       	ldi	r22, 0x00	; 0
    5010:	0e 94 39 43 	call	0x8672	; 0x8672 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    5014:	0e 94 b9 39 	call	0x7372	; 0x7372 <xTaskGetCurrentTaskHandle>
    5018:	ef 81       	ldd	r30, Y+7	; 0x07
    501a:	f8 85       	ldd	r31, Y+8	; 0x08
    501c:	91 87       	std	Z+9, r25	; 0x09
    501e:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5020:	0f 90       	pop	r0
    5022:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    5024:	2b 81       	ldd	r18, Y+3	; 0x03
    5026:	3c 81       	ldd	r19, Y+4	; 0x04
    5028:	89 81       	ldd	r24, Y+1	; 0x01
    502a:	9a 81       	ldd	r25, Y+2	; 0x02
    502c:	82 17       	cp	r24, r18
    502e:	93 07       	cpc	r25, r19
    5030:	08 f1       	brcs	.+66     	; 0x5074 <xStreamBufferReceive+0xf0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    5032:	ef 85       	ldd	r30, Y+15	; 0x0f
    5034:	f8 89       	ldd	r31, Y+16	; 0x10
    5036:	80 e0       	ldi	r24, 0x00	; 0
    5038:	40 e0       	ldi	r20, 0x00	; 0
    503a:	50 e0       	ldi	r21, 0x00	; 0
    503c:	60 e0       	ldi	r22, 0x00	; 0
    503e:	70 e0       	ldi	r23, 0x00	; 0
    5040:	00 e0       	ldi	r16, 0x00	; 0
    5042:	10 e0       	ldi	r17, 0x00	; 0
    5044:	20 e0       	ldi	r18, 0x00	; 0
    5046:	30 e0       	ldi	r19, 0x00	; 0
    5048:	ee 24       	eor	r14, r14
    504a:	ff 24       	eor	r15, r15
    504c:	6f 01       	movw	r12, r30
    504e:	0e 94 35 3d 	call	0x7a6a	; 0x7a6a <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    5052:	ef 81       	ldd	r30, Y+7	; 0x07
    5054:	f8 85       	ldd	r31, Y+8	; 0x08
    5056:	11 86       	std	Z+9, r1	; 0x09
    5058:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    505a:	8f 81       	ldd	r24, Y+7	; 0x07
    505c:	98 85       	ldd	r25, Y+8	; 0x08
    505e:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvBytesInBuffer>
    5062:	9c 83       	std	Y+4, r25	; 0x04
    5064:	8b 83       	std	Y+3, r24	; 0x03
    5066:	06 c0       	rjmp	.+12     	; 0x5074 <xStreamBufferReceive+0xf0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    5068:	8f 81       	ldd	r24, Y+7	; 0x07
    506a:	98 85       	ldd	r25, Y+8	; 0x08
    506c:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvBytesInBuffer>
    5070:	9c 83       	std	Y+4, r25	; 0x04
    5072:	8b 83       	std	Y+3, r24	; 0x03
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    5074:	2b 81       	ldd	r18, Y+3	; 0x03
    5076:	3c 81       	ldd	r19, Y+4	; 0x04
    5078:	89 81       	ldd	r24, Y+1	; 0x01
    507a:	9a 81       	ldd	r25, Y+2	; 0x02
    507c:	82 17       	cp	r24, r18
    507e:	93 07       	cpc	r25, r19
    5080:	70 f5       	brcc	.+92     	; 0x50de <xStreamBufferReceive+0x15a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    5082:	8f 81       	ldd	r24, Y+7	; 0x07
    5084:	98 85       	ldd	r25, Y+8	; 0x08
    5086:	2b 85       	ldd	r18, Y+11	; 0x0b
    5088:	3c 85       	ldd	r19, Y+12	; 0x0c
    508a:	4d 85       	ldd	r20, Y+13	; 0x0d
    508c:	5e 85       	ldd	r21, Y+14	; 0x0e
    508e:	eb 81       	ldd	r30, Y+3	; 0x03
    5090:	fc 81       	ldd	r31, Y+4	; 0x04
    5092:	b9 01       	movw	r22, r18
    5094:	9f 01       	movw	r18, r30
    5096:	0e 94 41 29 	call	0x5282	; 0x5282 <prvReadMessageFromBuffer>
    509a:	9e 83       	std	Y+6, r25	; 0x06
    509c:	8d 83       	std	Y+5, r24	; 0x05

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    509e:	8d 81       	ldd	r24, Y+5	; 0x05
    50a0:	9e 81       	ldd	r25, Y+6	; 0x06
    50a2:	00 97       	sbiw	r24, 0x00	; 0
    50a4:	e1 f0       	breq	.+56     	; 0x50de <xStreamBufferReceive+0x15a>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    50a6:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
    50aa:	e9 85       	ldd	r30, Y+9	; 0x09
    50ac:	fa 85       	ldd	r31, Y+10	; 0x0a
    50ae:	82 85       	ldd	r24, Z+10	; 0x0a
    50b0:	93 85       	ldd	r25, Z+11	; 0x0b
    50b2:	00 97       	sbiw	r24, 0x00	; 0
    50b4:	91 f0       	breq	.+36     	; 0x50da <xStreamBufferReceive+0x156>
    50b6:	e9 85       	ldd	r30, Y+9	; 0x09
    50b8:	fa 85       	ldd	r31, Y+10	; 0x0a
    50ba:	82 85       	ldd	r24, Z+10	; 0x0a
    50bc:	93 85       	ldd	r25, Z+11	; 0x0b
    50be:	60 e0       	ldi	r22, 0x00	; 0
    50c0:	20 e0       	ldi	r18, 0x00	; 0
    50c2:	30 e0       	ldi	r19, 0x00	; 0
    50c4:	40 e0       	ldi	r20, 0x00	; 0
    50c6:	50 e0       	ldi	r21, 0x00	; 0
    50c8:	00 e0       	ldi	r16, 0x00	; 0
    50ca:	ee 24       	eor	r14, r14
    50cc:	ff 24       	eor	r15, r15
    50ce:	0e 94 2c 3e 	call	0x7c58	; 0x7c58 <xTaskGenericNotify>
    50d2:	e9 85       	ldd	r30, Y+9	; 0x09
    50d4:	fa 85       	ldd	r31, Y+10	; 0x0a
    50d6:	13 86       	std	Z+11, r1	; 0x0b
    50d8:	12 86       	std	Z+10, r1	; 0x0a
    50da:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
    50de:	8d 81       	ldd	r24, Y+5	; 0x05
    50e0:	9e 81       	ldd	r25, Y+6	; 0x06
}
    50e2:	60 96       	adiw	r28, 0x10	; 16
    50e4:	0f b6       	in	r0, 0x3f	; 63
    50e6:	f8 94       	cli
    50e8:	de bf       	out	0x3e, r29	; 62
    50ea:	0f be       	out	0x3f, r0	; 63
    50ec:	cd bf       	out	0x3d, r28	; 61
    50ee:	cf 91       	pop	r28
    50f0:	df 91       	pop	r29
    50f2:	1f 91       	pop	r17
    50f4:	0f 91       	pop	r16
    50f6:	ff 90       	pop	r15
    50f8:	ef 90       	pop	r14
    50fa:	df 90       	pop	r13
    50fc:	cf 90       	pop	r12
    50fe:	08 95       	ret

00005100 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    5100:	df 93       	push	r29
    5102:	cf 93       	push	r28
    5104:	cd b7       	in	r28, 0x3d	; 61
    5106:	de b7       	in	r29, 0x3e	; 62
    5108:	2a 97       	sbiw	r28, 0x0a	; 10
    510a:	0f b6       	in	r0, 0x3f	; 63
    510c:	f8 94       	cli
    510e:	de bf       	out	0x3e, r29	; 62
    5110:	0f be       	out	0x3f, r0	; 63
    5112:	cd bf       	out	0x3d, r28	; 61
    5114:	9a 87       	std	Y+10, r25	; 0x0a
    5116:	89 87       	std	Y+9, r24	; 0x09
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5118:	89 85       	ldd	r24, Y+9	; 0x09
    511a:	9a 85       	ldd	r25, Y+10	; 0x0a
    511c:	9e 83       	std	Y+6, r25	; 0x06
    511e:	8d 83       	std	Y+5, r24	; 0x05
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    5120:	ed 81       	ldd	r30, Y+5	; 0x05
    5122:	fe 81       	ldd	r31, Y+6	; 0x06
    5124:	86 85       	ldd	r24, Z+14	; 0x0e
    5126:	88 2f       	mov	r24, r24
    5128:	90 e0       	ldi	r25, 0x00	; 0
    512a:	81 70       	andi	r24, 0x01	; 1
    512c:	90 70       	andi	r25, 0x00	; 0
    512e:	88 23       	and	r24, r24
    5130:	19 f1       	breq	.+70     	; 0x5178 <xStreamBufferNextMessageLengthBytes+0x78>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    5132:	8d 81       	ldd	r24, Y+5	; 0x05
    5134:	9e 81       	ldd	r25, Y+6	; 0x06
    5136:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvBytesInBuffer>
    513a:	9a 83       	std	Y+2, r25	; 0x02
    513c:	89 83       	std	Y+1, r24	; 0x01

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    513e:	89 81       	ldd	r24, Y+1	; 0x01
    5140:	9a 81       	ldd	r25, Y+2	; 0x02
    5142:	83 30       	cpi	r24, 0x03	; 3
    5144:	91 05       	cpc	r25, r1
    5146:	a8 f0       	brcs	.+42     	; 0x5172 <xStreamBufferNextMessageLengthBytes+0x72>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    5148:	9e 01       	movw	r18, r28
    514a:	29 5f       	subi	r18, 0xF9	; 249
    514c:	3f 4f       	sbci	r19, 0xFF	; 255
    514e:	ed 81       	ldd	r30, Y+5	; 0x05
    5150:	fe 81       	ldd	r31, Y+6	; 0x06
    5152:	01 90       	ld	r0, Z+
    5154:	f0 81       	ld	r31, Z
    5156:	e0 2d       	mov	r30, r0
    5158:	8d 81       	ldd	r24, Y+5	; 0x05
    515a:	9e 81       	ldd	r25, Y+6	; 0x06
    515c:	b9 01       	movw	r22, r18
    515e:	42 e0       	ldi	r20, 0x02	; 2
    5160:	50 e0       	ldi	r21, 0x00	; 0
    5162:	9f 01       	movw	r18, r30
    5164:	0e 94 33 2b 	call	0x5666	; 0x5666 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    5168:	8f 81       	ldd	r24, Y+7	; 0x07
    516a:	98 85       	ldd	r25, Y+8	; 0x08
    516c:	9c 83       	std	Y+4, r25	; 0x04
    516e:	8b 83       	std	Y+3, r24	; 0x03
    5170:	05 c0       	rjmp	.+10     	; 0x517c <xStreamBufferNextMessageLengthBytes+0x7c>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
    5172:	1c 82       	std	Y+4, r1	; 0x04
    5174:	1b 82       	std	Y+3, r1	; 0x03
    5176:	02 c0       	rjmp	.+4      	; 0x517c <xStreamBufferNextMessageLengthBytes+0x7c>
        }
    }
    else
    {
        xReturn = 0;
    5178:	1c 82       	std	Y+4, r1	; 0x04
    517a:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    517c:	8b 81       	ldd	r24, Y+3	; 0x03
    517e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    5180:	2a 96       	adiw	r28, 0x0a	; 10
    5182:	0f b6       	in	r0, 0x3f	; 63
    5184:	f8 94       	cli
    5186:	de bf       	out	0x3e, r29	; 62
    5188:	0f be       	out	0x3f, r0	; 63
    518a:	cd bf       	out	0x3d, r28	; 61
    518c:	cf 91       	pop	r28
    518e:	df 91       	pop	r29
    5190:	08 95       	ret

00005192 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    5192:	cf 92       	push	r12
    5194:	df 92       	push	r13
    5196:	ef 92       	push	r14
    5198:	ff 92       	push	r15
    519a:	0f 93       	push	r16
    519c:	df 93       	push	r29
    519e:	cf 93       	push	r28
    51a0:	cd b7       	in	r28, 0x3d	; 61
    51a2:	de b7       	in	r29, 0x3e	; 62
    51a4:	61 97       	sbiw	r28, 0x11	; 17
    51a6:	0f b6       	in	r0, 0x3f	; 63
    51a8:	f8 94       	cli
    51aa:	de bf       	out	0x3e, r29	; 62
    51ac:	0f be       	out	0x3f, r0	; 63
    51ae:	cd bf       	out	0x3d, r28	; 61
    51b0:	9b 87       	std	Y+11, r25	; 0x0b
    51b2:	8a 87       	std	Y+10, r24	; 0x0a
    51b4:	7d 87       	std	Y+13, r23	; 0x0d
    51b6:	6c 87       	std	Y+12, r22	; 0x0c
    51b8:	5f 87       	std	Y+15, r21	; 0x0f
    51ba:	4e 87       	std	Y+14, r20	; 0x0e
    51bc:	39 8b       	std	Y+17, r19	; 0x11
    51be:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    51c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    51c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    51c4:	99 87       	std	Y+9, r25	; 0x09
    51c6:	88 87       	std	Y+8, r24	; 0x08
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    51c8:	1f 82       	std	Y+7, r1	; 0x07
    51ca:	1e 82       	std	Y+6, r1	; 0x06
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    51cc:	e8 85       	ldd	r30, Y+8	; 0x08
    51ce:	f9 85       	ldd	r31, Y+9	; 0x09
    51d0:	86 85       	ldd	r24, Z+14	; 0x0e
    51d2:	88 2f       	mov	r24, r24
    51d4:	90 e0       	ldi	r25, 0x00	; 0
    51d6:	81 70       	andi	r24, 0x01	; 1
    51d8:	90 70       	andi	r25, 0x00	; 0
    51da:	88 23       	and	r24, r24
    51dc:	29 f0       	breq	.+10     	; 0x51e8 <xStreamBufferReceiveFromISR+0x56>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    51de:	82 e0       	ldi	r24, 0x02	; 2
    51e0:	90 e0       	ldi	r25, 0x00	; 0
    51e2:	9b 83       	std	Y+3, r25	; 0x03
    51e4:	8a 83       	std	Y+2, r24	; 0x02
    51e6:	02 c0       	rjmp	.+4      	; 0x51ec <xStreamBufferReceiveFromISR+0x5a>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    51e8:	1b 82       	std	Y+3, r1	; 0x03
    51ea:	1a 82       	std	Y+2, r1	; 0x02
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    51ec:	88 85       	ldd	r24, Y+8	; 0x08
    51ee:	99 85       	ldd	r25, Y+9	; 0x09
    51f0:	0e 94 b8 2b 	call	0x5770	; 0x5770 <prvBytesInBuffer>
    51f4:	9d 83       	std	Y+5, r25	; 0x05
    51f6:	8c 83       	std	Y+4, r24	; 0x04
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    51f8:	2c 81       	ldd	r18, Y+4	; 0x04
    51fa:	3d 81       	ldd	r19, Y+5	; 0x05
    51fc:	8a 81       	ldd	r24, Y+2	; 0x02
    51fe:	9b 81       	ldd	r25, Y+3	; 0x03
    5200:	82 17       	cp	r24, r18
    5202:	93 07       	cpc	r25, r19
    5204:	70 f5       	brcc	.+92     	; 0x5262 <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    5206:	88 85       	ldd	r24, Y+8	; 0x08
    5208:	99 85       	ldd	r25, Y+9	; 0x09
    520a:	2c 85       	ldd	r18, Y+12	; 0x0c
    520c:	3d 85       	ldd	r19, Y+13	; 0x0d
    520e:	4e 85       	ldd	r20, Y+14	; 0x0e
    5210:	5f 85       	ldd	r21, Y+15	; 0x0f
    5212:	ec 81       	ldd	r30, Y+4	; 0x04
    5214:	fd 81       	ldd	r31, Y+5	; 0x05
    5216:	b9 01       	movw	r22, r18
    5218:	9f 01       	movw	r18, r30
    521a:	0e 94 41 29 	call	0x5282	; 0x5282 <prvReadMessageFromBuffer>
    521e:	9f 83       	std	Y+7, r25	; 0x07
    5220:	8e 83       	std	Y+6, r24	; 0x06

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    5222:	8e 81       	ldd	r24, Y+6	; 0x06
    5224:	9f 81       	ldd	r25, Y+7	; 0x07
    5226:	00 97       	sbiw	r24, 0x00	; 0
    5228:	e1 f0       	breq	.+56     	; 0x5262 <xStreamBufferReceiveFromISR+0xd0>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    522a:	19 82       	std	Y+1, r1	; 0x01
    522c:	e8 85       	ldd	r30, Y+8	; 0x08
    522e:	f9 85       	ldd	r31, Y+9	; 0x09
    5230:	82 85       	ldd	r24, Z+10	; 0x0a
    5232:	93 85       	ldd	r25, Z+11	; 0x0b
    5234:	00 97       	sbiw	r24, 0x00	; 0
    5236:	a9 f0       	breq	.+42     	; 0x5262 <xStreamBufferReceiveFromISR+0xd0>
    5238:	e8 85       	ldd	r30, Y+8	; 0x08
    523a:	f9 85       	ldd	r31, Y+9	; 0x09
    523c:	82 85       	ldd	r24, Z+10	; 0x0a
    523e:	93 85       	ldd	r25, Z+11	; 0x0b
    5240:	e8 89       	ldd	r30, Y+16	; 0x10
    5242:	f9 89       	ldd	r31, Y+17	; 0x11
    5244:	60 e0       	ldi	r22, 0x00	; 0
    5246:	20 e0       	ldi	r18, 0x00	; 0
    5248:	30 e0       	ldi	r19, 0x00	; 0
    524a:	40 e0       	ldi	r20, 0x00	; 0
    524c:	50 e0       	ldi	r21, 0x00	; 0
    524e:	00 e0       	ldi	r16, 0x00	; 0
    5250:	ee 24       	eor	r14, r14
    5252:	ff 24       	eor	r15, r15
    5254:	6f 01       	movw	r12, r30
    5256:	0e 94 ea 3f 	call	0x7fd4	; 0x7fd4 <xTaskGenericNotifyFromISR>
    525a:	e8 85       	ldd	r30, Y+8	; 0x08
    525c:	f9 85       	ldd	r31, Y+9	; 0x09
    525e:	13 86       	std	Z+11, r1	; 0x0b
    5260:	12 86       	std	Z+10, r1	; 0x0a
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
    5262:	8e 81       	ldd	r24, Y+6	; 0x06
    5264:	9f 81       	ldd	r25, Y+7	; 0x07
}
    5266:	61 96       	adiw	r28, 0x11	; 17
    5268:	0f b6       	in	r0, 0x3f	; 63
    526a:	f8 94       	cli
    526c:	de bf       	out	0x3e, r29	; 62
    526e:	0f be       	out	0x3f, r0	; 63
    5270:	cd bf       	out	0x3d, r28	; 61
    5272:	cf 91       	pop	r28
    5274:	df 91       	pop	r29
    5276:	0f 91       	pop	r16
    5278:	ff 90       	pop	r15
    527a:	ef 90       	pop	r14
    527c:	df 90       	pop	r13
    527e:	cf 90       	pop	r12
    5280:	08 95       	ret

00005282 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    5282:	df 93       	push	r29
    5284:	cf 93       	push	r28
    5286:	cd b7       	in	r28, 0x3d	; 61
    5288:	de b7       	in	r29, 0x3e	; 62
    528a:	64 97       	sbiw	r28, 0x14	; 20
    528c:	0f b6       	in	r0, 0x3f	; 63
    528e:	f8 94       	cli
    5290:	de bf       	out	0x3e, r29	; 62
    5292:	0f be       	out	0x3f, r0	; 63
    5294:	cd bf       	out	0x3d, r28	; 61
    5296:	9a 87       	std	Y+10, r25	; 0x0a
    5298:	89 87       	std	Y+9, r24	; 0x09
    529a:	7c 87       	std	Y+12, r23	; 0x0c
    529c:	6b 87       	std	Y+11, r22	; 0x0b
    529e:	5e 87       	std	Y+14, r21	; 0x0e
    52a0:	4d 87       	std	Y+13, r20	; 0x0d
    52a2:	38 8b       	std	Y+16, r19	; 0x10
    52a4:	2f 87       	std	Y+15, r18	; 0x0f
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    52a6:	e9 85       	ldd	r30, Y+9	; 0x09
    52a8:	fa 85       	ldd	r31, Y+10	; 0x0a
    52aa:	80 81       	ld	r24, Z
    52ac:	91 81       	ldd	r25, Z+1	; 0x01
    52ae:	9a 83       	std	Y+2, r25	; 0x02
    52b0:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    52b2:	e9 85       	ldd	r30, Y+9	; 0x09
    52b4:	fa 85       	ldd	r31, Y+10	; 0x0a
    52b6:	86 85       	ldd	r24, Z+14	; 0x0e
    52b8:	88 2f       	mov	r24, r24
    52ba:	90 e0       	ldi	r25, 0x00	; 0
    52bc:	81 70       	andi	r24, 0x01	; 1
    52be:	90 70       	andi	r25, 0x00	; 0
    52c0:	88 23       	and	r24, r24
    52c2:	11 f1       	breq	.+68     	; 0x5308 <prvReadMessageFromBuffer+0x86>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    52c4:	9e 01       	movw	r18, r28
    52c6:	29 5f       	subi	r18, 0xF9	; 249
    52c8:	3f 4f       	sbci	r19, 0xFF	; 255
    52ca:	89 85       	ldd	r24, Y+9	; 0x09
    52cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    52ce:	e9 81       	ldd	r30, Y+1	; 0x01
    52d0:	fa 81       	ldd	r31, Y+2	; 0x02
    52d2:	b9 01       	movw	r22, r18
    52d4:	42 e0       	ldi	r20, 0x02	; 2
    52d6:	50 e0       	ldi	r21, 0x00	; 0
    52d8:	9f 01       	movw	r18, r30
    52da:	0e 94 33 2b 	call	0x5666	; 0x5666 <prvReadBytesFromBuffer>
    52de:	9a 83       	std	Y+2, r25	; 0x02
    52e0:	89 83       	std	Y+1, r24	; 0x01
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    52e2:	8f 81       	ldd	r24, Y+7	; 0x07
    52e4:	98 85       	ldd	r25, Y+8	; 0x08
    52e6:	9c 83       	std	Y+4, r25	; 0x04
    52e8:	8b 83       	std	Y+3, r24	; 0x03

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    52ea:	8f 85       	ldd	r24, Y+15	; 0x0f
    52ec:	98 89       	ldd	r25, Y+16	; 0x10
    52ee:	02 97       	sbiw	r24, 0x02	; 2
    52f0:	98 8b       	std	Y+16, r25	; 0x10
    52f2:	8f 87       	std	Y+15, r24	; 0x0f

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    52f4:	2b 81       	ldd	r18, Y+3	; 0x03
    52f6:	3c 81       	ldd	r19, Y+4	; 0x04
    52f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    52fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    52fc:	82 17       	cp	r24, r18
    52fe:	93 07       	cpc	r25, r19
    5300:	38 f4       	brcc	.+14     	; 0x5310 <prvReadMessageFromBuffer+0x8e>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
    5302:	1c 82       	std	Y+4, r1	; 0x04
    5304:	1b 82       	std	Y+3, r1	; 0x03
    5306:	04 c0       	rjmp	.+8      	; 0x5310 <prvReadMessageFromBuffer+0x8e>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    5308:	8d 85       	ldd	r24, Y+13	; 0x0d
    530a:	9e 85       	ldd	r25, Y+14	; 0x0e
    530c:	9c 83       	std	Y+4, r25	; 0x04
    530e:	8b 83       	std	Y+3, r24	; 0x03
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    5310:	2b 81       	ldd	r18, Y+3	; 0x03
    5312:	3c 81       	ldd	r19, Y+4	; 0x04
    5314:	3c 8b       	std	Y+20, r19	; 0x14
    5316:	2b 8b       	std	Y+19, r18	; 0x13
    5318:	8f 85       	ldd	r24, Y+15	; 0x0f
    531a:	98 89       	ldd	r25, Y+16	; 0x10
    531c:	9a 8b       	std	Y+18, r25	; 0x12
    531e:	89 8b       	std	Y+17, r24	; 0x11
    5320:	29 89       	ldd	r18, Y+17	; 0x11
    5322:	3a 89       	ldd	r19, Y+18	; 0x12
    5324:	8b 89       	ldd	r24, Y+19	; 0x13
    5326:	9c 89       	ldd	r25, Y+20	; 0x14
    5328:	82 17       	cp	r24, r18
    532a:	93 07       	cpc	r25, r19
    532c:	20 f4       	brcc	.+8      	; 0x5336 <prvReadMessageFromBuffer+0xb4>
    532e:	2b 89       	ldd	r18, Y+19	; 0x13
    5330:	3c 89       	ldd	r19, Y+20	; 0x14
    5332:	3a 8b       	std	Y+18, r19	; 0x12
    5334:	29 8b       	std	Y+17, r18	; 0x11
    5336:	89 89       	ldd	r24, Y+17	; 0x11
    5338:	9a 89       	ldd	r25, Y+18	; 0x12
    533a:	9e 83       	std	Y+6, r25	; 0x06
    533c:	8d 83       	std	Y+5, r24	; 0x05

    if( xCount != ( size_t ) 0 )
    533e:	8d 81       	ldd	r24, Y+5	; 0x05
    5340:	9e 81       	ldd	r25, Y+6	; 0x06
    5342:	00 97       	sbiw	r24, 0x00	; 0
    5344:	89 f0       	breq	.+34     	; 0x5368 <prvReadMessageFromBuffer+0xe6>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    5346:	4b 85       	ldd	r20, Y+11	; 0x0b
    5348:	5c 85       	ldd	r21, Y+12	; 0x0c
    534a:	89 85       	ldd	r24, Y+9	; 0x09
    534c:	9a 85       	ldd	r25, Y+10	; 0x0a
    534e:	2d 81       	ldd	r18, Y+5	; 0x05
    5350:	3e 81       	ldd	r19, Y+6	; 0x06
    5352:	e9 81       	ldd	r30, Y+1	; 0x01
    5354:	fa 81       	ldd	r31, Y+2	; 0x02
    5356:	ba 01       	movw	r22, r20
    5358:	a9 01       	movw	r20, r18
    535a:	9f 01       	movw	r18, r30
    535c:	0e 94 33 2b 	call	0x5666	; 0x5666 <prvReadBytesFromBuffer>
    5360:	e9 85       	ldd	r30, Y+9	; 0x09
    5362:	fa 85       	ldd	r31, Y+10	; 0x0a
    5364:	91 83       	std	Z+1, r25	; 0x01
    5366:	80 83       	st	Z, r24
    }

    return xCount;
    5368:	8d 81       	ldd	r24, Y+5	; 0x05
    536a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    536c:	64 96       	adiw	r28, 0x14	; 20
    536e:	0f b6       	in	r0, 0x3f	; 63
    5370:	f8 94       	cli
    5372:	de bf       	out	0x3e, r29	; 62
    5374:	0f be       	out	0x3f, r0	; 63
    5376:	cd bf       	out	0x3d, r28	; 61
    5378:	cf 91       	pop	r28
    537a:	df 91       	pop	r29
    537c:	08 95       	ret

0000537e <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    537e:	df 93       	push	r29
    5380:	cf 93       	push	r28
    5382:	cd b7       	in	r28, 0x3d	; 61
    5384:	de b7       	in	r29, 0x3e	; 62
    5386:	27 97       	sbiw	r28, 0x07	; 7
    5388:	0f b6       	in	r0, 0x3f	; 63
    538a:	f8 94       	cli
    538c:	de bf       	out	0x3e, r29	; 62
    538e:	0f be       	out	0x3f, r0	; 63
    5390:	cd bf       	out	0x3d, r28	; 61
    5392:	9f 83       	std	Y+7, r25	; 0x07
    5394:	8e 83       	std	Y+6, r24	; 0x06
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    5396:	8e 81       	ldd	r24, Y+6	; 0x06
    5398:	9f 81       	ldd	r25, Y+7	; 0x07
    539a:	9d 83       	std	Y+5, r25	; 0x05
    539c:	8c 83       	std	Y+4, r24	; 0x04
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    539e:	ec 81       	ldd	r30, Y+4	; 0x04
    53a0:	fd 81       	ldd	r31, Y+5	; 0x05
    53a2:	80 81       	ld	r24, Z
    53a4:	91 81       	ldd	r25, Z+1	; 0x01
    53a6:	9a 83       	std	Y+2, r25	; 0x02
    53a8:	89 83       	std	Y+1, r24	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    53aa:	ec 81       	ldd	r30, Y+4	; 0x04
    53ac:	fd 81       	ldd	r31, Y+5	; 0x05
    53ae:	22 81       	ldd	r18, Z+2	; 0x02
    53b0:	33 81       	ldd	r19, Z+3	; 0x03
    53b2:	89 81       	ldd	r24, Y+1	; 0x01
    53b4:	9a 81       	ldd	r25, Y+2	; 0x02
    53b6:	28 17       	cp	r18, r24
    53b8:	39 07       	cpc	r19, r25
    53ba:	19 f4       	brne	.+6      	; 0x53c2 <xStreamBufferIsEmpty+0x44>
    {
        xReturn = pdTRUE;
    53bc:	81 e0       	ldi	r24, 0x01	; 1
    53be:	8b 83       	std	Y+3, r24	; 0x03
    53c0:	01 c0       	rjmp	.+2      	; 0x53c4 <xStreamBufferIsEmpty+0x46>
    }
    else
    {
        xReturn = pdFALSE;
    53c2:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    53c4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    53c6:	27 96       	adiw	r28, 0x07	; 7
    53c8:	0f b6       	in	r0, 0x3f	; 63
    53ca:	f8 94       	cli
    53cc:	de bf       	out	0x3e, r29	; 62
    53ce:	0f be       	out	0x3f, r0	; 63
    53d0:	cd bf       	out	0x3d, r28	; 61
    53d2:	cf 91       	pop	r28
    53d4:	df 91       	pop	r29
    53d6:	08 95       	ret

000053d8 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    53d8:	df 93       	push	r29
    53da:	cf 93       	push	r28
    53dc:	cd b7       	in	r28, 0x3d	; 61
    53de:	de b7       	in	r29, 0x3e	; 62
    53e0:	27 97       	sbiw	r28, 0x07	; 7
    53e2:	0f b6       	in	r0, 0x3f	; 63
    53e4:	f8 94       	cli
    53e6:	de bf       	out	0x3e, r29	; 62
    53e8:	0f be       	out	0x3f, r0	; 63
    53ea:	cd bf       	out	0x3d, r28	; 61
    53ec:	9f 83       	std	Y+7, r25	; 0x07
    53ee:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    53f0:	8e 81       	ldd	r24, Y+6	; 0x06
    53f2:	9f 81       	ldd	r25, Y+7	; 0x07
    53f4:	9a 83       	std	Y+2, r25	; 0x02
    53f6:	89 83       	std	Y+1, r24	; 0x01

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    53f8:	e9 81       	ldd	r30, Y+1	; 0x01
    53fa:	fa 81       	ldd	r31, Y+2	; 0x02
    53fc:	86 85       	ldd	r24, Z+14	; 0x0e
    53fe:	88 2f       	mov	r24, r24
    5400:	90 e0       	ldi	r25, 0x00	; 0
    5402:	81 70       	andi	r24, 0x01	; 1
    5404:	90 70       	andi	r25, 0x00	; 0
    5406:	88 23       	and	r24, r24
    5408:	29 f0       	breq	.+10     	; 0x5414 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    540a:	82 e0       	ldi	r24, 0x02	; 2
    540c:	90 e0       	ldi	r25, 0x00	; 0
    540e:	9c 83       	std	Y+4, r25	; 0x04
    5410:	8b 83       	std	Y+3, r24	; 0x03
    5412:	02 c0       	rjmp	.+4      	; 0x5418 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    5414:	1c 82       	std	Y+4, r1	; 0x04
    5416:	1b 82       	std	Y+3, r1	; 0x03
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    5418:	8e 81       	ldd	r24, Y+6	; 0x06
    541a:	9f 81       	ldd	r25, Y+7	; 0x07
    541c:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <xStreamBufferSpacesAvailable>
    5420:	9c 01       	movw	r18, r24
    5422:	8b 81       	ldd	r24, Y+3	; 0x03
    5424:	9c 81       	ldd	r25, Y+4	; 0x04
    5426:	82 17       	cp	r24, r18
    5428:	93 07       	cpc	r25, r19
    542a:	18 f0       	brcs	.+6      	; 0x5432 <xStreamBufferIsFull+0x5a>
    {
        xReturn = pdTRUE;
    542c:	81 e0       	ldi	r24, 0x01	; 1
    542e:	8d 83       	std	Y+5, r24	; 0x05
    5430:	01 c0       	rjmp	.+2      	; 0x5434 <xStreamBufferIsFull+0x5c>
    }
    else
    {
        xReturn = pdFALSE;
    5432:	1d 82       	std	Y+5, r1	; 0x05
    }

    return xReturn;
    5434:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5436:	27 96       	adiw	r28, 0x07	; 7
    5438:	0f b6       	in	r0, 0x3f	; 63
    543a:	f8 94       	cli
    543c:	de bf       	out	0x3e, r29	; 62
    543e:	0f be       	out	0x3f, r0	; 63
    5440:	cd bf       	out	0x3d, r28	; 61
    5442:	cf 91       	pop	r28
    5444:	df 91       	pop	r29
    5446:	08 95       	ret

00005448 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    5448:	cf 92       	push	r12
    544a:	df 92       	push	r13
    544c:	ef 92       	push	r14
    544e:	ff 92       	push	r15
    5450:	0f 93       	push	r16
    5452:	df 93       	push	r29
    5454:	cf 93       	push	r28
    5456:	cd b7       	in	r28, 0x3d	; 61
    5458:	de b7       	in	r29, 0x3e	; 62
    545a:	28 97       	sbiw	r28, 0x08	; 8
    545c:	0f b6       	in	r0, 0x3f	; 63
    545e:	f8 94       	cli
    5460:	de bf       	out	0x3e, r29	; 62
    5462:	0f be       	out	0x3f, r0	; 63
    5464:	cd bf       	out	0x3d, r28	; 61
    5466:	9e 83       	std	Y+6, r25	; 0x06
    5468:	8d 83       	std	Y+5, r24	; 0x05
    546a:	78 87       	std	Y+8, r23	; 0x08
    546c:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    546e:	8d 81       	ldd	r24, Y+5	; 0x05
    5470:	9e 81       	ldd	r25, Y+6	; 0x06
    5472:	9c 83       	std	Y+4, r25	; 0x04
    5474:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    5476:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    5478:	eb 81       	ldd	r30, Y+3	; 0x03
    547a:	fc 81       	ldd	r31, Y+4	; 0x04
    547c:	80 85       	ldd	r24, Z+8	; 0x08
    547e:	91 85       	ldd	r25, Z+9	; 0x09
    5480:	00 97       	sbiw	r24, 0x00	; 0
    5482:	c1 f0       	breq	.+48     	; 0x54b4 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    5484:	eb 81       	ldd	r30, Y+3	; 0x03
    5486:	fc 81       	ldd	r31, Y+4	; 0x04
    5488:	80 85       	ldd	r24, Z+8	; 0x08
    548a:	91 85       	ldd	r25, Z+9	; 0x09
    548c:	ef 81       	ldd	r30, Y+7	; 0x07
    548e:	f8 85       	ldd	r31, Y+8	; 0x08
    5490:	60 e0       	ldi	r22, 0x00	; 0
    5492:	20 e0       	ldi	r18, 0x00	; 0
    5494:	30 e0       	ldi	r19, 0x00	; 0
    5496:	40 e0       	ldi	r20, 0x00	; 0
    5498:	50 e0       	ldi	r21, 0x00	; 0
    549a:	00 e0       	ldi	r16, 0x00	; 0
    549c:	ee 24       	eor	r14, r14
    549e:	ff 24       	eor	r15, r15
    54a0:	6f 01       	movw	r12, r30
    54a2:	0e 94 ea 3f 	call	0x7fd4	; 0x7fd4 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    54a6:	eb 81       	ldd	r30, Y+3	; 0x03
    54a8:	fc 81       	ldd	r31, Y+4	; 0x04
    54aa:	11 86       	std	Z+9, r1	; 0x09
    54ac:	10 86       	std	Z+8, r1	; 0x08
            xReturn = pdTRUE;
    54ae:	81 e0       	ldi	r24, 0x01	; 1
    54b0:	8a 83       	std	Y+2, r24	; 0x02
    54b2:	01 c0       	rjmp	.+2      	; 0x54b6 <xStreamBufferSendCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    54b4:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    54b6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    54b8:	28 96       	adiw	r28, 0x08	; 8
    54ba:	0f b6       	in	r0, 0x3f	; 63
    54bc:	f8 94       	cli
    54be:	de bf       	out	0x3e, r29	; 62
    54c0:	0f be       	out	0x3f, r0	; 63
    54c2:	cd bf       	out	0x3d, r28	; 61
    54c4:	cf 91       	pop	r28
    54c6:	df 91       	pop	r29
    54c8:	0f 91       	pop	r16
    54ca:	ff 90       	pop	r15
    54cc:	ef 90       	pop	r14
    54ce:	df 90       	pop	r13
    54d0:	cf 90       	pop	r12
    54d2:	08 95       	ret

000054d4 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    54d4:	cf 92       	push	r12
    54d6:	df 92       	push	r13
    54d8:	ef 92       	push	r14
    54da:	ff 92       	push	r15
    54dc:	0f 93       	push	r16
    54de:	df 93       	push	r29
    54e0:	cf 93       	push	r28
    54e2:	cd b7       	in	r28, 0x3d	; 61
    54e4:	de b7       	in	r29, 0x3e	; 62
    54e6:	28 97       	sbiw	r28, 0x08	; 8
    54e8:	0f b6       	in	r0, 0x3f	; 63
    54ea:	f8 94       	cli
    54ec:	de bf       	out	0x3e, r29	; 62
    54ee:	0f be       	out	0x3f, r0	; 63
    54f0:	cd bf       	out	0x3d, r28	; 61
    54f2:	9e 83       	std	Y+6, r25	; 0x06
    54f4:	8d 83       	std	Y+5, r24	; 0x05
    54f6:	78 87       	std	Y+8, r23	; 0x08
    54f8:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    54fa:	8d 81       	ldd	r24, Y+5	; 0x05
    54fc:	9e 81       	ldd	r25, Y+6	; 0x06
    54fe:	9c 83       	std	Y+4, r25	; 0x04
    5500:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    5502:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    5504:	eb 81       	ldd	r30, Y+3	; 0x03
    5506:	fc 81       	ldd	r31, Y+4	; 0x04
    5508:	82 85       	ldd	r24, Z+10	; 0x0a
    550a:	93 85       	ldd	r25, Z+11	; 0x0b
    550c:	00 97       	sbiw	r24, 0x00	; 0
    550e:	c1 f0       	breq	.+48     	; 0x5540 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    5510:	eb 81       	ldd	r30, Y+3	; 0x03
    5512:	fc 81       	ldd	r31, Y+4	; 0x04
    5514:	82 85       	ldd	r24, Z+10	; 0x0a
    5516:	93 85       	ldd	r25, Z+11	; 0x0b
    5518:	ef 81       	ldd	r30, Y+7	; 0x07
    551a:	f8 85       	ldd	r31, Y+8	; 0x08
    551c:	60 e0       	ldi	r22, 0x00	; 0
    551e:	20 e0       	ldi	r18, 0x00	; 0
    5520:	30 e0       	ldi	r19, 0x00	; 0
    5522:	40 e0       	ldi	r20, 0x00	; 0
    5524:	50 e0       	ldi	r21, 0x00	; 0
    5526:	00 e0       	ldi	r16, 0x00	; 0
    5528:	ee 24       	eor	r14, r14
    552a:	ff 24       	eor	r15, r15
    552c:	6f 01       	movw	r12, r30
    552e:	0e 94 ea 3f 	call	0x7fd4	; 0x7fd4 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    5532:	eb 81       	ldd	r30, Y+3	; 0x03
    5534:	fc 81       	ldd	r31, Y+4	; 0x04
    5536:	13 86       	std	Z+11, r1	; 0x0b
    5538:	12 86       	std	Z+10, r1	; 0x0a
            xReturn = pdTRUE;
    553a:	81 e0       	ldi	r24, 0x01	; 1
    553c:	8a 83       	std	Y+2, r24	; 0x02
    553e:	01 c0       	rjmp	.+2      	; 0x5542 <xStreamBufferReceiveCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    5540:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    5542:	8a 81       	ldd	r24, Y+2	; 0x02
}
    5544:	28 96       	adiw	r28, 0x08	; 8
    5546:	0f b6       	in	r0, 0x3f	; 63
    5548:	f8 94       	cli
    554a:	de bf       	out	0x3e, r29	; 62
    554c:	0f be       	out	0x3f, r0	; 63
    554e:	cd bf       	out	0x3d, r28	; 61
    5550:	cf 91       	pop	r28
    5552:	df 91       	pop	r29
    5554:	0f 91       	pop	r16
    5556:	ff 90       	pop	r15
    5558:	ef 90       	pop	r14
    555a:	df 90       	pop	r13
    555c:	cf 90       	pop	r12
    555e:	08 95       	ret

00005560 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    5560:	df 93       	push	r29
    5562:	cf 93       	push	r28
    5564:	cd b7       	in	r28, 0x3d	; 61
    5566:	de b7       	in	r29, 0x3e	; 62
    5568:	2e 97       	sbiw	r28, 0x0e	; 14
    556a:	0f b6       	in	r0, 0x3f	; 63
    556c:	f8 94       	cli
    556e:	de bf       	out	0x3e, r29	; 62
    5570:	0f be       	out	0x3f, r0	; 63
    5572:	cd bf       	out	0x3d, r28	; 61
    5574:	9c 83       	std	Y+4, r25	; 0x04
    5576:	8b 83       	std	Y+3, r24	; 0x03
    5578:	7e 83       	std	Y+6, r23	; 0x06
    557a:	6d 83       	std	Y+5, r22	; 0x05
    557c:	58 87       	std	Y+8, r21	; 0x08
    557e:	4f 83       	std	Y+7, r20	; 0x07
    5580:	3a 87       	std	Y+10, r19	; 0x0a
    5582:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    5584:	eb 81       	ldd	r30, Y+3	; 0x03
    5586:	fc 81       	ldd	r31, Y+4	; 0x04
    5588:	24 81       	ldd	r18, Z+4	; 0x04
    558a:	35 81       	ldd	r19, Z+5	; 0x05
    558c:	89 85       	ldd	r24, Y+9	; 0x09
    558e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5590:	a9 01       	movw	r20, r18
    5592:	48 1b       	sub	r20, r24
    5594:	59 0b       	sbc	r21, r25
    5596:	ca 01       	movw	r24, r20
    5598:	2f 81       	ldd	r18, Y+7	; 0x07
    559a:	38 85       	ldd	r19, Y+8	; 0x08
    559c:	3e 87       	std	Y+14, r19	; 0x0e
    559e:	2d 87       	std	Y+13, r18	; 0x0d
    55a0:	9c 87       	std	Y+12, r25	; 0x0c
    55a2:	8b 87       	std	Y+11, r24	; 0x0b
    55a4:	4b 85       	ldd	r20, Y+11	; 0x0b
    55a6:	5c 85       	ldd	r21, Y+12	; 0x0c
    55a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    55aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    55ac:	84 17       	cp	r24, r20
    55ae:	95 07       	cpc	r25, r21
    55b0:	20 f4       	brcc	.+8      	; 0x55ba <prvWriteBytesToBuffer+0x5a>
    55b2:	2d 85       	ldd	r18, Y+13	; 0x0d
    55b4:	3e 85       	ldd	r19, Y+14	; 0x0e
    55b6:	3c 87       	std	Y+12, r19	; 0x0c
    55b8:	2b 87       	std	Y+11, r18	; 0x0b
    55ba:	4b 85       	ldd	r20, Y+11	; 0x0b
    55bc:	5c 85       	ldd	r21, Y+12	; 0x0c
    55be:	5a 83       	std	Y+2, r21	; 0x02
    55c0:	49 83       	std	Y+1, r20	; 0x01

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    55c2:	eb 81       	ldd	r30, Y+3	; 0x03
    55c4:	fc 81       	ldd	r31, Y+4	; 0x04
    55c6:	24 85       	ldd	r18, Z+12	; 0x0c
    55c8:	35 85       	ldd	r19, Z+13	; 0x0d
    55ca:	89 85       	ldd	r24, Y+9	; 0x09
    55cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    55ce:	82 0f       	add	r24, r18
    55d0:	93 1f       	adc	r25, r19
    55d2:	2d 81       	ldd	r18, Y+5	; 0x05
    55d4:	3e 81       	ldd	r19, Y+6	; 0x06
    55d6:	49 81       	ldd	r20, Y+1	; 0x01
    55d8:	5a 81       	ldd	r21, Y+2	; 0x02
    55da:	b9 01       	movw	r22, r18
    55dc:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    55e0:	2f 81       	ldd	r18, Y+7	; 0x07
    55e2:	38 85       	ldd	r19, Y+8	; 0x08
    55e4:	89 81       	ldd	r24, Y+1	; 0x01
    55e6:	9a 81       	ldd	r25, Y+2	; 0x02
    55e8:	82 17       	cp	r24, r18
    55ea:	93 07       	cpc	r25, r19
    55ec:	b0 f4       	brcc	.+44     	; 0x561a <prvWriteBytesToBuffer+0xba>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    55ee:	eb 81       	ldd	r30, Y+3	; 0x03
    55f0:	fc 81       	ldd	r31, Y+4	; 0x04
    55f2:	64 85       	ldd	r22, Z+12	; 0x0c
    55f4:	75 85       	ldd	r23, Z+13	; 0x0d
    55f6:	2d 81       	ldd	r18, Y+5	; 0x05
    55f8:	3e 81       	ldd	r19, Y+6	; 0x06
    55fa:	89 81       	ldd	r24, Y+1	; 0x01
    55fc:	9a 81       	ldd	r25, Y+2	; 0x02
    55fe:	a9 01       	movw	r20, r18
    5600:	48 0f       	add	r20, r24
    5602:	59 1f       	adc	r21, r25
    5604:	2f 81       	ldd	r18, Y+7	; 0x07
    5606:	38 85       	ldd	r19, Y+8	; 0x08
    5608:	89 81       	ldd	r24, Y+1	; 0x01
    560a:	9a 81       	ldd	r25, Y+2	; 0x02
    560c:	28 1b       	sub	r18, r24
    560e:	39 0b       	sbc	r19, r25
    5610:	cb 01       	movw	r24, r22
    5612:	ba 01       	movw	r22, r20
    5614:	a9 01       	movw	r20, r18
    5616:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    561a:	29 85       	ldd	r18, Y+9	; 0x09
    561c:	3a 85       	ldd	r19, Y+10	; 0x0a
    561e:	8f 81       	ldd	r24, Y+7	; 0x07
    5620:	98 85       	ldd	r25, Y+8	; 0x08
    5622:	82 0f       	add	r24, r18
    5624:	93 1f       	adc	r25, r19
    5626:	9a 87       	std	Y+10, r25	; 0x0a
    5628:	89 87       	std	Y+9, r24	; 0x09

    if( xHead >= pxStreamBuffer->xLength )
    562a:	eb 81       	ldd	r30, Y+3	; 0x03
    562c:	fc 81       	ldd	r31, Y+4	; 0x04
    562e:	24 81       	ldd	r18, Z+4	; 0x04
    5630:	35 81       	ldd	r19, Z+5	; 0x05
    5632:	89 85       	ldd	r24, Y+9	; 0x09
    5634:	9a 85       	ldd	r25, Y+10	; 0x0a
    5636:	82 17       	cp	r24, r18
    5638:	93 07       	cpc	r25, r19
    563a:	50 f0       	brcs	.+20     	; 0x5650 <prvWriteBytesToBuffer+0xf0>
    {
        xHead -= pxStreamBuffer->xLength;
    563c:	eb 81       	ldd	r30, Y+3	; 0x03
    563e:	fc 81       	ldd	r31, Y+4	; 0x04
    5640:	24 81       	ldd	r18, Z+4	; 0x04
    5642:	35 81       	ldd	r19, Z+5	; 0x05
    5644:	89 85       	ldd	r24, Y+9	; 0x09
    5646:	9a 85       	ldd	r25, Y+10	; 0x0a
    5648:	82 1b       	sub	r24, r18
    564a:	93 0b       	sbc	r25, r19
    564c:	9a 87       	std	Y+10, r25	; 0x0a
    564e:	89 87       	std	Y+9, r24	; 0x09
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
    5650:	89 85       	ldd	r24, Y+9	; 0x09
    5652:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    5654:	2e 96       	adiw	r28, 0x0e	; 14
    5656:	0f b6       	in	r0, 0x3f	; 63
    5658:	f8 94       	cli
    565a:	de bf       	out	0x3e, r29	; 62
    565c:	0f be       	out	0x3f, r0	; 63
    565e:	cd bf       	out	0x3d, r28	; 61
    5660:	cf 91       	pop	r28
    5662:	df 91       	pop	r29
    5664:	08 95       	ret

00005666 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    5666:	df 93       	push	r29
    5668:	cf 93       	push	r28
    566a:	cd b7       	in	r28, 0x3d	; 61
    566c:	de b7       	in	r29, 0x3e	; 62
    566e:	2e 97       	sbiw	r28, 0x0e	; 14
    5670:	0f b6       	in	r0, 0x3f	; 63
    5672:	f8 94       	cli
    5674:	de bf       	out	0x3e, r29	; 62
    5676:	0f be       	out	0x3f, r0	; 63
    5678:	cd bf       	out	0x3d, r28	; 61
    567a:	9c 83       	std	Y+4, r25	; 0x04
    567c:	8b 83       	std	Y+3, r24	; 0x03
    567e:	7e 83       	std	Y+6, r23	; 0x06
    5680:	6d 83       	std	Y+5, r22	; 0x05
    5682:	58 87       	std	Y+8, r21	; 0x08
    5684:	4f 83       	std	Y+7, r20	; 0x07
    5686:	3a 87       	std	Y+10, r19	; 0x0a
    5688:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    568a:	eb 81       	ldd	r30, Y+3	; 0x03
    568c:	fc 81       	ldd	r31, Y+4	; 0x04
    568e:	24 81       	ldd	r18, Z+4	; 0x04
    5690:	35 81       	ldd	r19, Z+5	; 0x05
    5692:	89 85       	ldd	r24, Y+9	; 0x09
    5694:	9a 85       	ldd	r25, Y+10	; 0x0a
    5696:	a9 01       	movw	r20, r18
    5698:	48 1b       	sub	r20, r24
    569a:	59 0b       	sbc	r21, r25
    569c:	ca 01       	movw	r24, r20
    569e:	2f 81       	ldd	r18, Y+7	; 0x07
    56a0:	38 85       	ldd	r19, Y+8	; 0x08
    56a2:	3e 87       	std	Y+14, r19	; 0x0e
    56a4:	2d 87       	std	Y+13, r18	; 0x0d
    56a6:	9c 87       	std	Y+12, r25	; 0x0c
    56a8:	8b 87       	std	Y+11, r24	; 0x0b
    56aa:	4b 85       	ldd	r20, Y+11	; 0x0b
    56ac:	5c 85       	ldd	r21, Y+12	; 0x0c
    56ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    56b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    56b2:	84 17       	cp	r24, r20
    56b4:	95 07       	cpc	r25, r21
    56b6:	20 f4       	brcc	.+8      	; 0x56c0 <prvReadBytesFromBuffer+0x5a>
    56b8:	2d 85       	ldd	r18, Y+13	; 0x0d
    56ba:	3e 85       	ldd	r19, Y+14	; 0x0e
    56bc:	3c 87       	std	Y+12, r19	; 0x0c
    56be:	2b 87       	std	Y+11, r18	; 0x0b
    56c0:	4b 85       	ldd	r20, Y+11	; 0x0b
    56c2:	5c 85       	ldd	r21, Y+12	; 0x0c
    56c4:	5a 83       	std	Y+2, r21	; 0x02
    56c6:	49 83       	std	Y+1, r20	; 0x01

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    56c8:	eb 81       	ldd	r30, Y+3	; 0x03
    56ca:	fc 81       	ldd	r31, Y+4	; 0x04
    56cc:	24 85       	ldd	r18, Z+12	; 0x0c
    56ce:	35 85       	ldd	r19, Z+13	; 0x0d
    56d0:	89 85       	ldd	r24, Y+9	; 0x09
    56d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    56d4:	a9 01       	movw	r20, r18
    56d6:	48 0f       	add	r20, r24
    56d8:	59 1f       	adc	r21, r25
    56da:	8d 81       	ldd	r24, Y+5	; 0x05
    56dc:	9e 81       	ldd	r25, Y+6	; 0x06
    56de:	29 81       	ldd	r18, Y+1	; 0x01
    56e0:	3a 81       	ldd	r19, Y+2	; 0x02
    56e2:	ba 01       	movw	r22, r20
    56e4:	a9 01       	movw	r20, r18
    56e6:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    56ea:	2f 81       	ldd	r18, Y+7	; 0x07
    56ec:	38 85       	ldd	r19, Y+8	; 0x08
    56ee:	89 81       	ldd	r24, Y+1	; 0x01
    56f0:	9a 81       	ldd	r25, Y+2	; 0x02
    56f2:	82 17       	cp	r24, r18
    56f4:	93 07       	cpc	r25, r19
    56f6:	b0 f4       	brcc	.+44     	; 0x5724 <prvReadBytesFromBuffer+0xbe>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    56f8:	2d 81       	ldd	r18, Y+5	; 0x05
    56fa:	3e 81       	ldd	r19, Y+6	; 0x06
    56fc:	89 81       	ldd	r24, Y+1	; 0x01
    56fe:	9a 81       	ldd	r25, Y+2	; 0x02
    5700:	b9 01       	movw	r22, r18
    5702:	68 0f       	add	r22, r24
    5704:	79 1f       	adc	r23, r25
    5706:	eb 81       	ldd	r30, Y+3	; 0x03
    5708:	fc 81       	ldd	r31, Y+4	; 0x04
    570a:	44 85       	ldd	r20, Z+12	; 0x0c
    570c:	55 85       	ldd	r21, Z+13	; 0x0d
    570e:	2f 81       	ldd	r18, Y+7	; 0x07
    5710:	38 85       	ldd	r19, Y+8	; 0x08
    5712:	89 81       	ldd	r24, Y+1	; 0x01
    5714:	9a 81       	ldd	r25, Y+2	; 0x02
    5716:	28 1b       	sub	r18, r24
    5718:	39 0b       	sbc	r19, r25
    571a:	cb 01       	movw	r24, r22
    571c:	ba 01       	movw	r22, r20
    571e:	a9 01       	movw	r20, r18
    5720:	0e 94 a4 4d 	call	0x9b48	; 0x9b48 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    5724:	29 85       	ldd	r18, Y+9	; 0x09
    5726:	3a 85       	ldd	r19, Y+10	; 0x0a
    5728:	8f 81       	ldd	r24, Y+7	; 0x07
    572a:	98 85       	ldd	r25, Y+8	; 0x08
    572c:	82 0f       	add	r24, r18
    572e:	93 1f       	adc	r25, r19
    5730:	9a 87       	std	Y+10, r25	; 0x0a
    5732:	89 87       	std	Y+9, r24	; 0x09

    if( xTail >= pxStreamBuffer->xLength )
    5734:	eb 81       	ldd	r30, Y+3	; 0x03
    5736:	fc 81       	ldd	r31, Y+4	; 0x04
    5738:	24 81       	ldd	r18, Z+4	; 0x04
    573a:	35 81       	ldd	r19, Z+5	; 0x05
    573c:	89 85       	ldd	r24, Y+9	; 0x09
    573e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5740:	82 17       	cp	r24, r18
    5742:	93 07       	cpc	r25, r19
    5744:	50 f0       	brcs	.+20     	; 0x575a <prvReadBytesFromBuffer+0xf4>
    {
        xTail -= pxStreamBuffer->xLength;
    5746:	eb 81       	ldd	r30, Y+3	; 0x03
    5748:	fc 81       	ldd	r31, Y+4	; 0x04
    574a:	24 81       	ldd	r18, Z+4	; 0x04
    574c:	35 81       	ldd	r19, Z+5	; 0x05
    574e:	89 85       	ldd	r24, Y+9	; 0x09
    5750:	9a 85       	ldd	r25, Y+10	; 0x0a
    5752:	82 1b       	sub	r24, r18
    5754:	93 0b       	sbc	r25, r19
    5756:	9a 87       	std	Y+10, r25	; 0x0a
    5758:	89 87       	std	Y+9, r24	; 0x09
    }

    return xTail;
    575a:	89 85       	ldd	r24, Y+9	; 0x09
    575c:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    575e:	2e 96       	adiw	r28, 0x0e	; 14
    5760:	0f b6       	in	r0, 0x3f	; 63
    5762:	f8 94       	cli
    5764:	de bf       	out	0x3e, r29	; 62
    5766:	0f be       	out	0x3f, r0	; 63
    5768:	cd bf       	out	0x3d, r28	; 61
    576a:	cf 91       	pop	r28
    576c:	df 91       	pop	r29
    576e:	08 95       	ret

00005770 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    5770:	df 93       	push	r29
    5772:	cf 93       	push	r28
    5774:	00 d0       	rcall	.+0      	; 0x5776 <prvBytesInBuffer+0x6>
    5776:	00 d0       	rcall	.+0      	; 0x5778 <prvBytesInBuffer+0x8>
    5778:	cd b7       	in	r28, 0x3d	; 61
    577a:	de b7       	in	r29, 0x3e	; 62
    577c:	9c 83       	std	Y+4, r25	; 0x04
    577e:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    5780:	eb 81       	ldd	r30, Y+3	; 0x03
    5782:	fc 81       	ldd	r31, Y+4	; 0x04
    5784:	24 81       	ldd	r18, Z+4	; 0x04
    5786:	35 81       	ldd	r19, Z+5	; 0x05
    5788:	eb 81       	ldd	r30, Y+3	; 0x03
    578a:	fc 81       	ldd	r31, Y+4	; 0x04
    578c:	82 81       	ldd	r24, Z+2	; 0x02
    578e:	93 81       	ldd	r25, Z+3	; 0x03
    5790:	82 0f       	add	r24, r18
    5792:	93 1f       	adc	r25, r19
    5794:	9a 83       	std	Y+2, r25	; 0x02
    5796:	89 83       	std	Y+1, r24	; 0x01
    xCount -= pxStreamBuffer->xTail;
    5798:	eb 81       	ldd	r30, Y+3	; 0x03
    579a:	fc 81       	ldd	r31, Y+4	; 0x04
    579c:	20 81       	ld	r18, Z
    579e:	31 81       	ldd	r19, Z+1	; 0x01
    57a0:	89 81       	ldd	r24, Y+1	; 0x01
    57a2:	9a 81       	ldd	r25, Y+2	; 0x02
    57a4:	82 1b       	sub	r24, r18
    57a6:	93 0b       	sbc	r25, r19
    57a8:	9a 83       	std	Y+2, r25	; 0x02
    57aa:	89 83       	std	Y+1, r24	; 0x01

    if( xCount >= pxStreamBuffer->xLength )
    57ac:	eb 81       	ldd	r30, Y+3	; 0x03
    57ae:	fc 81       	ldd	r31, Y+4	; 0x04
    57b0:	24 81       	ldd	r18, Z+4	; 0x04
    57b2:	35 81       	ldd	r19, Z+5	; 0x05
    57b4:	89 81       	ldd	r24, Y+1	; 0x01
    57b6:	9a 81       	ldd	r25, Y+2	; 0x02
    57b8:	82 17       	cp	r24, r18
    57ba:	93 07       	cpc	r25, r19
    57bc:	50 f0       	brcs	.+20     	; 0x57d2 <prvBytesInBuffer+0x62>
    {
        xCount -= pxStreamBuffer->xLength;
    57be:	eb 81       	ldd	r30, Y+3	; 0x03
    57c0:	fc 81       	ldd	r31, Y+4	; 0x04
    57c2:	24 81       	ldd	r18, Z+4	; 0x04
    57c4:	35 81       	ldd	r19, Z+5	; 0x05
    57c6:	89 81       	ldd	r24, Y+1	; 0x01
    57c8:	9a 81       	ldd	r25, Y+2	; 0x02
    57ca:	82 1b       	sub	r24, r18
    57cc:	93 0b       	sbc	r25, r19
    57ce:	9a 83       	std	Y+2, r25	; 0x02
    57d0:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
    57d2:	89 81       	ldd	r24, Y+1	; 0x01
    57d4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    57d6:	0f 90       	pop	r0
    57d8:	0f 90       	pop	r0
    57da:	0f 90       	pop	r0
    57dc:	0f 90       	pop	r0
    57de:	cf 91       	pop	r28
    57e0:	df 91       	pop	r29
    57e2:	08 95       	ret

000057e4 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
    57e4:	cf 92       	push	r12
    57e6:	df 92       	push	r13
    57e8:	ef 92       	push	r14
    57ea:	ff 92       	push	r15
    57ec:	0f 93       	push	r16
    57ee:	df 93       	push	r29
    57f0:	cf 93       	push	r28
    57f2:	cd b7       	in	r28, 0x3d	; 61
    57f4:	de b7       	in	r29, 0x3e	; 62
    57f6:	2d 97       	sbiw	r28, 0x0d	; 13
    57f8:	0f b6       	in	r0, 0x3f	; 63
    57fa:	f8 94       	cli
    57fc:	de bf       	out	0x3e, r29	; 62
    57fe:	0f be       	out	0x3f, r0	; 63
    5800:	cd bf       	out	0x3d, r28	; 61
    5802:	9a 83       	std	Y+2, r25	; 0x02
    5804:	89 83       	std	Y+1, r24	; 0x01
    5806:	7c 83       	std	Y+4, r23	; 0x04
    5808:	6b 83       	std	Y+3, r22	; 0x03
    580a:	5e 83       	std	Y+6, r21	; 0x06
    580c:	4d 83       	std	Y+5, r20	; 0x05
    580e:	38 87       	std	Y+8, r19	; 0x08
    5810:	2f 83       	std	Y+7, r18	; 0x07
    5812:	09 87       	std	Y+9, r16	; 0x09
    5814:	fb 86       	std	Y+11, r15	; 0x0b
    5816:	ea 86       	std	Y+10, r14	; 0x0a
    5818:	dd 86       	std	Y+13, r13	; 0x0d
    581a:	cc 86       	std	Y+12, r12	; 0x0c
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    581c:	89 81       	ldd	r24, Y+1	; 0x01
    581e:	9a 81       	ldd	r25, Y+2	; 0x02
    5820:	60 e0       	ldi	r22, 0x00	; 0
    5822:	70 e0       	ldi	r23, 0x00	; 0
    5824:	4f e0       	ldi	r20, 0x0F	; 15
    5826:	50 e0       	ldi	r21, 0x00	; 0
    5828:	0e 94 ad 4d 	call	0x9b5a	; 0x9b5a <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
    582c:	e9 81       	ldd	r30, Y+1	; 0x01
    582e:	fa 81       	ldd	r31, Y+2	; 0x02
    5830:	8b 81       	ldd	r24, Y+3	; 0x03
    5832:	9c 81       	ldd	r25, Y+4	; 0x04
    5834:	95 87       	std	Z+13, r25	; 0x0d
    5836:	84 87       	std	Z+12, r24	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    5838:	e9 81       	ldd	r30, Y+1	; 0x01
    583a:	fa 81       	ldd	r31, Y+2	; 0x02
    583c:	8d 81       	ldd	r24, Y+5	; 0x05
    583e:	9e 81       	ldd	r25, Y+6	; 0x06
    5840:	95 83       	std	Z+5, r25	; 0x05
    5842:	84 83       	std	Z+4, r24	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    5844:	e9 81       	ldd	r30, Y+1	; 0x01
    5846:	fa 81       	ldd	r31, Y+2	; 0x02
    5848:	8f 81       	ldd	r24, Y+7	; 0x07
    584a:	98 85       	ldd	r25, Y+8	; 0x08
    584c:	97 83       	std	Z+7, r25	; 0x07
    584e:	86 83       	std	Z+6, r24	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    5850:	e9 81       	ldd	r30, Y+1	; 0x01
    5852:	fa 81       	ldd	r31, Y+2	; 0x02
    5854:	89 85       	ldd	r24, Y+9	; 0x09
    5856:	86 87       	std	Z+14, r24	; 0x0e
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
    5858:	2d 96       	adiw	r28, 0x0d	; 13
    585a:	0f b6       	in	r0, 0x3f	; 63
    585c:	f8 94       	cli
    585e:	de bf       	out	0x3e, r29	; 62
    5860:	0f be       	out	0x3f, r0	; 63
    5862:	cd bf       	out	0x3d, r28	; 61
    5864:	cf 91       	pop	r28
    5866:	df 91       	pop	r29
    5868:	0f 91       	pop	r16
    586a:	ff 90       	pop	r15
    586c:	ef 90       	pop	r14
    586e:	df 90       	pop	r13
    5870:	cf 90       	pop	r12
    5872:	08 95       	ret

00005874 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    5874:	8f 92       	push	r8
    5876:	9f 92       	push	r9
    5878:	af 92       	push	r10
    587a:	bf 92       	push	r11
    587c:	cf 92       	push	r12
    587e:	df 92       	push	r13
    5880:	ef 92       	push	r14
    5882:	ff 92       	push	r15
    5884:	0f 93       	push	r16
    5886:	1f 93       	push	r17
    5888:	df 93       	push	r29
    588a:	cf 93       	push	r28
    588c:	cd b7       	in	r28, 0x3d	; 61
    588e:	de b7       	in	r29, 0x3e	; 62
    5890:	60 97       	sbiw	r28, 0x10	; 16
    5892:	0f b6       	in	r0, 0x3f	; 63
    5894:	f8 94       	cli
    5896:	de bf       	out	0x3e, r29	; 62
    5898:	0f be       	out	0x3f, r0	; 63
    589a:	cd bf       	out	0x3d, r28	; 61
    589c:	9f 83       	std	Y+7, r25	; 0x07
    589e:	8e 83       	std	Y+6, r24	; 0x06
    58a0:	79 87       	std	Y+9, r23	; 0x09
    58a2:	68 87       	std	Y+8, r22	; 0x08
    58a4:	5b 87       	std	Y+11, r21	; 0x0b
    58a6:	4a 87       	std	Y+10, r20	; 0x0a
    58a8:	3d 87       	std	Y+13, r19	; 0x0d
    58aa:	2c 87       	std	Y+12, r18	; 0x0c
    58ac:	0e 87       	std	Y+14, r16	; 0x0e
    58ae:	f8 8a       	std	Y+16, r15	; 0x10
    58b0:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    58b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    58b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    58b6:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <pvPortMalloc>
    58ba:	9a 83       	std	Y+2, r25	; 0x02
    58bc:	89 83       	std	Y+1, r24	; 0x01

            if( pxStack != NULL )
    58be:	89 81       	ldd	r24, Y+1	; 0x01
    58c0:	9a 81       	ldd	r25, Y+2	; 0x02
    58c2:	00 97       	sbiw	r24, 0x00	; 0
    58c4:	f1 f0       	breq	.+60     	; 0x5902 <xTaskCreate+0x8e>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    58c6:	88 e2       	ldi	r24, 0x28	; 40
    58c8:	90 e0       	ldi	r25, 0x00	; 0
    58ca:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <pvPortMalloc>
    58ce:	9d 83       	std	Y+5, r25	; 0x05
    58d0:	8c 83       	std	Y+4, r24	; 0x04

                if( pxNewTCB != NULL )
    58d2:	8c 81       	ldd	r24, Y+4	; 0x04
    58d4:	9d 81       	ldd	r25, Y+5	; 0x05
    58d6:	00 97       	sbiw	r24, 0x00	; 0
    58d8:	79 f0       	breq	.+30     	; 0x58f8 <xTaskCreate+0x84>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    58da:	8c 81       	ldd	r24, Y+4	; 0x04
    58dc:	9d 81       	ldd	r25, Y+5	; 0x05
    58de:	60 e0       	ldi	r22, 0x00	; 0
    58e0:	70 e0       	ldi	r23, 0x00	; 0
    58e2:	48 e2       	ldi	r20, 0x28	; 40
    58e4:	50 e0       	ldi	r21, 0x00	; 0
    58e6:	0e 94 ad 4d 	call	0x9b5a	; 0x9b5a <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    58ea:	ec 81       	ldd	r30, Y+4	; 0x04
    58ec:	fd 81       	ldd	r31, Y+5	; 0x05
    58ee:	89 81       	ldd	r24, Y+1	; 0x01
    58f0:	9a 81       	ldd	r25, Y+2	; 0x02
    58f2:	90 8f       	std	Z+24, r25	; 0x18
    58f4:	87 8b       	std	Z+23, r24	; 0x17
    58f6:	07 c0       	rjmp	.+14     	; 0x5906 <xTaskCreate+0x92>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    58f8:	89 81       	ldd	r24, Y+1	; 0x01
    58fa:	9a 81       	ldd	r25, Y+2	; 0x02
    58fc:	0e 94 b4 17 	call	0x2f68	; 0x2f68 <vPortFree>
    5900:	02 c0       	rjmp	.+4      	; 0x5906 <xTaskCreate+0x92>
                }
            }
            else
            {
                pxNewTCB = NULL;
    5902:	1d 82       	std	Y+5, r1	; 0x05
    5904:	1c 82       	std	Y+4, r1	; 0x04
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    5906:	8c 81       	ldd	r24, Y+4	; 0x04
    5908:	9d 81       	ldd	r25, Y+5	; 0x05
    590a:	00 97       	sbiw	r24, 0x00	; 0
    590c:	e9 f0       	breq	.+58     	; 0x5948 <xTaskCreate+0xd4>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    590e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5910:	9b 85       	ldd	r25, Y+11	; 0x0b
    5912:	9c 01       	movw	r18, r24
    5914:	40 e0       	ldi	r20, 0x00	; 0
    5916:	50 e0       	ldi	r21, 0x00	; 0
    5918:	8e 81       	ldd	r24, Y+6	; 0x06
    591a:	9f 81       	ldd	r25, Y+7	; 0x07
    591c:	68 85       	ldd	r22, Y+8	; 0x08
    591e:	79 85       	ldd	r23, Y+9	; 0x09
    5920:	ec 85       	ldd	r30, Y+12	; 0x0c
    5922:	fd 85       	ldd	r31, Y+13	; 0x0d
    5924:	af 85       	ldd	r26, Y+15	; 0x0f
    5926:	b8 89       	ldd	r27, Y+16	; 0x10
    5928:	ac 80       	ldd	r10, Y+4	; 0x04
    592a:	bd 80       	ldd	r11, Y+5	; 0x05
    592c:	8f 01       	movw	r16, r30
    592e:	ee 84       	ldd	r14, Y+14	; 0x0e
    5930:	6d 01       	movw	r12, r26
    5932:	88 24       	eor	r8, r8
    5934:	99 24       	eor	r9, r9
    5936:	0e 94 ba 2c 	call	0x5974	; 0x5974 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    593a:	8c 81       	ldd	r24, Y+4	; 0x04
    593c:	9d 81       	ldd	r25, Y+5	; 0x05
    593e:	0e 94 6d 2d 	call	0x5ada	; 0x5ada <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    5942:	81 e0       	ldi	r24, 0x01	; 1
    5944:	8b 83       	std	Y+3, r24	; 0x03
    5946:	02 c0       	rjmp	.+4      	; 0x594c <xTaskCreate+0xd8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    5948:	8f ef       	ldi	r24, 0xFF	; 255
    594a:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    594c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    594e:	60 96       	adiw	r28, 0x10	; 16
    5950:	0f b6       	in	r0, 0x3f	; 63
    5952:	f8 94       	cli
    5954:	de bf       	out	0x3e, r29	; 62
    5956:	0f be       	out	0x3f, r0	; 63
    5958:	cd bf       	out	0x3d, r28	; 61
    595a:	cf 91       	pop	r28
    595c:	df 91       	pop	r29
    595e:	1f 91       	pop	r17
    5960:	0f 91       	pop	r16
    5962:	ff 90       	pop	r15
    5964:	ef 90       	pop	r14
    5966:	df 90       	pop	r13
    5968:	cf 90       	pop	r12
    596a:	bf 90       	pop	r11
    596c:	af 90       	pop	r10
    596e:	9f 90       	pop	r9
    5970:	8f 90       	pop	r8
    5972:	08 95       	ret

00005974 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    5974:	8f 92       	push	r8
    5976:	9f 92       	push	r9
    5978:	af 92       	push	r10
    597a:	bf 92       	push	r11
    597c:	cf 92       	push	r12
    597e:	df 92       	push	r13
    5980:	ef 92       	push	r14
    5982:	0f 93       	push	r16
    5984:	1f 93       	push	r17
    5986:	df 93       	push	r29
    5988:	cf 93       	push	r28
    598a:	cd b7       	in	r28, 0x3d	; 61
    598c:	de b7       	in	r29, 0x3e	; 62
    598e:	64 97       	sbiw	r28, 0x14	; 20
    5990:	0f b6       	in	r0, 0x3f	; 63
    5992:	f8 94       	cli
    5994:	de bf       	out	0x3e, r29	; 62
    5996:	0f be       	out	0x3f, r0	; 63
    5998:	cd bf       	out	0x3d, r28	; 61
    599a:	9d 83       	std	Y+5, r25	; 0x05
    599c:	8c 83       	std	Y+4, r24	; 0x04
    599e:	7f 83       	std	Y+7, r23	; 0x07
    59a0:	6e 83       	std	Y+6, r22	; 0x06
    59a2:	28 87       	std	Y+8, r18	; 0x08
    59a4:	39 87       	std	Y+9, r19	; 0x09
    59a6:	4a 87       	std	Y+10, r20	; 0x0a
    59a8:	5b 87       	std	Y+11, r21	; 0x0b
    59aa:	1d 87       	std	Y+13, r17	; 0x0d
    59ac:	0c 87       	std	Y+12, r16	; 0x0c
    59ae:	ee 86       	std	Y+14, r14	; 0x0e
    59b0:	d8 8a       	std	Y+16, r13	; 0x10
    59b2:	cf 86       	std	Y+15, r12	; 0x0f
    59b4:	ba 8a       	std	Y+18, r11	; 0x12
    59b6:	a9 8a       	std	Y+17, r10	; 0x11
    59b8:	9c 8a       	std	Y+20, r9	; 0x14
    59ba:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    59bc:	e9 89       	ldd	r30, Y+17	; 0x11
    59be:	fa 89       	ldd	r31, Y+18	; 0x12
    59c0:	27 89       	ldd	r18, Z+23	; 0x17
    59c2:	30 8d       	ldd	r19, Z+24	; 0x18
    59c4:	88 85       	ldd	r24, Y+8	; 0x08
    59c6:	99 85       	ldd	r25, Y+9	; 0x09
    59c8:	01 97       	sbiw	r24, 0x01	; 1
    59ca:	82 0f       	add	r24, r18
    59cc:	93 1f       	adc	r25, r19
    59ce:	9b 83       	std	Y+3, r25	; 0x03
    59d0:	8a 83       	std	Y+2, r24	; 0x02
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    59d2:	8e 81       	ldd	r24, Y+6	; 0x06
    59d4:	9f 81       	ldd	r25, Y+7	; 0x07
    59d6:	00 97       	sbiw	r24, 0x00	; 0
    59d8:	49 f1       	breq	.+82     	; 0x5a2c <prvInitialiseNewTask+0xb8>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    59da:	19 82       	std	Y+1, r1	; 0x01
    59dc:	21 c0       	rjmp	.+66     	; 0x5a20 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    59de:	89 81       	ldd	r24, Y+1	; 0x01
    59e0:	48 2f       	mov	r20, r24
    59e2:	50 e0       	ldi	r21, 0x00	; 0
    59e4:	89 81       	ldd	r24, Y+1	; 0x01
    59e6:	28 2f       	mov	r18, r24
    59e8:	30 e0       	ldi	r19, 0x00	; 0
    59ea:	8e 81       	ldd	r24, Y+6	; 0x06
    59ec:	9f 81       	ldd	r25, Y+7	; 0x07
    59ee:	fc 01       	movw	r30, r24
    59f0:	e2 0f       	add	r30, r18
    59f2:	f3 1f       	adc	r31, r19
    59f4:	20 81       	ld	r18, Z
    59f6:	89 89       	ldd	r24, Y+17	; 0x11
    59f8:	9a 89       	ldd	r25, Y+18	; 0x12
    59fa:	84 0f       	add	r24, r20
    59fc:	95 1f       	adc	r25, r21
    59fe:	fc 01       	movw	r30, r24
    5a00:	79 96       	adiw	r30, 0x19	; 25
    5a02:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    5a04:	89 81       	ldd	r24, Y+1	; 0x01
    5a06:	28 2f       	mov	r18, r24
    5a08:	30 e0       	ldi	r19, 0x00	; 0
    5a0a:	8e 81       	ldd	r24, Y+6	; 0x06
    5a0c:	9f 81       	ldd	r25, Y+7	; 0x07
    5a0e:	fc 01       	movw	r30, r24
    5a10:	e2 0f       	add	r30, r18
    5a12:	f3 1f       	adc	r31, r19
    5a14:	80 81       	ld	r24, Z
    5a16:	88 23       	and	r24, r24
    5a18:	31 f0       	breq	.+12     	; 0x5a26 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5a1a:	89 81       	ldd	r24, Y+1	; 0x01
    5a1c:	8f 5f       	subi	r24, 0xFF	; 255
    5a1e:	89 83       	std	Y+1, r24	; 0x01
    5a20:	89 81       	ldd	r24, Y+1	; 0x01
    5a22:	88 30       	cpi	r24, 0x08	; 8
    5a24:	e0 f2       	brcs	.-72     	; 0x59de <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5a26:	e9 89       	ldd	r30, Y+17	; 0x11
    5a28:	fa 89       	ldd	r31, Y+18	; 0x12
    5a2a:	10 a2       	std	Z+32, r1	; 0x20
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    5a2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    5a2e:	84 30       	cpi	r24, 0x04	; 4
    5a30:	10 f0       	brcs	.+4      	; 0x5a36 <prvInitialiseNewTask+0xc2>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5a32:	83 e0       	ldi	r24, 0x03	; 3
    5a34:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    5a36:	e9 89       	ldd	r30, Y+17	; 0x11
    5a38:	fa 89       	ldd	r31, Y+18	; 0x12
    5a3a:	8e 85       	ldd	r24, Y+14	; 0x0e
    5a3c:	86 8b       	std	Z+22, r24	; 0x16
    #if ( configUSE_MUTEXES == 1 )
    {
        pxNewTCB->uxBasePriority = uxPriority;
    5a3e:	e9 89       	ldd	r30, Y+17	; 0x11
    5a40:	fa 89       	ldd	r31, Y+18	; 0x12
    5a42:	8e 85       	ldd	r24, Y+14	; 0x0e
    5a44:	81 a3       	std	Z+33, r24	; 0x21
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    5a46:	89 89       	ldd	r24, Y+17	; 0x11
    5a48:	9a 89       	ldd	r25, Y+18	; 0x12
    5a4a:	02 96       	adiw	r24, 0x02	; 2
    5a4c:	0e 94 04 18 	call	0x3008	; 0x3008 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    5a50:	89 89       	ldd	r24, Y+17	; 0x11
    5a52:	9a 89       	ldd	r25, Y+18	; 0x12
    5a54:	0c 96       	adiw	r24, 0x0c	; 12
    5a56:	0e 94 04 18 	call	0x3008	; 0x3008 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    5a5a:	e9 89       	ldd	r30, Y+17	; 0x11
    5a5c:	fa 89       	ldd	r31, Y+18	; 0x12
    5a5e:	89 89       	ldd	r24, Y+17	; 0x11
    5a60:	9a 89       	ldd	r25, Y+18	; 0x12
    5a62:	91 87       	std	Z+9, r25	; 0x09
    5a64:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5a66:	8e 85       	ldd	r24, Y+14	; 0x0e
    5a68:	28 2f       	mov	r18, r24
    5a6a:	30 e0       	ldi	r19, 0x00	; 0
    5a6c:	84 e0       	ldi	r24, 0x04	; 4
    5a6e:	90 e0       	ldi	r25, 0x00	; 0
    5a70:	82 1b       	sub	r24, r18
    5a72:	93 0b       	sbc	r25, r19
    5a74:	e9 89       	ldd	r30, Y+17	; 0x11
    5a76:	fa 89       	ldd	r31, Y+18	; 0x12
    5a78:	95 87       	std	Z+13, r25	; 0x0d
    5a7a:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    5a7c:	e9 89       	ldd	r30, Y+17	; 0x11
    5a7e:	fa 89       	ldd	r31, Y+18	; 0x12
    5a80:	89 89       	ldd	r24, Y+17	; 0x11
    5a82:	9a 89       	ldd	r25, Y+18	; 0x12
    5a84:	93 8b       	std	Z+19, r25	; 0x13
    5a86:	82 8b       	std	Z+18, r24	; 0x12
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    5a88:	8a 81       	ldd	r24, Y+2	; 0x02
    5a8a:	9b 81       	ldd	r25, Y+3	; 0x03
    5a8c:	2c 81       	ldd	r18, Y+4	; 0x04
    5a8e:	3d 81       	ldd	r19, Y+5	; 0x05
    5a90:	4c 85       	ldd	r20, Y+12	; 0x0c
    5a92:	5d 85       	ldd	r21, Y+13	; 0x0d
    5a94:	b9 01       	movw	r22, r18
    5a96:	0e 94 10 19 	call	0x3220	; 0x3220 <pxPortInitialiseStack>
    5a9a:	e9 89       	ldd	r30, Y+17	; 0x11
    5a9c:	fa 89       	ldd	r31, Y+18	; 0x12
    5a9e:	91 83       	std	Z+1, r25	; 0x01
    5aa0:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    5aa2:	8f 85       	ldd	r24, Y+15	; 0x0f
    5aa4:	98 89       	ldd	r25, Y+16	; 0x10
    5aa6:	00 97       	sbiw	r24, 0x00	; 0
    5aa8:	31 f0       	breq	.+12     	; 0x5ab6 <prvInitialiseNewTask+0x142>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    5aaa:	ef 85       	ldd	r30, Y+15	; 0x0f
    5aac:	f8 89       	ldd	r31, Y+16	; 0x10
    5aae:	89 89       	ldd	r24, Y+17	; 0x11
    5ab0:	9a 89       	ldd	r25, Y+18	; 0x12
    5ab2:	91 83       	std	Z+1, r25	; 0x01
    5ab4:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    5ab6:	64 96       	adiw	r28, 0x14	; 20
    5ab8:	0f b6       	in	r0, 0x3f	; 63
    5aba:	f8 94       	cli
    5abc:	de bf       	out	0x3e, r29	; 62
    5abe:	0f be       	out	0x3f, r0	; 63
    5ac0:	cd bf       	out	0x3d, r28	; 61
    5ac2:	cf 91       	pop	r28
    5ac4:	df 91       	pop	r29
    5ac6:	1f 91       	pop	r17
    5ac8:	0f 91       	pop	r16
    5aca:	ef 90       	pop	r14
    5acc:	df 90       	pop	r13
    5ace:	cf 90       	pop	r12
    5ad0:	bf 90       	pop	r11
    5ad2:	af 90       	pop	r10
    5ad4:	9f 90       	pop	r9
    5ad6:	8f 90       	pop	r8
    5ad8:	08 95       	ret

00005ada <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    5ada:	df 93       	push	r29
    5adc:	cf 93       	push	r28
    5ade:	00 d0       	rcall	.+0      	; 0x5ae0 <prvAddNewTaskToReadyList+0x6>
    5ae0:	00 d0       	rcall	.+0      	; 0x5ae2 <prvAddNewTaskToReadyList+0x8>
    5ae2:	cd b7       	in	r28, 0x3d	; 61
    5ae4:	de b7       	in	r29, 0x3e	; 62
    5ae6:	9c 83       	std	Y+4, r25	; 0x04
    5ae8:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    5aea:	0f b6       	in	r0, 0x3f	; 63
    5aec:	f8 94       	cli
    5aee:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    5af0:	80 91 59 07 	lds	r24, 0x0759
    5af4:	8f 5f       	subi	r24, 0xFF	; 255
    5af6:	80 93 59 07 	sts	0x0759, r24

        if( pxCurrentTCB == NULL )
    5afa:	80 91 56 07 	lds	r24, 0x0756
    5afe:	90 91 57 07 	lds	r25, 0x0757
    5b02:	00 97       	sbiw	r24, 0x00	; 0
    5b04:	69 f4       	brne	.+26     	; 0x5b20 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    5b06:	8b 81       	ldd	r24, Y+3	; 0x03
    5b08:	9c 81       	ldd	r25, Y+4	; 0x04
    5b0a:	90 93 57 07 	sts	0x0757, r25
    5b0e:	80 93 56 07 	sts	0x0756, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    5b12:	80 91 59 07 	lds	r24, 0x0759
    5b16:	81 30       	cpi	r24, 0x01	; 1
    5b18:	b9 f4       	brne	.+46     	; 0x5b48 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    5b1a:	0e 94 11 39 	call	0x7222	; 0x7222 <prvInitialiseTaskLists>
    5b1e:	14 c0       	rjmp	.+40     	; 0x5b48 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    5b20:	80 91 5d 07 	lds	r24, 0x075D
    5b24:	88 23       	and	r24, r24
    5b26:	81 f4       	brne	.+32     	; 0x5b48 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    5b28:	e0 91 56 07 	lds	r30, 0x0756
    5b2c:	f0 91 57 07 	lds	r31, 0x0757
    5b30:	96 89       	ldd	r25, Z+22	; 0x16
    5b32:	eb 81       	ldd	r30, Y+3	; 0x03
    5b34:	fc 81       	ldd	r31, Y+4	; 0x04
    5b36:	86 89       	ldd	r24, Z+22	; 0x16
    5b38:	89 17       	cp	r24, r25
    5b3a:	30 f0       	brcs	.+12     	; 0x5b48 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    5b3c:	8b 81       	ldd	r24, Y+3	; 0x03
    5b3e:	9c 81       	ldd	r25, Y+4	; 0x04
    5b40:	90 93 57 07 	sts	0x0757, r25
    5b44:	80 93 56 07 	sts	0x0756, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    5b48:	80 91 62 07 	lds	r24, 0x0762
    5b4c:	8f 5f       	subi	r24, 0xFF	; 255
    5b4e:	80 93 62 07 	sts	0x0762, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    5b52:	eb 81       	ldd	r30, Y+3	; 0x03
    5b54:	fc 81       	ldd	r31, Y+4	; 0x04
    5b56:	96 89       	ldd	r25, Z+22	; 0x16
    5b58:	80 91 5c 07 	lds	r24, 0x075C
    5b5c:	89 17       	cp	r24, r25
    5b5e:	28 f4       	brcc	.+10     	; 0x5b6a <prvAddNewTaskToReadyList+0x90>
    5b60:	eb 81       	ldd	r30, Y+3	; 0x03
    5b62:	fc 81       	ldd	r31, Y+4	; 0x04
    5b64:	86 89       	ldd	r24, Z+22	; 0x16
    5b66:	80 93 5c 07 	sts	0x075C, r24
    5b6a:	eb 81       	ldd	r30, Y+3	; 0x03
    5b6c:	fc 81       	ldd	r31, Y+4	; 0x04
    5b6e:	86 89       	ldd	r24, Z+22	; 0x16
    5b70:	28 2f       	mov	r18, r24
    5b72:	30 e0       	ldi	r19, 0x00	; 0
    5b74:	c9 01       	movw	r24, r18
    5b76:	88 0f       	add	r24, r24
    5b78:	99 1f       	adc	r25, r25
    5b7a:	88 0f       	add	r24, r24
    5b7c:	99 1f       	adc	r25, r25
    5b7e:	88 0f       	add	r24, r24
    5b80:	99 1f       	adc	r25, r25
    5b82:	82 0f       	add	r24, r18
    5b84:	93 1f       	adc	r25, r19
    5b86:	fc 01       	movw	r30, r24
    5b88:	e8 59       	subi	r30, 0x98	; 152
    5b8a:	f8 4f       	sbci	r31, 0xF8	; 248
    5b8c:	81 81       	ldd	r24, Z+1	; 0x01
    5b8e:	92 81       	ldd	r25, Z+2	; 0x02
    5b90:	9a 83       	std	Y+2, r25	; 0x02
    5b92:	89 83       	std	Y+1, r24	; 0x01
    5b94:	eb 81       	ldd	r30, Y+3	; 0x03
    5b96:	fc 81       	ldd	r31, Y+4	; 0x04
    5b98:	89 81       	ldd	r24, Y+1	; 0x01
    5b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    5b9c:	95 83       	std	Z+5, r25	; 0x05
    5b9e:	84 83       	std	Z+4, r24	; 0x04
    5ba0:	e9 81       	ldd	r30, Y+1	; 0x01
    5ba2:	fa 81       	ldd	r31, Y+2	; 0x02
    5ba4:	84 81       	ldd	r24, Z+4	; 0x04
    5ba6:	95 81       	ldd	r25, Z+5	; 0x05
    5ba8:	eb 81       	ldd	r30, Y+3	; 0x03
    5baa:	fc 81       	ldd	r31, Y+4	; 0x04
    5bac:	97 83       	std	Z+7, r25	; 0x07
    5bae:	86 83       	std	Z+6, r24	; 0x06
    5bb0:	e9 81       	ldd	r30, Y+1	; 0x01
    5bb2:	fa 81       	ldd	r31, Y+2	; 0x02
    5bb4:	04 80       	ldd	r0, Z+4	; 0x04
    5bb6:	f5 81       	ldd	r31, Z+5	; 0x05
    5bb8:	e0 2d       	mov	r30, r0
    5bba:	8b 81       	ldd	r24, Y+3	; 0x03
    5bbc:	9c 81       	ldd	r25, Y+4	; 0x04
    5bbe:	02 96       	adiw	r24, 0x02	; 2
    5bc0:	93 83       	std	Z+3, r25	; 0x03
    5bc2:	82 83       	std	Z+2, r24	; 0x02
    5bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    5bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    5bc8:	02 96       	adiw	r24, 0x02	; 2
    5bca:	e9 81       	ldd	r30, Y+1	; 0x01
    5bcc:	fa 81       	ldd	r31, Y+2	; 0x02
    5bce:	95 83       	std	Z+5, r25	; 0x05
    5bd0:	84 83       	std	Z+4, r24	; 0x04
    5bd2:	eb 81       	ldd	r30, Y+3	; 0x03
    5bd4:	fc 81       	ldd	r31, Y+4	; 0x04
    5bd6:	86 89       	ldd	r24, Z+22	; 0x16
    5bd8:	28 2f       	mov	r18, r24
    5bda:	30 e0       	ldi	r19, 0x00	; 0
    5bdc:	c9 01       	movw	r24, r18
    5bde:	88 0f       	add	r24, r24
    5be0:	99 1f       	adc	r25, r25
    5be2:	88 0f       	add	r24, r24
    5be4:	99 1f       	adc	r25, r25
    5be6:	88 0f       	add	r24, r24
    5be8:	99 1f       	adc	r25, r25
    5bea:	82 0f       	add	r24, r18
    5bec:	93 1f       	adc	r25, r19
    5bee:	88 59       	subi	r24, 0x98	; 152
    5bf0:	98 4f       	sbci	r25, 0xF8	; 248
    5bf2:	eb 81       	ldd	r30, Y+3	; 0x03
    5bf4:	fc 81       	ldd	r31, Y+4	; 0x04
    5bf6:	93 87       	std	Z+11, r25	; 0x0b
    5bf8:	82 87       	std	Z+10, r24	; 0x0a
    5bfa:	eb 81       	ldd	r30, Y+3	; 0x03
    5bfc:	fc 81       	ldd	r31, Y+4	; 0x04
    5bfe:	86 89       	ldd	r24, Z+22	; 0x16
    5c00:	28 2f       	mov	r18, r24
    5c02:	30 e0       	ldi	r19, 0x00	; 0
    5c04:	c9 01       	movw	r24, r18
    5c06:	88 0f       	add	r24, r24
    5c08:	99 1f       	adc	r25, r25
    5c0a:	88 0f       	add	r24, r24
    5c0c:	99 1f       	adc	r25, r25
    5c0e:	88 0f       	add	r24, r24
    5c10:	99 1f       	adc	r25, r25
    5c12:	82 0f       	add	r24, r18
    5c14:	93 1f       	adc	r25, r19
    5c16:	fc 01       	movw	r30, r24
    5c18:	e8 59       	subi	r30, 0x98	; 152
    5c1a:	f8 4f       	sbci	r31, 0xF8	; 248
    5c1c:	80 81       	ld	r24, Z
    5c1e:	8f 5f       	subi	r24, 0xFF	; 255
    5c20:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    5c22:	0f 90       	pop	r0
    5c24:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    5c26:	80 91 5d 07 	lds	r24, 0x075D
    5c2a:	88 23       	and	r24, r24
    5c2c:	61 f0       	breq	.+24     	; 0x5c46 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    5c2e:	e0 91 56 07 	lds	r30, 0x0756
    5c32:	f0 91 57 07 	lds	r31, 0x0757
    5c36:	96 89       	ldd	r25, Z+22	; 0x16
    5c38:	eb 81       	ldd	r30, Y+3	; 0x03
    5c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    5c3c:	86 89       	ldd	r24, Z+22	; 0x16
    5c3e:	98 17       	cp	r25, r24
    5c40:	10 f4       	brcc	.+4      	; 0x5c46 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    5c42:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    5c46:	0f 90       	pop	r0
    5c48:	0f 90       	pop	r0
    5c4a:	0f 90       	pop	r0
    5c4c:	0f 90       	pop	r0
    5c4e:	cf 91       	pop	r28
    5c50:	df 91       	pop	r29
    5c52:	08 95       	ret

00005c54 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    5c54:	df 93       	push	r29
    5c56:	cf 93       	push	r28
    5c58:	00 d0       	rcall	.+0      	; 0x5c5a <vTaskDelete+0x6>
    5c5a:	00 d0       	rcall	.+0      	; 0x5c5c <vTaskDelete+0x8>
    5c5c:	00 d0       	rcall	.+0      	; 0x5c5e <vTaskDelete+0xa>
    5c5e:	cd b7       	in	r28, 0x3d	; 61
    5c60:	de b7       	in	r29, 0x3e	; 62
    5c62:	9c 83       	std	Y+4, r25	; 0x04
    5c64:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    5c66:	0f b6       	in	r0, 0x3f	; 63
    5c68:	f8 94       	cli
    5c6a:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    5c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    5c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    5c70:	00 97       	sbiw	r24, 0x00	; 0
    5c72:	39 f4       	brne	.+14     	; 0x5c82 <vTaskDelete+0x2e>
    5c74:	80 91 56 07 	lds	r24, 0x0756
    5c78:	90 91 57 07 	lds	r25, 0x0757
    5c7c:	9e 83       	std	Y+6, r25	; 0x06
    5c7e:	8d 83       	std	Y+5, r24	; 0x05
    5c80:	04 c0       	rjmp	.+8      	; 0x5c8a <vTaskDelete+0x36>
    5c82:	8b 81       	ldd	r24, Y+3	; 0x03
    5c84:	9c 81       	ldd	r25, Y+4	; 0x04
    5c86:	9e 83       	std	Y+6, r25	; 0x06
    5c88:	8d 83       	std	Y+5, r24	; 0x05
    5c8a:	8d 81       	ldd	r24, Y+5	; 0x05
    5c8c:	9e 81       	ldd	r25, Y+6	; 0x06
    5c8e:	9a 83       	std	Y+2, r25	; 0x02
    5c90:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5c92:	89 81       	ldd	r24, Y+1	; 0x01
    5c94:	9a 81       	ldd	r25, Y+2	; 0x02
    5c96:	02 96       	adiw	r24, 0x02	; 2
    5c98:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5c9c:	e9 81       	ldd	r30, Y+1	; 0x01
    5c9e:	fa 81       	ldd	r31, Y+2	; 0x02
    5ca0:	84 89       	ldd	r24, Z+20	; 0x14
    5ca2:	95 89       	ldd	r25, Z+21	; 0x15
    5ca4:	00 97       	sbiw	r24, 0x00	; 0
    5ca6:	29 f0       	breq	.+10     	; 0x5cb2 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5ca8:	89 81       	ldd	r24, Y+1	; 0x01
    5caa:	9a 81       	ldd	r25, Y+2	; 0x02
    5cac:	0c 96       	adiw	r24, 0x0c	; 12
    5cae:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    5cb2:	80 91 62 07 	lds	r24, 0x0762
    5cb6:	8f 5f       	subi	r24, 0xFF	; 255
    5cb8:	80 93 62 07 	sts	0x0762, r24

            if( pxTCB == pxCurrentTCB )
    5cbc:	20 91 56 07 	lds	r18, 0x0756
    5cc0:	30 91 57 07 	lds	r19, 0x0757
    5cc4:	89 81       	ldd	r24, Y+1	; 0x01
    5cc6:	9a 81       	ldd	r25, Y+2	; 0x02
    5cc8:	82 17       	cp	r24, r18
    5cca:	93 07       	cpc	r25, r19
    5ccc:	81 f4       	brne	.+32     	; 0x5cee <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    5cce:	89 81       	ldd	r24, Y+1	; 0x01
    5cd0:	9a 81       	ldd	r25, Y+2	; 0x02
    5cd2:	9c 01       	movw	r18, r24
    5cd4:	2e 5f       	subi	r18, 0xFE	; 254
    5cd6:	3f 4f       	sbci	r19, 0xFF	; 255
    5cd8:	8b ea       	ldi	r24, 0xAB	; 171
    5cda:	97 e0       	ldi	r25, 0x07	; 7
    5cdc:	b9 01       	movw	r22, r18
    5cde:	0e 94 14 18 	call	0x3028	; 0x3028 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    5ce2:	80 91 58 07 	lds	r24, 0x0758
    5ce6:	8f 5f       	subi	r24, 0xFF	; 255
    5ce8:	80 93 58 07 	sts	0x0758, r24
    5cec:	07 c0       	rjmp	.+14     	; 0x5cfc <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    5cee:	80 91 59 07 	lds	r24, 0x0759
    5cf2:	81 50       	subi	r24, 0x01	; 1
    5cf4:	80 93 59 07 	sts	0x0759, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    5cf8:	0e 94 97 39 	call	0x732e	; 0x732e <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    5cfc:	0f 90       	pop	r0
    5cfe:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    5d00:	20 91 56 07 	lds	r18, 0x0756
    5d04:	30 91 57 07 	lds	r19, 0x0757
    5d08:	89 81       	ldd	r24, Y+1	; 0x01
    5d0a:	9a 81       	ldd	r25, Y+2	; 0x02
    5d0c:	82 17       	cp	r24, r18
    5d0e:	93 07       	cpc	r25, r19
    5d10:	21 f0       	breq	.+8      	; 0x5d1a <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    5d12:	89 81       	ldd	r24, Y+1	; 0x01
    5d14:	9a 81       	ldd	r25, Y+2	; 0x02
    5d16:	0e 94 81 39 	call	0x7302	; 0x7302 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    5d1a:	80 91 5d 07 	lds	r24, 0x075D
    5d1e:	88 23       	and	r24, r24
    5d20:	59 f0       	breq	.+22     	; 0x5d38 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    5d22:	20 91 56 07 	lds	r18, 0x0756
    5d26:	30 91 57 07 	lds	r19, 0x0757
    5d2a:	89 81       	ldd	r24, Y+1	; 0x01
    5d2c:	9a 81       	ldd	r25, Y+2	; 0x02
    5d2e:	82 17       	cp	r24, r18
    5d30:	93 07       	cpc	r25, r19
    5d32:	11 f4       	brne	.+4      	; 0x5d38 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    5d34:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    5d38:	26 96       	adiw	r28, 0x06	; 6
    5d3a:	0f b6       	in	r0, 0x3f	; 63
    5d3c:	f8 94       	cli
    5d3e:	de bf       	out	0x3e, r29	; 62
    5d40:	0f be       	out	0x3f, r0	; 63
    5d42:	cd bf       	out	0x3d, r28	; 61
    5d44:	cf 91       	pop	r28
    5d46:	df 91       	pop	r29
    5d48:	08 95       	ret

00005d4a <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    5d4a:	df 93       	push	r29
    5d4c:	cf 93       	push	r28
    5d4e:	cd b7       	in	r28, 0x3d	; 61
    5d50:	de b7       	in	r29, 0x3e	; 62
    5d52:	2a 97       	sbiw	r28, 0x0a	; 10
    5d54:	0f b6       	in	r0, 0x3f	; 63
    5d56:	f8 94       	cli
    5d58:	de bf       	out	0x3e, r29	; 62
    5d5a:	0f be       	out	0x3f, r0	; 63
    5d5c:	cd bf       	out	0x3d, r28	; 61
    5d5e:	98 87       	std	Y+8, r25	; 0x08
    5d60:	8f 83       	std	Y+7, r24	; 0x07
    5d62:	7a 87       	std	Y+10, r23	; 0x0a
    5d64:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    5d66:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    5d68:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    5d6c:	80 91 5a 07 	lds	r24, 0x075A
    5d70:	90 91 5b 07 	lds	r25, 0x075B
    5d74:	9a 83       	std	Y+2, r25	; 0x02
    5d76:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5d78:	ef 81       	ldd	r30, Y+7	; 0x07
    5d7a:	f8 85       	ldd	r31, Y+8	; 0x08
    5d7c:	20 81       	ld	r18, Z
    5d7e:	31 81       	ldd	r19, Z+1	; 0x01
    5d80:	89 85       	ldd	r24, Y+9	; 0x09
    5d82:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d84:	82 0f       	add	r24, r18
    5d86:	93 1f       	adc	r25, r19
    5d88:	9e 83       	std	Y+6, r25	; 0x06
    5d8a:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    5d8c:	ef 81       	ldd	r30, Y+7	; 0x07
    5d8e:	f8 85       	ldd	r31, Y+8	; 0x08
    5d90:	20 81       	ld	r18, Z
    5d92:	31 81       	ldd	r19, Z+1	; 0x01
    5d94:	89 81       	ldd	r24, Y+1	; 0x01
    5d96:	9a 81       	ldd	r25, Y+2	; 0x02
    5d98:	82 17       	cp	r24, r18
    5d9a:	93 07       	cpc	r25, r19
    5d9c:	98 f4       	brcc	.+38     	; 0x5dc4 <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    5d9e:	ef 81       	ldd	r30, Y+7	; 0x07
    5da0:	f8 85       	ldd	r31, Y+8	; 0x08
    5da2:	20 81       	ld	r18, Z
    5da4:	31 81       	ldd	r19, Z+1	; 0x01
    5da6:	8d 81       	ldd	r24, Y+5	; 0x05
    5da8:	9e 81       	ldd	r25, Y+6	; 0x06
    5daa:	82 17       	cp	r24, r18
    5dac:	93 07       	cpc	r25, r19
    5dae:	e0 f4       	brcc	.+56     	; 0x5de8 <xTaskDelayUntil+0x9e>
    5db0:	2d 81       	ldd	r18, Y+5	; 0x05
    5db2:	3e 81       	ldd	r19, Y+6	; 0x06
    5db4:	89 81       	ldd	r24, Y+1	; 0x01
    5db6:	9a 81       	ldd	r25, Y+2	; 0x02
    5db8:	82 17       	cp	r24, r18
    5dba:	93 07       	cpc	r25, r19
    5dbc:	a8 f4       	brcc	.+42     	; 0x5de8 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    5dbe:	81 e0       	ldi	r24, 0x01	; 1
    5dc0:	8b 83       	std	Y+3, r24	; 0x03
    5dc2:	12 c0       	rjmp	.+36     	; 0x5de8 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    5dc4:	ef 81       	ldd	r30, Y+7	; 0x07
    5dc6:	f8 85       	ldd	r31, Y+8	; 0x08
    5dc8:	20 81       	ld	r18, Z
    5dca:	31 81       	ldd	r19, Z+1	; 0x01
    5dcc:	8d 81       	ldd	r24, Y+5	; 0x05
    5dce:	9e 81       	ldd	r25, Y+6	; 0x06
    5dd0:	82 17       	cp	r24, r18
    5dd2:	93 07       	cpc	r25, r19
    5dd4:	38 f0       	brcs	.+14     	; 0x5de4 <xTaskDelayUntil+0x9a>
    5dd6:	2d 81       	ldd	r18, Y+5	; 0x05
    5dd8:	3e 81       	ldd	r19, Y+6	; 0x06
    5dda:	89 81       	ldd	r24, Y+1	; 0x01
    5ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    5dde:	82 17       	cp	r24, r18
    5de0:	93 07       	cpc	r25, r19
    5de2:	10 f4       	brcc	.+4      	; 0x5de8 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    5de4:	81 e0       	ldi	r24, 0x01	; 1
    5de6:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    5de8:	ef 81       	ldd	r30, Y+7	; 0x07
    5dea:	f8 85       	ldd	r31, Y+8	; 0x08
    5dec:	8d 81       	ldd	r24, Y+5	; 0x05
    5dee:	9e 81       	ldd	r25, Y+6	; 0x06
    5df0:	91 83       	std	Z+1, r25	; 0x01
    5df2:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    5df4:	8b 81       	ldd	r24, Y+3	; 0x03
    5df6:	88 23       	and	r24, r24
    5df8:	49 f0       	breq	.+18     	; 0x5e0c <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    5dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    5dfc:	9e 81       	ldd	r25, Y+6	; 0x06
    5dfe:	29 81       	ldd	r18, Y+1	; 0x01
    5e00:	3a 81       	ldd	r19, Y+2	; 0x02
    5e02:	82 1b       	sub	r24, r18
    5e04:	93 0b       	sbc	r25, r19
    5e06:	60 e0       	ldi	r22, 0x00	; 0
    5e08:	0e 94 04 44 	call	0x8808	; 0x8808 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    5e0c:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    5e10:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    5e12:	8c 81       	ldd	r24, Y+4	; 0x04
    5e14:	88 23       	and	r24, r24
    5e16:	11 f4       	brne	.+4      	; 0x5e1c <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    5e18:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    5e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    5e1e:	2a 96       	adiw	r28, 0x0a	; 10
    5e20:	0f b6       	in	r0, 0x3f	; 63
    5e22:	f8 94       	cli
    5e24:	de bf       	out	0x3e, r29	; 62
    5e26:	0f be       	out	0x3f, r0	; 63
    5e28:	cd bf       	out	0x3d, r28	; 61
    5e2a:	cf 91       	pop	r28
    5e2c:	df 91       	pop	r29
    5e2e:	08 95       	ret

00005e30 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    5e30:	df 93       	push	r29
    5e32:	cf 93       	push	r28
    5e34:	00 d0       	rcall	.+0      	; 0x5e36 <vTaskDelay+0x6>
    5e36:	0f 92       	push	r0
    5e38:	cd b7       	in	r28, 0x3d	; 61
    5e3a:	de b7       	in	r29, 0x3e	; 62
    5e3c:	9b 83       	std	Y+3, r25	; 0x03
    5e3e:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    5e40:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    5e42:	8a 81       	ldd	r24, Y+2	; 0x02
    5e44:	9b 81       	ldd	r25, Y+3	; 0x03
    5e46:	00 97       	sbiw	r24, 0x00	; 0
    5e48:	51 f0       	breq	.+20     	; 0x5e5e <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    5e4a:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    5e4e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e50:	9b 81       	ldd	r25, Y+3	; 0x03
    5e52:	60 e0       	ldi	r22, 0x00	; 0
    5e54:	0e 94 04 44 	call	0x8808	; 0x8808 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    5e58:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    5e5c:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    5e5e:	89 81       	ldd	r24, Y+1	; 0x01
    5e60:	88 23       	and	r24, r24
    5e62:	11 f4       	brne	.+4      	; 0x5e68 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    5e64:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    5e68:	0f 90       	pop	r0
    5e6a:	0f 90       	pop	r0
    5e6c:	0f 90       	pop	r0
    5e6e:	cf 91       	pop	r28
    5e70:	df 91       	pop	r29
    5e72:	08 95       	ret

00005e74 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskSuspend( TaskHandle_t xTaskToSuspend )
    {
    5e74:	df 93       	push	r29
    5e76:	cf 93       	push	r28
    5e78:	cd b7       	in	r28, 0x3d	; 61
    5e7a:	de b7       	in	r29, 0x3e	; 62
    5e7c:	27 97       	sbiw	r28, 0x07	; 7
    5e7e:	0f b6       	in	r0, 0x3f	; 63
    5e80:	f8 94       	cli
    5e82:	de bf       	out	0x3e, r29	; 62
    5e84:	0f be       	out	0x3f, r0	; 63
    5e86:	cd bf       	out	0x3d, r28	; 61
    5e88:	9d 83       	std	Y+5, r25	; 0x05
    5e8a:	8c 83       	std	Y+4, r24	; 0x04
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    5e8c:	0f b6       	in	r0, 0x3f	; 63
    5e8e:	f8 94       	cli
    5e90:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the running task that is
             * being suspended. */
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    5e92:	8c 81       	ldd	r24, Y+4	; 0x04
    5e94:	9d 81       	ldd	r25, Y+5	; 0x05
    5e96:	00 97       	sbiw	r24, 0x00	; 0
    5e98:	39 f4       	brne	.+14     	; 0x5ea8 <vTaskSuspend+0x34>
    5e9a:	80 91 56 07 	lds	r24, 0x0756
    5e9e:	90 91 57 07 	lds	r25, 0x0757
    5ea2:	9f 83       	std	Y+7, r25	; 0x07
    5ea4:	8e 83       	std	Y+6, r24	; 0x06
    5ea6:	04 c0       	rjmp	.+8      	; 0x5eb0 <vTaskSuspend+0x3c>
    5ea8:	8c 81       	ldd	r24, Y+4	; 0x04
    5eaa:	9d 81       	ldd	r25, Y+5	; 0x05
    5eac:	9f 83       	std	Y+7, r25	; 0x07
    5eae:	8e 83       	std	Y+6, r24	; 0x06
    5eb0:	8e 81       	ldd	r24, Y+6	; 0x06
    5eb2:	9f 81       	ldd	r25, Y+7	; 0x07
    5eb4:	9b 83       	std	Y+3, r25	; 0x03
    5eb6:	8a 83       	std	Y+2, r24	; 0x02

            traceTASK_SUSPEND( pxTCB );

            /* Remove task from the ready/delayed list and place in the
             * suspended list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5eb8:	8a 81       	ldd	r24, Y+2	; 0x02
    5eba:	9b 81       	ldd	r25, Y+3	; 0x03
    5ebc:	02 96       	adiw	r24, 0x02	; 2
    5ebe:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5ec2:	ea 81       	ldd	r30, Y+2	; 0x02
    5ec4:	fb 81       	ldd	r31, Y+3	; 0x03
    5ec6:	84 89       	ldd	r24, Z+20	; 0x14
    5ec8:	95 89       	ldd	r25, Z+21	; 0x15
    5eca:	00 97       	sbiw	r24, 0x00	; 0
    5ecc:	29 f0       	breq	.+10     	; 0x5ed8 <vTaskSuspend+0x64>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5ece:	8a 81       	ldd	r24, Y+2	; 0x02
    5ed0:	9b 81       	ldd	r25, Y+3	; 0x03
    5ed2:	0c 96       	adiw	r24, 0x0c	; 12
    5ed4:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    5ed8:	8a 81       	ldd	r24, Y+2	; 0x02
    5eda:	9b 81       	ldd	r25, Y+3	; 0x03
    5edc:	9c 01       	movw	r18, r24
    5ede:	2e 5f       	subi	r18, 0xFE	; 254
    5ee0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ee2:	84 eb       	ldi	r24, 0xB4	; 180
    5ee4:	97 e0       	ldi	r25, 0x07	; 7
    5ee6:	b9 01       	movw	r22, r18
    5ee8:	0e 94 14 18 	call	0x3028	; 0x3028 <vListInsertEnd>

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    5eec:	19 82       	std	Y+1, r1	; 0x01
    5eee:	1d c0       	rjmp	.+58     	; 0x5f2a <vTaskSuspend+0xb6>
                {
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
    5ef0:	89 81       	ldd	r24, Y+1	; 0x01
    5ef2:	28 2f       	mov	r18, r24
    5ef4:	33 27       	eor	r19, r19
    5ef6:	27 fd       	sbrc	r18, 7
    5ef8:	30 95       	com	r19
    5efa:	8a 81       	ldd	r24, Y+2	; 0x02
    5efc:	9b 81       	ldd	r25, Y+3	; 0x03
    5efe:	82 0f       	add	r24, r18
    5f00:	93 1f       	adc	r25, r19
    5f02:	fc 01       	movw	r30, r24
    5f04:	b7 96       	adiw	r30, 0x27	; 39
    5f06:	80 81       	ld	r24, Z
    5f08:	81 30       	cpi	r24, 0x01	; 1
    5f0a:	61 f4       	brne	.+24     	; 0x5f24 <vTaskSuspend+0xb0>
                    {
                        /* The task was blocked to wait for a notification, but is
                         * now suspended, so no notification was received. */
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
    5f0c:	89 81       	ldd	r24, Y+1	; 0x01
    5f0e:	28 2f       	mov	r18, r24
    5f10:	33 27       	eor	r19, r19
    5f12:	27 fd       	sbrc	r18, 7
    5f14:	30 95       	com	r19
    5f16:	8a 81       	ldd	r24, Y+2	; 0x02
    5f18:	9b 81       	ldd	r25, Y+3	; 0x03
    5f1a:	82 0f       	add	r24, r18
    5f1c:	93 1f       	adc	r25, r19
    5f1e:	fc 01       	movw	r30, r24
    5f20:	b7 96       	adiw	r30, 0x27	; 39
    5f22:	10 82       	st	Z, r1

            #if ( configUSE_TASK_NOTIFICATIONS == 1 )
            {
                BaseType_t x;

                for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
    5f24:	89 81       	ldd	r24, Y+1	; 0x01
    5f26:	8f 5f       	subi	r24, 0xFF	; 255
    5f28:	89 83       	std	Y+1, r24	; 0x01
    5f2a:	89 81       	ldd	r24, Y+1	; 0x01
    5f2c:	18 16       	cp	r1, r24
    5f2e:	04 f7       	brge	.-64     	; 0x5ef0 <vTaskSuspend+0x7c>
                    }
                }
            }
            #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
        }
        taskEXIT_CRITICAL();
    5f30:	0f 90       	pop	r0
    5f32:	0f be       	out	0x3f, r0	; 63

        if( xSchedulerRunning != pdFALSE )
    5f34:	80 91 5d 07 	lds	r24, 0x075D
    5f38:	88 23       	and	r24, r24
    5f3a:	39 f0       	breq	.+14     	; 0x5f4a <vTaskSuspend+0xd6>
        {
            /* Reset the next expected unblock time in case it referred to the
             * task that is now in the Suspended state. */
            taskENTER_CRITICAL();
    5f3c:	0f b6       	in	r0, 0x3f	; 63
    5f3e:	f8 94       	cli
    5f40:	0f 92       	push	r0
            {
                prvResetNextTaskUnblockTime();
    5f42:	0e 94 97 39 	call	0x732e	; 0x732e <prvResetNextTaskUnblockTime>
            }
            taskEXIT_CRITICAL();
    5f46:	0f 90       	pop	r0
    5f48:	0f be       	out	0x3f, r0	; 63
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( pxTCB == pxCurrentTCB )
    5f4a:	20 91 56 07 	lds	r18, 0x0756
    5f4e:	30 91 57 07 	lds	r19, 0x0757
    5f52:	8a 81       	ldd	r24, Y+2	; 0x02
    5f54:	9b 81       	ldd	r25, Y+3	; 0x03
    5f56:	82 17       	cp	r24, r18
    5f58:	93 07       	cpc	r25, r19
    5f5a:	a1 f4       	brne	.+40     	; 0x5f84 <vTaskSuspend+0x110>
        {
            if( xSchedulerRunning != pdFALSE )
    5f5c:	80 91 5d 07 	lds	r24, 0x075D
    5f60:	88 23       	and	r24, r24
    5f62:	19 f0       	breq	.+6      	; 0x5f6a <vTaskSuspend+0xf6>
            {
                /* The current task has just been suspended. */
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    5f64:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    5f68:	0d c0       	rjmp	.+26     	; 0x5f84 <vTaskSuspend+0x110>
            else
            {
                /* The scheduler is not running, but the task that was pointed
                 * to by pxCurrentTCB has just been suspended and pxCurrentTCB
                 * must be adjusted to point to a different task. */
                if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    5f6a:	90 91 b4 07 	lds	r25, 0x07B4
    5f6e:	80 91 59 07 	lds	r24, 0x0759
    5f72:	98 17       	cp	r25, r24
    5f74:	29 f4       	brne	.+10     	; 0x5f80 <vTaskSuspend+0x10c>
                {
                    /* No other tasks are ready, so set pxCurrentTCB back to
                     * NULL so when the next task is created pxCurrentTCB will
                     * be set to point to it no matter what its relative priority
                     * is. */
                    pxCurrentTCB = NULL;
    5f76:	10 92 57 07 	sts	0x0757, r1
    5f7a:	10 92 56 07 	sts	0x0756, r1
    5f7e:	02 c0       	rjmp	.+4      	; 0x5f84 <vTaskSuspend+0x110>
                }
                else
                {
                    vTaskSwitchContext();
    5f80:	0e 94 09 35 	call	0x6a12	; 0x6a12 <vTaskSwitchContext>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    5f84:	27 96       	adiw	r28, 0x07	; 7
    5f86:	0f b6       	in	r0, 0x3f	; 63
    5f88:	f8 94       	cli
    5f8a:	de bf       	out	0x3e, r29	; 62
    5f8c:	0f be       	out	0x3f, r0	; 63
    5f8e:	cd bf       	out	0x3d, r28	; 61
    5f90:	cf 91       	pop	r28
    5f92:	df 91       	pop	r29
    5f94:	08 95       	ret

00005f96 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
    {
    5f96:	df 93       	push	r29
    5f98:	cf 93       	push	r28
    5f9a:	00 d0       	rcall	.+0      	; 0x5f9c <prvTaskIsTaskSuspended+0x6>
    5f9c:	00 d0       	rcall	.+0      	; 0x5f9e <prvTaskIsTaskSuspended+0x8>
    5f9e:	0f 92       	push	r0
    5fa0:	cd b7       	in	r28, 0x3d	; 61
    5fa2:	de b7       	in	r29, 0x3e	; 62
    5fa4:	9d 83       	std	Y+5, r25	; 0x05
    5fa6:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn = pdFALSE;
    5fa8:	1b 82       	std	Y+3, r1	; 0x03
        const TCB_t * const pxTCB = xTask;
    5faa:	8c 81       	ldd	r24, Y+4	; 0x04
    5fac:	9d 81       	ldd	r25, Y+5	; 0x05
    5fae:	9a 83       	std	Y+2, r25	; 0x02
    5fb0:	89 83       	std	Y+1, r24	; 0x01

        /* It does not make sense to check if the calling task is suspended. */
        configASSERT( xTask );

        /* Is the task being resumed actually in the suspended list? */
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    5fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    5fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    5fb6:	82 85       	ldd	r24, Z+10	; 0x0a
    5fb8:	93 85       	ldd	r25, Z+11	; 0x0b
    5fba:	27 e0       	ldi	r18, 0x07	; 7
    5fbc:	84 3b       	cpi	r24, 0xB4	; 180
    5fbe:	92 07       	cpc	r25, r18
    5fc0:	81 f4       	brne	.+32     	; 0x5fe2 <prvTaskIsTaskSuspended+0x4c>
        {
            /* Has the task already been resumed from within an ISR? */
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    5fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    5fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    5fc6:	84 89       	ldd	r24, Z+20	; 0x14
    5fc8:	95 89       	ldd	r25, Z+21	; 0x15
    5fca:	27 e0       	ldi	r18, 0x07	; 7
    5fcc:	82 3a       	cpi	r24, 0xA2	; 162
    5fce:	92 07       	cpc	r25, r18
    5fd0:	41 f0       	breq	.+16     	; 0x5fe2 <prvTaskIsTaskSuspended+0x4c>
            {
                /* Is it in the suspended list because it is in the Suspended
                 * state, or because is is blocked with no timeout? */
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    5fd2:	e9 81       	ldd	r30, Y+1	; 0x01
    5fd4:	fa 81       	ldd	r31, Y+2	; 0x02
    5fd6:	84 89       	ldd	r24, Z+20	; 0x14
    5fd8:	95 89       	ldd	r25, Z+21	; 0x15
    5fda:	00 97       	sbiw	r24, 0x00	; 0
    5fdc:	11 f4       	brne	.+4      	; 0x5fe2 <prvTaskIsTaskSuspended+0x4c>
                {
                    xReturn = pdTRUE;
    5fde:	81 e0       	ldi	r24, 0x01	; 1
    5fe0:	8b 83       	std	Y+3, r24	; 0x03
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    5fe2:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    5fe4:	0f 90       	pop	r0
    5fe6:	0f 90       	pop	r0
    5fe8:	0f 90       	pop	r0
    5fea:	0f 90       	pop	r0
    5fec:	0f 90       	pop	r0
    5fee:	cf 91       	pop	r28
    5ff0:	df 91       	pop	r29
    5ff2:	08 95       	ret

00005ff4 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

    void vTaskResume( TaskHandle_t xTaskToResume )
    {
    5ff4:	df 93       	push	r29
    5ff6:	cf 93       	push	r28
    5ff8:	00 d0       	rcall	.+0      	; 0x5ffa <vTaskResume+0x6>
    5ffa:	00 d0       	rcall	.+0      	; 0x5ffc <vTaskResume+0x8>
    5ffc:	00 d0       	rcall	.+0      	; 0x5ffe <vTaskResume+0xa>
    5ffe:	cd b7       	in	r28, 0x3d	; 61
    6000:	de b7       	in	r29, 0x3e	; 62
    6002:	9e 83       	std	Y+6, r25	; 0x06
    6004:	8d 83       	std	Y+5, r24	; 0x05
        TCB_t * const pxTCB = xTaskToResume;
    6006:	8d 81       	ldd	r24, Y+5	; 0x05
    6008:	9e 81       	ldd	r25, Y+6	; 0x06
    600a:	9c 83       	std	Y+4, r25	; 0x04
    600c:	8b 83       	std	Y+3, r24	; 0x03
        /* It does not make sense to resume the calling task. */
        configASSERT( xTaskToResume );

        /* The parameter cannot be NULL as it is impossible to resume the
         * currently executing task. */
        if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    600e:	20 91 56 07 	lds	r18, 0x0756
    6012:	30 91 57 07 	lds	r19, 0x0757
    6016:	8b 81       	ldd	r24, Y+3	; 0x03
    6018:	9c 81       	ldd	r25, Y+4	; 0x04
    601a:	82 17       	cp	r24, r18
    601c:	93 07       	cpc	r25, r19
    601e:	09 f4       	brne	.+2      	; 0x6022 <vTaskResume+0x2e>
    6020:	8a c0       	rjmp	.+276    	; 0x6136 <vTaskResume+0x142>
    6022:	8b 81       	ldd	r24, Y+3	; 0x03
    6024:	9c 81       	ldd	r25, Y+4	; 0x04
    6026:	00 97       	sbiw	r24, 0x00	; 0
    6028:	09 f4       	brne	.+2      	; 0x602c <vTaskResume+0x38>
    602a:	85 c0       	rjmp	.+266    	; 0x6136 <vTaskResume+0x142>
        {
            taskENTER_CRITICAL();
    602c:	0f b6       	in	r0, 0x3f	; 63
    602e:	f8 94       	cli
    6030:	0f 92       	push	r0
            {
                if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    6032:	8b 81       	ldd	r24, Y+3	; 0x03
    6034:	9c 81       	ldd	r25, Y+4	; 0x04
    6036:	0e 94 cb 2f 	call	0x5f96	; 0x5f96 <prvTaskIsTaskSuspended>
    603a:	88 23       	and	r24, r24
    603c:	09 f4       	brne	.+2      	; 0x6040 <vTaskResume+0x4c>
    603e:	79 c0       	rjmp	.+242    	; 0x6132 <vTaskResume+0x13e>
                {
                    traceTASK_RESUME( pxTCB );

                    /* The ready list can be accessed even if the scheduler is
                     * suspended because this is inside a critical section. */
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6040:	8b 81       	ldd	r24, Y+3	; 0x03
    6042:	9c 81       	ldd	r25, Y+4	; 0x04
    6044:	02 96       	adiw	r24, 0x02	; 2
    6046:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    604a:	eb 81       	ldd	r30, Y+3	; 0x03
    604c:	fc 81       	ldd	r31, Y+4	; 0x04
    604e:	96 89       	ldd	r25, Z+22	; 0x16
    6050:	80 91 5c 07 	lds	r24, 0x075C
    6054:	89 17       	cp	r24, r25
    6056:	28 f4       	brcc	.+10     	; 0x6062 <vTaskResume+0x6e>
    6058:	eb 81       	ldd	r30, Y+3	; 0x03
    605a:	fc 81       	ldd	r31, Y+4	; 0x04
    605c:	86 89       	ldd	r24, Z+22	; 0x16
    605e:	80 93 5c 07 	sts	0x075C, r24
    6062:	eb 81       	ldd	r30, Y+3	; 0x03
    6064:	fc 81       	ldd	r31, Y+4	; 0x04
    6066:	86 89       	ldd	r24, Z+22	; 0x16
    6068:	28 2f       	mov	r18, r24
    606a:	30 e0       	ldi	r19, 0x00	; 0
    606c:	c9 01       	movw	r24, r18
    606e:	88 0f       	add	r24, r24
    6070:	99 1f       	adc	r25, r25
    6072:	88 0f       	add	r24, r24
    6074:	99 1f       	adc	r25, r25
    6076:	88 0f       	add	r24, r24
    6078:	99 1f       	adc	r25, r25
    607a:	82 0f       	add	r24, r18
    607c:	93 1f       	adc	r25, r19
    607e:	fc 01       	movw	r30, r24
    6080:	e8 59       	subi	r30, 0x98	; 152
    6082:	f8 4f       	sbci	r31, 0xF8	; 248
    6084:	81 81       	ldd	r24, Z+1	; 0x01
    6086:	92 81       	ldd	r25, Z+2	; 0x02
    6088:	9a 83       	std	Y+2, r25	; 0x02
    608a:	89 83       	std	Y+1, r24	; 0x01
    608c:	eb 81       	ldd	r30, Y+3	; 0x03
    608e:	fc 81       	ldd	r31, Y+4	; 0x04
    6090:	89 81       	ldd	r24, Y+1	; 0x01
    6092:	9a 81       	ldd	r25, Y+2	; 0x02
    6094:	95 83       	std	Z+5, r25	; 0x05
    6096:	84 83       	std	Z+4, r24	; 0x04
    6098:	e9 81       	ldd	r30, Y+1	; 0x01
    609a:	fa 81       	ldd	r31, Y+2	; 0x02
    609c:	84 81       	ldd	r24, Z+4	; 0x04
    609e:	95 81       	ldd	r25, Z+5	; 0x05
    60a0:	eb 81       	ldd	r30, Y+3	; 0x03
    60a2:	fc 81       	ldd	r31, Y+4	; 0x04
    60a4:	97 83       	std	Z+7, r25	; 0x07
    60a6:	86 83       	std	Z+6, r24	; 0x06
    60a8:	e9 81       	ldd	r30, Y+1	; 0x01
    60aa:	fa 81       	ldd	r31, Y+2	; 0x02
    60ac:	04 80       	ldd	r0, Z+4	; 0x04
    60ae:	f5 81       	ldd	r31, Z+5	; 0x05
    60b0:	e0 2d       	mov	r30, r0
    60b2:	8b 81       	ldd	r24, Y+3	; 0x03
    60b4:	9c 81       	ldd	r25, Y+4	; 0x04
    60b6:	02 96       	adiw	r24, 0x02	; 2
    60b8:	93 83       	std	Z+3, r25	; 0x03
    60ba:	82 83       	std	Z+2, r24	; 0x02
    60bc:	8b 81       	ldd	r24, Y+3	; 0x03
    60be:	9c 81       	ldd	r25, Y+4	; 0x04
    60c0:	02 96       	adiw	r24, 0x02	; 2
    60c2:	e9 81       	ldd	r30, Y+1	; 0x01
    60c4:	fa 81       	ldd	r31, Y+2	; 0x02
    60c6:	95 83       	std	Z+5, r25	; 0x05
    60c8:	84 83       	std	Z+4, r24	; 0x04
    60ca:	eb 81       	ldd	r30, Y+3	; 0x03
    60cc:	fc 81       	ldd	r31, Y+4	; 0x04
    60ce:	86 89       	ldd	r24, Z+22	; 0x16
    60d0:	28 2f       	mov	r18, r24
    60d2:	30 e0       	ldi	r19, 0x00	; 0
    60d4:	c9 01       	movw	r24, r18
    60d6:	88 0f       	add	r24, r24
    60d8:	99 1f       	adc	r25, r25
    60da:	88 0f       	add	r24, r24
    60dc:	99 1f       	adc	r25, r25
    60de:	88 0f       	add	r24, r24
    60e0:	99 1f       	adc	r25, r25
    60e2:	82 0f       	add	r24, r18
    60e4:	93 1f       	adc	r25, r19
    60e6:	88 59       	subi	r24, 0x98	; 152
    60e8:	98 4f       	sbci	r25, 0xF8	; 248
    60ea:	eb 81       	ldd	r30, Y+3	; 0x03
    60ec:	fc 81       	ldd	r31, Y+4	; 0x04
    60ee:	93 87       	std	Z+11, r25	; 0x0b
    60f0:	82 87       	std	Z+10, r24	; 0x0a
    60f2:	eb 81       	ldd	r30, Y+3	; 0x03
    60f4:	fc 81       	ldd	r31, Y+4	; 0x04
    60f6:	86 89       	ldd	r24, Z+22	; 0x16
    60f8:	28 2f       	mov	r18, r24
    60fa:	30 e0       	ldi	r19, 0x00	; 0
    60fc:	c9 01       	movw	r24, r18
    60fe:	88 0f       	add	r24, r24
    6100:	99 1f       	adc	r25, r25
    6102:	88 0f       	add	r24, r24
    6104:	99 1f       	adc	r25, r25
    6106:	88 0f       	add	r24, r24
    6108:	99 1f       	adc	r25, r25
    610a:	82 0f       	add	r24, r18
    610c:	93 1f       	adc	r25, r19
    610e:	fc 01       	movw	r30, r24
    6110:	e8 59       	subi	r30, 0x98	; 152
    6112:	f8 4f       	sbci	r31, 0xF8	; 248
    6114:	80 81       	ld	r24, Z
    6116:	8f 5f       	subi	r24, 0xFF	; 255
    6118:	80 83       	st	Z, r24

                    /* A higher priority task may have just been resumed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    611a:	eb 81       	ldd	r30, Y+3	; 0x03
    611c:	fc 81       	ldd	r31, Y+4	; 0x04
    611e:	96 89       	ldd	r25, Z+22	; 0x16
    6120:	e0 91 56 07 	lds	r30, 0x0756
    6124:	f0 91 57 07 	lds	r31, 0x0757
    6128:	86 89       	ldd	r24, Z+22	; 0x16
    612a:	98 17       	cp	r25, r24
    612c:	10 f0       	brcs	.+4      	; 0x6132 <vTaskResume+0x13e>
                    {
                        /* This yield may not cause the task just resumed to run,
                         * but will leave the lists in the correct state for the
                         * next yield. */
                        taskYIELD_IF_USING_PREEMPTION();
    612e:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    6132:	0f 90       	pop	r0
    6134:	0f be       	out	0x3f, r0	; 63
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    6136:	26 96       	adiw	r28, 0x06	; 6
    6138:	0f b6       	in	r0, 0x3f	; 63
    613a:	f8 94       	cli
    613c:	de bf       	out	0x3e, r29	; 62
    613e:	0f be       	out	0x3f, r0	; 63
    6140:	cd bf       	out	0x3d, r28	; 61
    6142:	cf 91       	pop	r28
    6144:	df 91       	pop	r29
    6146:	08 95       	ret

00006148 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

    BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
    {
    6148:	df 93       	push	r29
    614a:	cf 93       	push	r28
    614c:	cd b7       	in	r28, 0x3d	; 61
    614e:	de b7       	in	r29, 0x3e	; 62
    6150:	28 97       	sbiw	r28, 0x08	; 8
    6152:	0f b6       	in	r0, 0x3f	; 63
    6154:	f8 94       	cli
    6156:	de bf       	out	0x3e, r29	; 62
    6158:	0f be       	out	0x3f, r0	; 63
    615a:	cd bf       	out	0x3d, r28	; 61
    615c:	98 87       	std	Y+8, r25	; 0x08
    615e:	8f 83       	std	Y+7, r24	; 0x07
        BaseType_t xYieldRequired = pdFALSE;
    6160:	1e 82       	std	Y+6, r1	; 0x06
        TCB_t * const pxTCB = xTaskToResume;
    6162:	8f 81       	ldd	r24, Y+7	; 0x07
    6164:	98 85       	ldd	r25, Y+8	; 0x08
    6166:	9d 83       	std	Y+5, r25	; 0x05
    6168:	8c 83       	std	Y+4, r24	; 0x04
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    616a:	1b 82       	std	Y+3, r1	; 0x03
        {
            if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    616c:	8c 81       	ldd	r24, Y+4	; 0x04
    616e:	9d 81       	ldd	r25, Y+5	; 0x05
    6170:	0e 94 cb 2f 	call	0x5f96	; 0x5f96 <prvTaskIsTaskSuspended>
    6174:	88 23       	and	r24, r24
    6176:	09 f4       	brne	.+2      	; 0x617a <xTaskResumeFromISR+0x32>
    6178:	8c c0       	rjmp	.+280    	; 0x6292 <xTaskResumeFromISR+0x14a>
            {
                traceTASK_RESUME_FROM_ISR( pxTCB );

                /* Check the ready lists can be accessed. */
                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    617a:	80 91 67 07 	lds	r24, 0x0767
    617e:	88 23       	and	r24, r24
    6180:	09 f0       	breq	.+2      	; 0x6184 <xTaskResumeFromISR+0x3c>
    6182:	7d c0       	rjmp	.+250    	; 0x627e <xTaskResumeFromISR+0x136>
                {
                    /* Ready lists can be accessed so move the task from the
                     * suspended list to the ready list directly. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6184:	ec 81       	ldd	r30, Y+4	; 0x04
    6186:	fd 81       	ldd	r31, Y+5	; 0x05
    6188:	96 89       	ldd	r25, Z+22	; 0x16
    618a:	e0 91 56 07 	lds	r30, 0x0756
    618e:	f0 91 57 07 	lds	r31, 0x0757
    6192:	86 89       	ldd	r24, Z+22	; 0x16
    6194:	98 17       	cp	r25, r24
    6196:	28 f0       	brcs	.+10     	; 0x61a2 <xTaskResumeFromISR+0x5a>
                    {
                        xYieldRequired = pdTRUE;
    6198:	81 e0       	ldi	r24, 0x01	; 1
    619a:	8e 83       	std	Y+6, r24	; 0x06

                        /* Mark that a yield is pending in case the user is not
                         * using the return value to initiate a context switch
                         * from the ISR using portYIELD_FROM_ISR. */
                        xYieldPending = pdTRUE;
    619c:	81 e0       	ldi	r24, 0x01	; 1
    619e:	80 93 60 07 	sts	0x0760, r24
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    61a2:	8c 81       	ldd	r24, Y+4	; 0x04
    61a4:	9d 81       	ldd	r25, Y+5	; 0x05
    61a6:	02 96       	adiw	r24, 0x02	; 2
    61a8:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
                    prvAddTaskToReadyList( pxTCB );
    61ac:	ec 81       	ldd	r30, Y+4	; 0x04
    61ae:	fd 81       	ldd	r31, Y+5	; 0x05
    61b0:	96 89       	ldd	r25, Z+22	; 0x16
    61b2:	80 91 5c 07 	lds	r24, 0x075C
    61b6:	89 17       	cp	r24, r25
    61b8:	28 f4       	brcc	.+10     	; 0x61c4 <xTaskResumeFromISR+0x7c>
    61ba:	ec 81       	ldd	r30, Y+4	; 0x04
    61bc:	fd 81       	ldd	r31, Y+5	; 0x05
    61be:	86 89       	ldd	r24, Z+22	; 0x16
    61c0:	80 93 5c 07 	sts	0x075C, r24
    61c4:	ec 81       	ldd	r30, Y+4	; 0x04
    61c6:	fd 81       	ldd	r31, Y+5	; 0x05
    61c8:	86 89       	ldd	r24, Z+22	; 0x16
    61ca:	28 2f       	mov	r18, r24
    61cc:	30 e0       	ldi	r19, 0x00	; 0
    61ce:	c9 01       	movw	r24, r18
    61d0:	88 0f       	add	r24, r24
    61d2:	99 1f       	adc	r25, r25
    61d4:	88 0f       	add	r24, r24
    61d6:	99 1f       	adc	r25, r25
    61d8:	88 0f       	add	r24, r24
    61da:	99 1f       	adc	r25, r25
    61dc:	82 0f       	add	r24, r18
    61de:	93 1f       	adc	r25, r19
    61e0:	fc 01       	movw	r30, r24
    61e2:	e8 59       	subi	r30, 0x98	; 152
    61e4:	f8 4f       	sbci	r31, 0xF8	; 248
    61e6:	81 81       	ldd	r24, Z+1	; 0x01
    61e8:	92 81       	ldd	r25, Z+2	; 0x02
    61ea:	9a 83       	std	Y+2, r25	; 0x02
    61ec:	89 83       	std	Y+1, r24	; 0x01
    61ee:	ec 81       	ldd	r30, Y+4	; 0x04
    61f0:	fd 81       	ldd	r31, Y+5	; 0x05
    61f2:	89 81       	ldd	r24, Y+1	; 0x01
    61f4:	9a 81       	ldd	r25, Y+2	; 0x02
    61f6:	95 83       	std	Z+5, r25	; 0x05
    61f8:	84 83       	std	Z+4, r24	; 0x04
    61fa:	e9 81       	ldd	r30, Y+1	; 0x01
    61fc:	fa 81       	ldd	r31, Y+2	; 0x02
    61fe:	84 81       	ldd	r24, Z+4	; 0x04
    6200:	95 81       	ldd	r25, Z+5	; 0x05
    6202:	ec 81       	ldd	r30, Y+4	; 0x04
    6204:	fd 81       	ldd	r31, Y+5	; 0x05
    6206:	97 83       	std	Z+7, r25	; 0x07
    6208:	86 83       	std	Z+6, r24	; 0x06
    620a:	e9 81       	ldd	r30, Y+1	; 0x01
    620c:	fa 81       	ldd	r31, Y+2	; 0x02
    620e:	04 80       	ldd	r0, Z+4	; 0x04
    6210:	f5 81       	ldd	r31, Z+5	; 0x05
    6212:	e0 2d       	mov	r30, r0
    6214:	8c 81       	ldd	r24, Y+4	; 0x04
    6216:	9d 81       	ldd	r25, Y+5	; 0x05
    6218:	02 96       	adiw	r24, 0x02	; 2
    621a:	93 83       	std	Z+3, r25	; 0x03
    621c:	82 83       	std	Z+2, r24	; 0x02
    621e:	8c 81       	ldd	r24, Y+4	; 0x04
    6220:	9d 81       	ldd	r25, Y+5	; 0x05
    6222:	02 96       	adiw	r24, 0x02	; 2
    6224:	e9 81       	ldd	r30, Y+1	; 0x01
    6226:	fa 81       	ldd	r31, Y+2	; 0x02
    6228:	95 83       	std	Z+5, r25	; 0x05
    622a:	84 83       	std	Z+4, r24	; 0x04
    622c:	ec 81       	ldd	r30, Y+4	; 0x04
    622e:	fd 81       	ldd	r31, Y+5	; 0x05
    6230:	86 89       	ldd	r24, Z+22	; 0x16
    6232:	28 2f       	mov	r18, r24
    6234:	30 e0       	ldi	r19, 0x00	; 0
    6236:	c9 01       	movw	r24, r18
    6238:	88 0f       	add	r24, r24
    623a:	99 1f       	adc	r25, r25
    623c:	88 0f       	add	r24, r24
    623e:	99 1f       	adc	r25, r25
    6240:	88 0f       	add	r24, r24
    6242:	99 1f       	adc	r25, r25
    6244:	82 0f       	add	r24, r18
    6246:	93 1f       	adc	r25, r19
    6248:	88 59       	subi	r24, 0x98	; 152
    624a:	98 4f       	sbci	r25, 0xF8	; 248
    624c:	ec 81       	ldd	r30, Y+4	; 0x04
    624e:	fd 81       	ldd	r31, Y+5	; 0x05
    6250:	93 87       	std	Z+11, r25	; 0x0b
    6252:	82 87       	std	Z+10, r24	; 0x0a
    6254:	ec 81       	ldd	r30, Y+4	; 0x04
    6256:	fd 81       	ldd	r31, Y+5	; 0x05
    6258:	86 89       	ldd	r24, Z+22	; 0x16
    625a:	28 2f       	mov	r18, r24
    625c:	30 e0       	ldi	r19, 0x00	; 0
    625e:	c9 01       	movw	r24, r18
    6260:	88 0f       	add	r24, r24
    6262:	99 1f       	adc	r25, r25
    6264:	88 0f       	add	r24, r24
    6266:	99 1f       	adc	r25, r25
    6268:	88 0f       	add	r24, r24
    626a:	99 1f       	adc	r25, r25
    626c:	82 0f       	add	r24, r18
    626e:	93 1f       	adc	r25, r19
    6270:	fc 01       	movw	r30, r24
    6272:	e8 59       	subi	r30, 0x98	; 152
    6274:	f8 4f       	sbci	r31, 0xF8	; 248
    6276:	80 81       	ld	r24, Z
    6278:	8f 5f       	subi	r24, 0xFF	; 255
    627a:	80 83       	st	Z, r24
    627c:	0a c0       	rjmp	.+20     	; 0x6292 <xTaskResumeFromISR+0x14a>
                else
                {
                    /* The delayed or ready lists cannot be accessed so the task
                     * is held in the pending ready list until the scheduler is
                     * unsuspended. */
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    627e:	8c 81       	ldd	r24, Y+4	; 0x04
    6280:	9d 81       	ldd	r25, Y+5	; 0x05
    6282:	9c 01       	movw	r18, r24
    6284:	24 5f       	subi	r18, 0xF4	; 244
    6286:	3f 4f       	sbci	r19, 0xFF	; 255
    6288:	82 ea       	ldi	r24, 0xA2	; 162
    628a:	97 e0       	ldi	r25, 0x07	; 7
    628c:	b9 01       	movw	r22, r18
    628e:	0e 94 14 18 	call	0x3028	; 0x3028 <vListInsertEnd>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xYieldRequired;
    6292:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    6294:	28 96       	adiw	r28, 0x08	; 8
    6296:	0f b6       	in	r0, 0x3f	; 63
    6298:	f8 94       	cli
    629a:	de bf       	out	0x3e, r29	; 62
    629c:	0f be       	out	0x3f, r0	; 63
    629e:	cd bf       	out	0x3d, r28	; 61
    62a0:	cf 91       	pop	r28
    62a2:	df 91       	pop	r29
    62a4:	08 95       	ret

000062a6 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    62a6:	ef 92       	push	r14
    62a8:	ff 92       	push	r15
    62aa:	0f 93       	push	r16
    62ac:	df 93       	push	r29
    62ae:	cf 93       	push	r28
    62b0:	00 d0       	rcall	.+0      	; 0x62b2 <vTaskStartScheduler+0xc>
    62b2:	cd b7       	in	r28, 0x3d	; 61
    62b4:	de b7       	in	r29, 0x3e	; 62
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    62b6:	81 e0       	ldi	r24, 0x01	; 1
    62b8:	99 e3       	ldi	r25, 0x39	; 57
    62ba:	20 e0       	ldi	r18, 0x00	; 0
    62bc:	31 e0       	ldi	r19, 0x01	; 1
    62be:	e5 e6       	ldi	r30, 0x65	; 101
    62c0:	f7 e0       	ldi	r31, 0x07	; 7
    62c2:	b9 01       	movw	r22, r18
    62c4:	45 e5       	ldi	r20, 0x55	; 85
    62c6:	50 e0       	ldi	r21, 0x00	; 0
    62c8:	20 e0       	ldi	r18, 0x00	; 0
    62ca:	30 e0       	ldi	r19, 0x00	; 0
    62cc:	00 e0       	ldi	r16, 0x00	; 0
    62ce:	7f 01       	movw	r14, r30
    62d0:	0e 94 3a 2c 	call	0x5874	; 0x5874 <xTaskCreate>
    62d4:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    62d6:	89 81       	ldd	r24, Y+1	; 0x01
    62d8:	81 30       	cpi	r24, 0x01	; 1
    62da:	81 f4       	brne	.+32     	; 0x62fc <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    62dc:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    62de:	8f ef       	ldi	r24, 0xFF	; 255
    62e0:	9f ef       	ldi	r25, 0xFF	; 255
    62e2:	90 93 64 07 	sts	0x0764, r25
    62e6:	80 93 63 07 	sts	0x0763, r24
        xSchedulerRunning = pdTRUE;
    62ea:	81 e0       	ldi	r24, 0x01	; 1
    62ec:	80 93 5d 07 	sts	0x075D, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    62f0:	10 92 5b 07 	sts	0x075B, r1
    62f4:	10 92 5a 07 	sts	0x075A, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    62f8:	0e 94 93 1a 	call	0x3526	; 0x3526 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    62fc:	80 91 5e 01 	lds	r24, 0x015E
}
    6300:	0f 90       	pop	r0
    6302:	0f 90       	pop	r0
    6304:	cf 91       	pop	r28
    6306:	df 91       	pop	r29
    6308:	0f 91       	pop	r16
    630a:	ff 90       	pop	r15
    630c:	ef 90       	pop	r14
    630e:	08 95       	ret

00006310 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    6310:	df 93       	push	r29
    6312:	cf 93       	push	r28
    6314:	cd b7       	in	r28, 0x3d	; 61
    6316:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    6318:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    631a:	10 92 5d 07 	sts	0x075D, r1
    vPortEndScheduler();
    631e:	0e 94 c8 1a 	call	0x3590	; 0x3590 <vPortEndScheduler>
}
    6322:	cf 91       	pop	r28
    6324:	df 91       	pop	r29
    6326:	08 95       	ret

00006328 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    6328:	df 93       	push	r29
    632a:	cf 93       	push	r28
    632c:	cd b7       	in	r28, 0x3d	; 61
    632e:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    6330:	80 91 67 07 	lds	r24, 0x0767
    6334:	8f 5f       	subi	r24, 0xFF	; 255
    6336:	80 93 67 07 	sts	0x0767, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    633a:	cf 91       	pop	r28
    633c:	df 91       	pop	r29
    633e:	08 95       	ret

00006340 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    6340:	df 93       	push	r29
    6342:	cf 93       	push	r28
    6344:	cd b7       	in	r28, 0x3d	; 61
    6346:	de b7       	in	r29, 0x3e	; 62
    6348:	2b 97       	sbiw	r28, 0x0b	; 11
    634a:	0f b6       	in	r0, 0x3f	; 63
    634c:	f8 94       	cli
    634e:	de bf       	out	0x3e, r29	; 62
    6350:	0f be       	out	0x3f, r0	; 63
    6352:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    6354:	1b 86       	std	Y+11, r1	; 0x0b
    6356:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    6358:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    635a:	0f b6       	in	r0, 0x3f	; 63
    635c:	f8 94       	cli
    635e:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    6360:	80 91 67 07 	lds	r24, 0x0767
    6364:	81 50       	subi	r24, 0x01	; 1
    6366:	80 93 67 07 	sts	0x0767, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    636a:	80 91 67 07 	lds	r24, 0x0767
    636e:	88 23       	and	r24, r24
    6370:	09 f0       	breq	.+2      	; 0x6374 <xTaskResumeAll+0x34>
    6372:	2a c1       	rjmp	.+596    	; 0x65c8 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    6374:	80 91 59 07 	lds	r24, 0x0759
    6378:	88 23       	and	r24, r24
    637a:	09 f4       	brne	.+2      	; 0x637e <xTaskResumeAll+0x3e>
    637c:	25 c1       	rjmp	.+586    	; 0x65c8 <xTaskResumeAll+0x288>
    637e:	f3 c0       	rjmp	.+486    	; 0x6566 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6380:	e0 91 a7 07 	lds	r30, 0x07A7
    6384:	f0 91 a8 07 	lds	r31, 0x07A8
    6388:	86 81       	ldd	r24, Z+6	; 0x06
    638a:	97 81       	ldd	r25, Z+7	; 0x07
    638c:	9b 87       	std	Y+11, r25	; 0x0b
    638e:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    6390:	ea 85       	ldd	r30, Y+10	; 0x0a
    6392:	fb 85       	ldd	r31, Y+11	; 0x0b
    6394:	84 89       	ldd	r24, Z+20	; 0x14
    6396:	95 89       	ldd	r25, Z+21	; 0x15
    6398:	98 87       	std	Y+8, r25	; 0x08
    639a:	8f 83       	std	Y+7, r24	; 0x07
    639c:	ea 85       	ldd	r30, Y+10	; 0x0a
    639e:	fb 85       	ldd	r31, Y+11	; 0x0b
    63a0:	a6 85       	ldd	r26, Z+14	; 0x0e
    63a2:	b7 85       	ldd	r27, Z+15	; 0x0f
    63a4:	ea 85       	ldd	r30, Y+10	; 0x0a
    63a6:	fb 85       	ldd	r31, Y+11	; 0x0b
    63a8:	80 89       	ldd	r24, Z+16	; 0x10
    63aa:	91 89       	ldd	r25, Z+17	; 0x11
    63ac:	15 96       	adiw	r26, 0x05	; 5
    63ae:	9c 93       	st	X, r25
    63b0:	8e 93       	st	-X, r24
    63b2:	14 97       	sbiw	r26, 0x04	; 4
    63b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    63b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    63b8:	a0 89       	ldd	r26, Z+16	; 0x10
    63ba:	b1 89       	ldd	r27, Z+17	; 0x11
    63bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    63be:	fb 85       	ldd	r31, Y+11	; 0x0b
    63c0:	86 85       	ldd	r24, Z+14	; 0x0e
    63c2:	97 85       	ldd	r25, Z+15	; 0x0f
    63c4:	13 96       	adiw	r26, 0x03	; 3
    63c6:	9c 93       	st	X, r25
    63c8:	8e 93       	st	-X, r24
    63ca:	12 97       	sbiw	r26, 0x02	; 2
    63cc:	ef 81       	ldd	r30, Y+7	; 0x07
    63ce:	f8 85       	ldd	r31, Y+8	; 0x08
    63d0:	21 81       	ldd	r18, Z+1	; 0x01
    63d2:	32 81       	ldd	r19, Z+2	; 0x02
    63d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    63d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    63d8:	0c 96       	adiw	r24, 0x0c	; 12
    63da:	28 17       	cp	r18, r24
    63dc:	39 07       	cpc	r19, r25
    63de:	41 f4       	brne	.+16     	; 0x63f0 <xTaskResumeAll+0xb0>
    63e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    63e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    63e4:	80 89       	ldd	r24, Z+16	; 0x10
    63e6:	91 89       	ldd	r25, Z+17	; 0x11
    63e8:	ef 81       	ldd	r30, Y+7	; 0x07
    63ea:	f8 85       	ldd	r31, Y+8	; 0x08
    63ec:	92 83       	std	Z+2, r25	; 0x02
    63ee:	81 83       	std	Z+1, r24	; 0x01
    63f0:	ea 85       	ldd	r30, Y+10	; 0x0a
    63f2:	fb 85       	ldd	r31, Y+11	; 0x0b
    63f4:	15 8a       	std	Z+21, r1	; 0x15
    63f6:	14 8a       	std	Z+20, r1	; 0x14
    63f8:	ef 81       	ldd	r30, Y+7	; 0x07
    63fa:	f8 85       	ldd	r31, Y+8	; 0x08
    63fc:	80 81       	ld	r24, Z
    63fe:	81 50       	subi	r24, 0x01	; 1
    6400:	ef 81       	ldd	r30, Y+7	; 0x07
    6402:	f8 85       	ldd	r31, Y+8	; 0x08
    6404:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    6406:	ea 85       	ldd	r30, Y+10	; 0x0a
    6408:	fb 85       	ldd	r31, Y+11	; 0x0b
    640a:	82 85       	ldd	r24, Z+10	; 0x0a
    640c:	93 85       	ldd	r25, Z+11	; 0x0b
    640e:	9e 83       	std	Y+6, r25	; 0x06
    6410:	8d 83       	std	Y+5, r24	; 0x05
    6412:	ea 85       	ldd	r30, Y+10	; 0x0a
    6414:	fb 85       	ldd	r31, Y+11	; 0x0b
    6416:	a4 81       	ldd	r26, Z+4	; 0x04
    6418:	b5 81       	ldd	r27, Z+5	; 0x05
    641a:	ea 85       	ldd	r30, Y+10	; 0x0a
    641c:	fb 85       	ldd	r31, Y+11	; 0x0b
    641e:	86 81       	ldd	r24, Z+6	; 0x06
    6420:	97 81       	ldd	r25, Z+7	; 0x07
    6422:	15 96       	adiw	r26, 0x05	; 5
    6424:	9c 93       	st	X, r25
    6426:	8e 93       	st	-X, r24
    6428:	14 97       	sbiw	r26, 0x04	; 4
    642a:	ea 85       	ldd	r30, Y+10	; 0x0a
    642c:	fb 85       	ldd	r31, Y+11	; 0x0b
    642e:	a6 81       	ldd	r26, Z+6	; 0x06
    6430:	b7 81       	ldd	r27, Z+7	; 0x07
    6432:	ea 85       	ldd	r30, Y+10	; 0x0a
    6434:	fb 85       	ldd	r31, Y+11	; 0x0b
    6436:	84 81       	ldd	r24, Z+4	; 0x04
    6438:	95 81       	ldd	r25, Z+5	; 0x05
    643a:	13 96       	adiw	r26, 0x03	; 3
    643c:	9c 93       	st	X, r25
    643e:	8e 93       	st	-X, r24
    6440:	12 97       	sbiw	r26, 0x02	; 2
    6442:	ed 81       	ldd	r30, Y+5	; 0x05
    6444:	fe 81       	ldd	r31, Y+6	; 0x06
    6446:	21 81       	ldd	r18, Z+1	; 0x01
    6448:	32 81       	ldd	r19, Z+2	; 0x02
    644a:	8a 85       	ldd	r24, Y+10	; 0x0a
    644c:	9b 85       	ldd	r25, Y+11	; 0x0b
    644e:	02 96       	adiw	r24, 0x02	; 2
    6450:	28 17       	cp	r18, r24
    6452:	39 07       	cpc	r19, r25
    6454:	41 f4       	brne	.+16     	; 0x6466 <xTaskResumeAll+0x126>
    6456:	ea 85       	ldd	r30, Y+10	; 0x0a
    6458:	fb 85       	ldd	r31, Y+11	; 0x0b
    645a:	86 81       	ldd	r24, Z+6	; 0x06
    645c:	97 81       	ldd	r25, Z+7	; 0x07
    645e:	ed 81       	ldd	r30, Y+5	; 0x05
    6460:	fe 81       	ldd	r31, Y+6	; 0x06
    6462:	92 83       	std	Z+2, r25	; 0x02
    6464:	81 83       	std	Z+1, r24	; 0x01
    6466:	ea 85       	ldd	r30, Y+10	; 0x0a
    6468:	fb 85       	ldd	r31, Y+11	; 0x0b
    646a:	13 86       	std	Z+11, r1	; 0x0b
    646c:	12 86       	std	Z+10, r1	; 0x0a
    646e:	ed 81       	ldd	r30, Y+5	; 0x05
    6470:	fe 81       	ldd	r31, Y+6	; 0x06
    6472:	80 81       	ld	r24, Z
    6474:	81 50       	subi	r24, 0x01	; 1
    6476:	ed 81       	ldd	r30, Y+5	; 0x05
    6478:	fe 81       	ldd	r31, Y+6	; 0x06
    647a:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    647c:	ea 85       	ldd	r30, Y+10	; 0x0a
    647e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6480:	96 89       	ldd	r25, Z+22	; 0x16
    6482:	80 91 5c 07 	lds	r24, 0x075C
    6486:	89 17       	cp	r24, r25
    6488:	28 f4       	brcc	.+10     	; 0x6494 <xTaskResumeAll+0x154>
    648a:	ea 85       	ldd	r30, Y+10	; 0x0a
    648c:	fb 85       	ldd	r31, Y+11	; 0x0b
    648e:	86 89       	ldd	r24, Z+22	; 0x16
    6490:	80 93 5c 07 	sts	0x075C, r24
    6494:	ea 85       	ldd	r30, Y+10	; 0x0a
    6496:	fb 85       	ldd	r31, Y+11	; 0x0b
    6498:	86 89       	ldd	r24, Z+22	; 0x16
    649a:	28 2f       	mov	r18, r24
    649c:	30 e0       	ldi	r19, 0x00	; 0
    649e:	c9 01       	movw	r24, r18
    64a0:	88 0f       	add	r24, r24
    64a2:	99 1f       	adc	r25, r25
    64a4:	88 0f       	add	r24, r24
    64a6:	99 1f       	adc	r25, r25
    64a8:	88 0f       	add	r24, r24
    64aa:	99 1f       	adc	r25, r25
    64ac:	82 0f       	add	r24, r18
    64ae:	93 1f       	adc	r25, r19
    64b0:	fc 01       	movw	r30, r24
    64b2:	e8 59       	subi	r30, 0x98	; 152
    64b4:	f8 4f       	sbci	r31, 0xF8	; 248
    64b6:	81 81       	ldd	r24, Z+1	; 0x01
    64b8:	92 81       	ldd	r25, Z+2	; 0x02
    64ba:	9c 83       	std	Y+4, r25	; 0x04
    64bc:	8b 83       	std	Y+3, r24	; 0x03
    64be:	ea 85       	ldd	r30, Y+10	; 0x0a
    64c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    64c2:	8b 81       	ldd	r24, Y+3	; 0x03
    64c4:	9c 81       	ldd	r25, Y+4	; 0x04
    64c6:	95 83       	std	Z+5, r25	; 0x05
    64c8:	84 83       	std	Z+4, r24	; 0x04
    64ca:	eb 81       	ldd	r30, Y+3	; 0x03
    64cc:	fc 81       	ldd	r31, Y+4	; 0x04
    64ce:	84 81       	ldd	r24, Z+4	; 0x04
    64d0:	95 81       	ldd	r25, Z+5	; 0x05
    64d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    64d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    64d6:	97 83       	std	Z+7, r25	; 0x07
    64d8:	86 83       	std	Z+6, r24	; 0x06
    64da:	eb 81       	ldd	r30, Y+3	; 0x03
    64dc:	fc 81       	ldd	r31, Y+4	; 0x04
    64de:	04 80       	ldd	r0, Z+4	; 0x04
    64e0:	f5 81       	ldd	r31, Z+5	; 0x05
    64e2:	e0 2d       	mov	r30, r0
    64e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    64e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    64e8:	02 96       	adiw	r24, 0x02	; 2
    64ea:	93 83       	std	Z+3, r25	; 0x03
    64ec:	82 83       	std	Z+2, r24	; 0x02
    64ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    64f0:	9b 85       	ldd	r25, Y+11	; 0x0b
    64f2:	02 96       	adiw	r24, 0x02	; 2
    64f4:	eb 81       	ldd	r30, Y+3	; 0x03
    64f6:	fc 81       	ldd	r31, Y+4	; 0x04
    64f8:	95 83       	std	Z+5, r25	; 0x05
    64fa:	84 83       	std	Z+4, r24	; 0x04
    64fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    64fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    6500:	86 89       	ldd	r24, Z+22	; 0x16
    6502:	28 2f       	mov	r18, r24
    6504:	30 e0       	ldi	r19, 0x00	; 0
    6506:	c9 01       	movw	r24, r18
    6508:	88 0f       	add	r24, r24
    650a:	99 1f       	adc	r25, r25
    650c:	88 0f       	add	r24, r24
    650e:	99 1f       	adc	r25, r25
    6510:	88 0f       	add	r24, r24
    6512:	99 1f       	adc	r25, r25
    6514:	82 0f       	add	r24, r18
    6516:	93 1f       	adc	r25, r19
    6518:	88 59       	subi	r24, 0x98	; 152
    651a:	98 4f       	sbci	r25, 0xF8	; 248
    651c:	ea 85       	ldd	r30, Y+10	; 0x0a
    651e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6520:	93 87       	std	Z+11, r25	; 0x0b
    6522:	82 87       	std	Z+10, r24	; 0x0a
    6524:	ea 85       	ldd	r30, Y+10	; 0x0a
    6526:	fb 85       	ldd	r31, Y+11	; 0x0b
    6528:	86 89       	ldd	r24, Z+22	; 0x16
    652a:	28 2f       	mov	r18, r24
    652c:	30 e0       	ldi	r19, 0x00	; 0
    652e:	c9 01       	movw	r24, r18
    6530:	88 0f       	add	r24, r24
    6532:	99 1f       	adc	r25, r25
    6534:	88 0f       	add	r24, r24
    6536:	99 1f       	adc	r25, r25
    6538:	88 0f       	add	r24, r24
    653a:	99 1f       	adc	r25, r25
    653c:	82 0f       	add	r24, r18
    653e:	93 1f       	adc	r25, r19
    6540:	fc 01       	movw	r30, r24
    6542:	e8 59       	subi	r30, 0x98	; 152
    6544:	f8 4f       	sbci	r31, 0xF8	; 248
    6546:	80 81       	ld	r24, Z
    6548:	8f 5f       	subi	r24, 0xFF	; 255
    654a:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    654c:	ea 85       	ldd	r30, Y+10	; 0x0a
    654e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6550:	96 89       	ldd	r25, Z+22	; 0x16
    6552:	e0 91 56 07 	lds	r30, 0x0756
    6556:	f0 91 57 07 	lds	r31, 0x0757
    655a:	86 89       	ldd	r24, Z+22	; 0x16
    655c:	98 17       	cp	r25, r24
    655e:	18 f0       	brcs	.+6      	; 0x6566 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    6560:	81 e0       	ldi	r24, 0x01	; 1
    6562:	80 93 60 07 	sts	0x0760, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    6566:	80 91 a2 07 	lds	r24, 0x07A2
    656a:	88 23       	and	r24, r24
    656c:	09 f0       	breq	.+2      	; 0x6570 <xTaskResumeAll+0x230>
    656e:	08 cf       	rjmp	.-496    	; 0x6380 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    6570:	8a 85       	ldd	r24, Y+10	; 0x0a
    6572:	9b 85       	ldd	r25, Y+11	; 0x0b
    6574:	00 97       	sbiw	r24, 0x00	; 0
    6576:	11 f0       	breq	.+4      	; 0x657c <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    6578:	0e 94 97 39 	call	0x732e	; 0x732e <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    657c:	80 91 5e 07 	lds	r24, 0x075E
    6580:	90 91 5f 07 	lds	r25, 0x075F
    6584:	9a 83       	std	Y+2, r25	; 0x02
    6586:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    6588:	89 81       	ldd	r24, Y+1	; 0x01
    658a:	9a 81       	ldd	r25, Y+2	; 0x02
    658c:	00 97       	sbiw	r24, 0x00	; 0
    658e:	a1 f0       	breq	.+40     	; 0x65b8 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    6590:	0e 94 72 33 	call	0x66e4	; 0x66e4 <xTaskIncrementTick>
    6594:	88 23       	and	r24, r24
    6596:	19 f0       	breq	.+6      	; 0x659e <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    6598:	81 e0       	ldi	r24, 0x01	; 1
    659a:	80 93 60 07 	sts	0x0760, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    659e:	89 81       	ldd	r24, Y+1	; 0x01
    65a0:	9a 81       	ldd	r25, Y+2	; 0x02
    65a2:	01 97       	sbiw	r24, 0x01	; 1
    65a4:	9a 83       	std	Y+2, r25	; 0x02
    65a6:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    65a8:	89 81       	ldd	r24, Y+1	; 0x01
    65aa:	9a 81       	ldd	r25, Y+2	; 0x02
    65ac:	00 97       	sbiw	r24, 0x00	; 0
    65ae:	81 f7       	brne	.-32     	; 0x6590 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    65b0:	10 92 5f 07 	sts	0x075F, r1
    65b4:	10 92 5e 07 	sts	0x075E, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    65b8:	80 91 60 07 	lds	r24, 0x0760
    65bc:	88 23       	and	r24, r24
    65be:	21 f0       	breq	.+8      	; 0x65c8 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
    65c0:	81 e0       	ldi	r24, 0x01	; 1
    65c2:	89 87       	std	Y+9, r24	; 0x09
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    65c4:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    65c8:	0f 90       	pop	r0
    65ca:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    65cc:	89 85       	ldd	r24, Y+9	; 0x09
}
    65ce:	2b 96       	adiw	r28, 0x0b	; 11
    65d0:	0f b6       	in	r0, 0x3f	; 63
    65d2:	f8 94       	cli
    65d4:	de bf       	out	0x3e, r29	; 62
    65d6:	0f be       	out	0x3f, r0	; 63
    65d8:	cd bf       	out	0x3d, r28	; 61
    65da:	cf 91       	pop	r28
    65dc:	df 91       	pop	r29
    65de:	08 95       	ret

000065e0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    65e0:	df 93       	push	r29
    65e2:	cf 93       	push	r28
    65e4:	00 d0       	rcall	.+0      	; 0x65e6 <xTaskGetTickCount+0x6>
    65e6:	cd b7       	in	r28, 0x3d	; 61
    65e8:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    65ea:	0f b6       	in	r0, 0x3f	; 63
    65ec:	f8 94       	cli
    65ee:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    65f0:	80 91 5a 07 	lds	r24, 0x075A
    65f4:	90 91 5b 07 	lds	r25, 0x075B
    65f8:	9a 83       	std	Y+2, r25	; 0x02
    65fa:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    65fc:	0f 90       	pop	r0
    65fe:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    6600:	89 81       	ldd	r24, Y+1	; 0x01
    6602:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6604:	0f 90       	pop	r0
    6606:	0f 90       	pop	r0
    6608:	cf 91       	pop	r28
    660a:	df 91       	pop	r29
    660c:	08 95       	ret

0000660e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    660e:	df 93       	push	r29
    6610:	cf 93       	push	r28
    6612:	00 d0       	rcall	.+0      	; 0x6614 <xTaskGetTickCountFromISR+0x6>
    6614:	0f 92       	push	r0
    6616:	cd b7       	in	r28, 0x3d	; 61
    6618:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    661a:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    661c:	80 91 5a 07 	lds	r24, 0x075A
    6620:	90 91 5b 07 	lds	r25, 0x075B
    6624:	9b 83       	std	Y+3, r25	; 0x03
    6626:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    6628:	8a 81       	ldd	r24, Y+2	; 0x02
    662a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    662c:	0f 90       	pop	r0
    662e:	0f 90       	pop	r0
    6630:	0f 90       	pop	r0
    6632:	cf 91       	pop	r28
    6634:	df 91       	pop	r29
    6636:	08 95       	ret

00006638 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    6638:	df 93       	push	r29
    663a:	cf 93       	push	r28
    663c:	cd b7       	in	r28, 0x3d	; 61
    663e:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    6640:	80 91 59 07 	lds	r24, 0x0759
}
    6644:	cf 91       	pop	r28
    6646:	df 91       	pop	r29
    6648:	08 95       	ret

0000664a <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    664a:	df 93       	push	r29
    664c:	cf 93       	push	r28
    664e:	00 d0       	rcall	.+0      	; 0x6650 <pcTaskGetName+0x6>
    6650:	00 d0       	rcall	.+0      	; 0x6652 <pcTaskGetName+0x8>
    6652:	00 d0       	rcall	.+0      	; 0x6654 <pcTaskGetName+0xa>
    6654:	cd b7       	in	r28, 0x3d	; 61
    6656:	de b7       	in	r29, 0x3e	; 62
    6658:	9c 83       	std	Y+4, r25	; 0x04
    665a:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    665c:	8b 81       	ldd	r24, Y+3	; 0x03
    665e:	9c 81       	ldd	r25, Y+4	; 0x04
    6660:	00 97       	sbiw	r24, 0x00	; 0
    6662:	39 f4       	brne	.+14     	; 0x6672 <pcTaskGetName+0x28>
    6664:	80 91 56 07 	lds	r24, 0x0756
    6668:	90 91 57 07 	lds	r25, 0x0757
    666c:	9e 83       	std	Y+6, r25	; 0x06
    666e:	8d 83       	std	Y+5, r24	; 0x05
    6670:	04 c0       	rjmp	.+8      	; 0x667a <pcTaskGetName+0x30>
    6672:	8b 81       	ldd	r24, Y+3	; 0x03
    6674:	9c 81       	ldd	r25, Y+4	; 0x04
    6676:	9e 83       	std	Y+6, r25	; 0x06
    6678:	8d 83       	std	Y+5, r24	; 0x05
    667a:	8d 81       	ldd	r24, Y+5	; 0x05
    667c:	9e 81       	ldd	r25, Y+6	; 0x06
    667e:	9a 83       	std	Y+2, r25	; 0x02
    6680:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    6682:	89 81       	ldd	r24, Y+1	; 0x01
    6684:	9a 81       	ldd	r25, Y+2	; 0x02
    6686:	49 96       	adiw	r24, 0x19	; 25
}
    6688:	26 96       	adiw	r28, 0x06	; 6
    668a:	0f b6       	in	r0, 0x3f	; 63
    668c:	f8 94       	cli
    668e:	de bf       	out	0x3e, r29	; 62
    6690:	0f be       	out	0x3f, r0	; 63
    6692:	cd bf       	out	0x3d, r28	; 61
    6694:	cf 91       	pop	r28
    6696:	df 91       	pop	r29
    6698:	08 95       	ret

0000669a <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    669a:	df 93       	push	r29
    669c:	cf 93       	push	r28
    669e:	00 d0       	rcall	.+0      	; 0x66a0 <xTaskCatchUpTicks+0x6>
    66a0:	0f 92       	push	r0
    66a2:	cd b7       	in	r28, 0x3d	; 61
    66a4:	de b7       	in	r29, 0x3e	; 62
    66a6:	9b 83       	std	Y+3, r25	; 0x03
    66a8:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    66aa:	0e 94 94 31 	call	0x6328	; 0x6328 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    66ae:	0f b6       	in	r0, 0x3f	; 63
    66b0:	f8 94       	cli
    66b2:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    66b4:	20 91 5e 07 	lds	r18, 0x075E
    66b8:	30 91 5f 07 	lds	r19, 0x075F
    66bc:	8a 81       	ldd	r24, Y+2	; 0x02
    66be:	9b 81       	ldd	r25, Y+3	; 0x03
    66c0:	82 0f       	add	r24, r18
    66c2:	93 1f       	adc	r25, r19
    66c4:	90 93 5f 07 	sts	0x075F, r25
    66c8:	80 93 5e 07 	sts	0x075E, r24
    }
    taskEXIT_CRITICAL();
    66cc:	0f 90       	pop	r0
    66ce:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    66d0:	0e 94 a0 31 	call	0x6340	; 0x6340 <xTaskResumeAll>
    66d4:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    66d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    66d8:	0f 90       	pop	r0
    66da:	0f 90       	pop	r0
    66dc:	0f 90       	pop	r0
    66de:	cf 91       	pop	r28
    66e0:	df 91       	pop	r29
    66e2:	08 95       	ret

000066e4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    66e4:	df 93       	push	r29
    66e6:	cf 93       	push	r28
    66e8:	cd b7       	in	r28, 0x3d	; 61
    66ea:	de b7       	in	r29, 0x3e	; 62
    66ec:	2f 97       	sbiw	r28, 0x0f	; 15
    66ee:	0f b6       	in	r0, 0x3f	; 63
    66f0:	f8 94       	cli
    66f2:	de bf       	out	0x3e, r29	; 62
    66f4:	0f be       	out	0x3f, r0	; 63
    66f6:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    66f8:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    66fa:	80 91 67 07 	lds	r24, 0x0767
    66fe:	88 23       	and	r24, r24
    6700:	09 f0       	breq	.+2      	; 0x6704 <xTaskIncrementTick+0x20>
    6702:	74 c1       	rjmp	.+744    	; 0x69ec <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    6704:	80 91 5a 07 	lds	r24, 0x075A
    6708:	90 91 5b 07 	lds	r25, 0x075B
    670c:	01 96       	adiw	r24, 0x01	; 1
    670e:	9a 87       	std	Y+10, r25	; 0x0a
    6710:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    6712:	89 85       	ldd	r24, Y+9	; 0x09
    6714:	9a 85       	ldd	r25, Y+10	; 0x0a
    6716:	90 93 5b 07 	sts	0x075B, r25
    671a:	80 93 5a 07 	sts	0x075A, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    671e:	89 85       	ldd	r24, Y+9	; 0x09
    6720:	9a 85       	ldd	r25, Y+10	; 0x0a
    6722:	00 97       	sbiw	r24, 0x00	; 0
    6724:	d9 f4       	brne	.+54     	; 0x675c <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    6726:	80 91 9e 07 	lds	r24, 0x079E
    672a:	90 91 9f 07 	lds	r25, 0x079F
    672e:	98 87       	std	Y+8, r25	; 0x08
    6730:	8f 83       	std	Y+7, r24	; 0x07
    6732:	80 91 a0 07 	lds	r24, 0x07A0
    6736:	90 91 a1 07 	lds	r25, 0x07A1
    673a:	90 93 9f 07 	sts	0x079F, r25
    673e:	80 93 9e 07 	sts	0x079E, r24
    6742:	8f 81       	ldd	r24, Y+7	; 0x07
    6744:	98 85       	ldd	r25, Y+8	; 0x08
    6746:	90 93 a1 07 	sts	0x07A1, r25
    674a:	80 93 a0 07 	sts	0x07A0, r24
    674e:	80 91 61 07 	lds	r24, 0x0761
    6752:	8f 5f       	subi	r24, 0xFF	; 255
    6754:	80 93 61 07 	sts	0x0761, r24
    6758:	0e 94 97 39 	call	0x732e	; 0x732e <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    675c:	20 91 63 07 	lds	r18, 0x0763
    6760:	30 91 64 07 	lds	r19, 0x0764
    6764:	89 85       	ldd	r24, Y+9	; 0x09
    6766:	9a 85       	ldd	r25, Y+10	; 0x0a
    6768:	82 17       	cp	r24, r18
    676a:	93 07       	cpc	r25, r19
    676c:	08 f4       	brcc	.+2      	; 0x6770 <xTaskIncrementTick+0x8c>
    676e:	1f c1       	rjmp	.+574    	; 0x69ae <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6770:	e0 91 9e 07 	lds	r30, 0x079E
    6774:	f0 91 9f 07 	lds	r31, 0x079F
    6778:	80 81       	ld	r24, Z
    677a:	88 23       	and	r24, r24
    677c:	39 f4       	brne	.+14     	; 0x678c <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    677e:	8f ef       	ldi	r24, 0xFF	; 255
    6780:	9f ef       	ldi	r25, 0xFF	; 255
    6782:	90 93 64 07 	sts	0x0764, r25
    6786:	80 93 63 07 	sts	0x0763, r24
    678a:	11 c1       	rjmp	.+546    	; 0x69ae <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    678c:	e0 91 9e 07 	lds	r30, 0x079E
    6790:	f0 91 9f 07 	lds	r31, 0x079F
    6794:	05 80       	ldd	r0, Z+5	; 0x05
    6796:	f6 81       	ldd	r31, Z+6	; 0x06
    6798:	e0 2d       	mov	r30, r0
    679a:	86 81       	ldd	r24, Z+6	; 0x06
    679c:	97 81       	ldd	r25, Z+7	; 0x07
    679e:	9f 87       	std	Y+15, r25	; 0x0f
    67a0:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    67a2:	ee 85       	ldd	r30, Y+14	; 0x0e
    67a4:	ff 85       	ldd	r31, Y+15	; 0x0f
    67a6:	82 81       	ldd	r24, Z+2	; 0x02
    67a8:	93 81       	ldd	r25, Z+3	; 0x03
    67aa:	9d 87       	std	Y+13, r25	; 0x0d
    67ac:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    67ae:	29 85       	ldd	r18, Y+9	; 0x09
    67b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    67b2:	8c 85       	ldd	r24, Y+12	; 0x0c
    67b4:	9d 85       	ldd	r25, Y+13	; 0x0d
    67b6:	28 17       	cp	r18, r24
    67b8:	39 07       	cpc	r19, r25
    67ba:	38 f4       	brcc	.+14     	; 0x67ca <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    67bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    67be:	9d 85       	ldd	r25, Y+13	; 0x0d
    67c0:	90 93 64 07 	sts	0x0764, r25
    67c4:	80 93 63 07 	sts	0x0763, r24
    67c8:	f2 c0       	rjmp	.+484    	; 0x69ae <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    67ca:	ee 85       	ldd	r30, Y+14	; 0x0e
    67cc:	ff 85       	ldd	r31, Y+15	; 0x0f
    67ce:	82 85       	ldd	r24, Z+10	; 0x0a
    67d0:	93 85       	ldd	r25, Z+11	; 0x0b
    67d2:	9e 83       	std	Y+6, r25	; 0x06
    67d4:	8d 83       	std	Y+5, r24	; 0x05
    67d6:	ee 85       	ldd	r30, Y+14	; 0x0e
    67d8:	ff 85       	ldd	r31, Y+15	; 0x0f
    67da:	a4 81       	ldd	r26, Z+4	; 0x04
    67dc:	b5 81       	ldd	r27, Z+5	; 0x05
    67de:	ee 85       	ldd	r30, Y+14	; 0x0e
    67e0:	ff 85       	ldd	r31, Y+15	; 0x0f
    67e2:	86 81       	ldd	r24, Z+6	; 0x06
    67e4:	97 81       	ldd	r25, Z+7	; 0x07
    67e6:	15 96       	adiw	r26, 0x05	; 5
    67e8:	9c 93       	st	X, r25
    67ea:	8e 93       	st	-X, r24
    67ec:	14 97       	sbiw	r26, 0x04	; 4
    67ee:	ee 85       	ldd	r30, Y+14	; 0x0e
    67f0:	ff 85       	ldd	r31, Y+15	; 0x0f
    67f2:	a6 81       	ldd	r26, Z+6	; 0x06
    67f4:	b7 81       	ldd	r27, Z+7	; 0x07
    67f6:	ee 85       	ldd	r30, Y+14	; 0x0e
    67f8:	ff 85       	ldd	r31, Y+15	; 0x0f
    67fa:	84 81       	ldd	r24, Z+4	; 0x04
    67fc:	95 81       	ldd	r25, Z+5	; 0x05
    67fe:	13 96       	adiw	r26, 0x03	; 3
    6800:	9c 93       	st	X, r25
    6802:	8e 93       	st	-X, r24
    6804:	12 97       	sbiw	r26, 0x02	; 2
    6806:	ed 81       	ldd	r30, Y+5	; 0x05
    6808:	fe 81       	ldd	r31, Y+6	; 0x06
    680a:	21 81       	ldd	r18, Z+1	; 0x01
    680c:	32 81       	ldd	r19, Z+2	; 0x02
    680e:	8e 85       	ldd	r24, Y+14	; 0x0e
    6810:	9f 85       	ldd	r25, Y+15	; 0x0f
    6812:	02 96       	adiw	r24, 0x02	; 2
    6814:	28 17       	cp	r18, r24
    6816:	39 07       	cpc	r19, r25
    6818:	41 f4       	brne	.+16     	; 0x682a <xTaskIncrementTick+0x146>
    681a:	ee 85       	ldd	r30, Y+14	; 0x0e
    681c:	ff 85       	ldd	r31, Y+15	; 0x0f
    681e:	86 81       	ldd	r24, Z+6	; 0x06
    6820:	97 81       	ldd	r25, Z+7	; 0x07
    6822:	ed 81       	ldd	r30, Y+5	; 0x05
    6824:	fe 81       	ldd	r31, Y+6	; 0x06
    6826:	92 83       	std	Z+2, r25	; 0x02
    6828:	81 83       	std	Z+1, r24	; 0x01
    682a:	ee 85       	ldd	r30, Y+14	; 0x0e
    682c:	ff 85       	ldd	r31, Y+15	; 0x0f
    682e:	13 86       	std	Z+11, r1	; 0x0b
    6830:	12 86       	std	Z+10, r1	; 0x0a
    6832:	ed 81       	ldd	r30, Y+5	; 0x05
    6834:	fe 81       	ldd	r31, Y+6	; 0x06
    6836:	80 81       	ld	r24, Z
    6838:	81 50       	subi	r24, 0x01	; 1
    683a:	ed 81       	ldd	r30, Y+5	; 0x05
    683c:	fe 81       	ldd	r31, Y+6	; 0x06
    683e:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    6840:	ee 85       	ldd	r30, Y+14	; 0x0e
    6842:	ff 85       	ldd	r31, Y+15	; 0x0f
    6844:	84 89       	ldd	r24, Z+20	; 0x14
    6846:	95 89       	ldd	r25, Z+21	; 0x15
    6848:	00 97       	sbiw	r24, 0x00	; 0
    684a:	d9 f1       	breq	.+118    	; 0x68c2 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    684c:	ee 85       	ldd	r30, Y+14	; 0x0e
    684e:	ff 85       	ldd	r31, Y+15	; 0x0f
    6850:	84 89       	ldd	r24, Z+20	; 0x14
    6852:	95 89       	ldd	r25, Z+21	; 0x15
    6854:	9c 83       	std	Y+4, r25	; 0x04
    6856:	8b 83       	std	Y+3, r24	; 0x03
    6858:	ee 85       	ldd	r30, Y+14	; 0x0e
    685a:	ff 85       	ldd	r31, Y+15	; 0x0f
    685c:	a6 85       	ldd	r26, Z+14	; 0x0e
    685e:	b7 85       	ldd	r27, Z+15	; 0x0f
    6860:	ee 85       	ldd	r30, Y+14	; 0x0e
    6862:	ff 85       	ldd	r31, Y+15	; 0x0f
    6864:	80 89       	ldd	r24, Z+16	; 0x10
    6866:	91 89       	ldd	r25, Z+17	; 0x11
    6868:	15 96       	adiw	r26, 0x05	; 5
    686a:	9c 93       	st	X, r25
    686c:	8e 93       	st	-X, r24
    686e:	14 97       	sbiw	r26, 0x04	; 4
    6870:	ee 85       	ldd	r30, Y+14	; 0x0e
    6872:	ff 85       	ldd	r31, Y+15	; 0x0f
    6874:	a0 89       	ldd	r26, Z+16	; 0x10
    6876:	b1 89       	ldd	r27, Z+17	; 0x11
    6878:	ee 85       	ldd	r30, Y+14	; 0x0e
    687a:	ff 85       	ldd	r31, Y+15	; 0x0f
    687c:	86 85       	ldd	r24, Z+14	; 0x0e
    687e:	97 85       	ldd	r25, Z+15	; 0x0f
    6880:	13 96       	adiw	r26, 0x03	; 3
    6882:	9c 93       	st	X, r25
    6884:	8e 93       	st	-X, r24
    6886:	12 97       	sbiw	r26, 0x02	; 2
    6888:	eb 81       	ldd	r30, Y+3	; 0x03
    688a:	fc 81       	ldd	r31, Y+4	; 0x04
    688c:	21 81       	ldd	r18, Z+1	; 0x01
    688e:	32 81       	ldd	r19, Z+2	; 0x02
    6890:	8e 85       	ldd	r24, Y+14	; 0x0e
    6892:	9f 85       	ldd	r25, Y+15	; 0x0f
    6894:	0c 96       	adiw	r24, 0x0c	; 12
    6896:	28 17       	cp	r18, r24
    6898:	39 07       	cpc	r19, r25
    689a:	41 f4       	brne	.+16     	; 0x68ac <xTaskIncrementTick+0x1c8>
    689c:	ee 85       	ldd	r30, Y+14	; 0x0e
    689e:	ff 85       	ldd	r31, Y+15	; 0x0f
    68a0:	80 89       	ldd	r24, Z+16	; 0x10
    68a2:	91 89       	ldd	r25, Z+17	; 0x11
    68a4:	eb 81       	ldd	r30, Y+3	; 0x03
    68a6:	fc 81       	ldd	r31, Y+4	; 0x04
    68a8:	92 83       	std	Z+2, r25	; 0x02
    68aa:	81 83       	std	Z+1, r24	; 0x01
    68ac:	ee 85       	ldd	r30, Y+14	; 0x0e
    68ae:	ff 85       	ldd	r31, Y+15	; 0x0f
    68b0:	15 8a       	std	Z+21, r1	; 0x15
    68b2:	14 8a       	std	Z+20, r1	; 0x14
    68b4:	eb 81       	ldd	r30, Y+3	; 0x03
    68b6:	fc 81       	ldd	r31, Y+4	; 0x04
    68b8:	80 81       	ld	r24, Z
    68ba:	81 50       	subi	r24, 0x01	; 1
    68bc:	eb 81       	ldd	r30, Y+3	; 0x03
    68be:	fc 81       	ldd	r31, Y+4	; 0x04
    68c0:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    68c2:	ee 85       	ldd	r30, Y+14	; 0x0e
    68c4:	ff 85       	ldd	r31, Y+15	; 0x0f
    68c6:	96 89       	ldd	r25, Z+22	; 0x16
    68c8:	80 91 5c 07 	lds	r24, 0x075C
    68cc:	89 17       	cp	r24, r25
    68ce:	28 f4       	brcc	.+10     	; 0x68da <xTaskIncrementTick+0x1f6>
    68d0:	ee 85       	ldd	r30, Y+14	; 0x0e
    68d2:	ff 85       	ldd	r31, Y+15	; 0x0f
    68d4:	86 89       	ldd	r24, Z+22	; 0x16
    68d6:	80 93 5c 07 	sts	0x075C, r24
    68da:	ee 85       	ldd	r30, Y+14	; 0x0e
    68dc:	ff 85       	ldd	r31, Y+15	; 0x0f
    68de:	86 89       	ldd	r24, Z+22	; 0x16
    68e0:	28 2f       	mov	r18, r24
    68e2:	30 e0       	ldi	r19, 0x00	; 0
    68e4:	c9 01       	movw	r24, r18
    68e6:	88 0f       	add	r24, r24
    68e8:	99 1f       	adc	r25, r25
    68ea:	88 0f       	add	r24, r24
    68ec:	99 1f       	adc	r25, r25
    68ee:	88 0f       	add	r24, r24
    68f0:	99 1f       	adc	r25, r25
    68f2:	82 0f       	add	r24, r18
    68f4:	93 1f       	adc	r25, r19
    68f6:	fc 01       	movw	r30, r24
    68f8:	e8 59       	subi	r30, 0x98	; 152
    68fa:	f8 4f       	sbci	r31, 0xF8	; 248
    68fc:	81 81       	ldd	r24, Z+1	; 0x01
    68fe:	92 81       	ldd	r25, Z+2	; 0x02
    6900:	9a 83       	std	Y+2, r25	; 0x02
    6902:	89 83       	std	Y+1, r24	; 0x01
    6904:	ee 85       	ldd	r30, Y+14	; 0x0e
    6906:	ff 85       	ldd	r31, Y+15	; 0x0f
    6908:	89 81       	ldd	r24, Y+1	; 0x01
    690a:	9a 81       	ldd	r25, Y+2	; 0x02
    690c:	95 83       	std	Z+5, r25	; 0x05
    690e:	84 83       	std	Z+4, r24	; 0x04
    6910:	e9 81       	ldd	r30, Y+1	; 0x01
    6912:	fa 81       	ldd	r31, Y+2	; 0x02
    6914:	84 81       	ldd	r24, Z+4	; 0x04
    6916:	95 81       	ldd	r25, Z+5	; 0x05
    6918:	ee 85       	ldd	r30, Y+14	; 0x0e
    691a:	ff 85       	ldd	r31, Y+15	; 0x0f
    691c:	97 83       	std	Z+7, r25	; 0x07
    691e:	86 83       	std	Z+6, r24	; 0x06
    6920:	e9 81       	ldd	r30, Y+1	; 0x01
    6922:	fa 81       	ldd	r31, Y+2	; 0x02
    6924:	04 80       	ldd	r0, Z+4	; 0x04
    6926:	f5 81       	ldd	r31, Z+5	; 0x05
    6928:	e0 2d       	mov	r30, r0
    692a:	8e 85       	ldd	r24, Y+14	; 0x0e
    692c:	9f 85       	ldd	r25, Y+15	; 0x0f
    692e:	02 96       	adiw	r24, 0x02	; 2
    6930:	93 83       	std	Z+3, r25	; 0x03
    6932:	82 83       	std	Z+2, r24	; 0x02
    6934:	8e 85       	ldd	r24, Y+14	; 0x0e
    6936:	9f 85       	ldd	r25, Y+15	; 0x0f
    6938:	02 96       	adiw	r24, 0x02	; 2
    693a:	e9 81       	ldd	r30, Y+1	; 0x01
    693c:	fa 81       	ldd	r31, Y+2	; 0x02
    693e:	95 83       	std	Z+5, r25	; 0x05
    6940:	84 83       	std	Z+4, r24	; 0x04
    6942:	ee 85       	ldd	r30, Y+14	; 0x0e
    6944:	ff 85       	ldd	r31, Y+15	; 0x0f
    6946:	86 89       	ldd	r24, Z+22	; 0x16
    6948:	28 2f       	mov	r18, r24
    694a:	30 e0       	ldi	r19, 0x00	; 0
    694c:	c9 01       	movw	r24, r18
    694e:	88 0f       	add	r24, r24
    6950:	99 1f       	adc	r25, r25
    6952:	88 0f       	add	r24, r24
    6954:	99 1f       	adc	r25, r25
    6956:	88 0f       	add	r24, r24
    6958:	99 1f       	adc	r25, r25
    695a:	82 0f       	add	r24, r18
    695c:	93 1f       	adc	r25, r19
    695e:	88 59       	subi	r24, 0x98	; 152
    6960:	98 4f       	sbci	r25, 0xF8	; 248
    6962:	ee 85       	ldd	r30, Y+14	; 0x0e
    6964:	ff 85       	ldd	r31, Y+15	; 0x0f
    6966:	93 87       	std	Z+11, r25	; 0x0b
    6968:	82 87       	std	Z+10, r24	; 0x0a
    696a:	ee 85       	ldd	r30, Y+14	; 0x0e
    696c:	ff 85       	ldd	r31, Y+15	; 0x0f
    696e:	86 89       	ldd	r24, Z+22	; 0x16
    6970:	28 2f       	mov	r18, r24
    6972:	30 e0       	ldi	r19, 0x00	; 0
    6974:	c9 01       	movw	r24, r18
    6976:	88 0f       	add	r24, r24
    6978:	99 1f       	adc	r25, r25
    697a:	88 0f       	add	r24, r24
    697c:	99 1f       	adc	r25, r25
    697e:	88 0f       	add	r24, r24
    6980:	99 1f       	adc	r25, r25
    6982:	82 0f       	add	r24, r18
    6984:	93 1f       	adc	r25, r19
    6986:	fc 01       	movw	r30, r24
    6988:	e8 59       	subi	r30, 0x98	; 152
    698a:	f8 4f       	sbci	r31, 0xF8	; 248
    698c:	80 81       	ld	r24, Z
    698e:	8f 5f       	subi	r24, 0xFF	; 255
    6990:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6992:	ee 85       	ldd	r30, Y+14	; 0x0e
    6994:	ff 85       	ldd	r31, Y+15	; 0x0f
    6996:	96 89       	ldd	r25, Z+22	; 0x16
    6998:	e0 91 56 07 	lds	r30, 0x0756
    699c:	f0 91 57 07 	lds	r31, 0x0757
    69a0:	86 89       	ldd	r24, Z+22	; 0x16
    69a2:	89 17       	cp	r24, r25
    69a4:	08 f0       	brcs	.+2      	; 0x69a8 <xTaskIncrementTick+0x2c4>
    69a6:	e4 ce       	rjmp	.-568    	; 0x6770 <xTaskIncrementTick+0x8c>
                        {
                            xSwitchRequired = pdTRUE;
    69a8:	81 e0       	ldi	r24, 0x01	; 1
    69aa:	8b 87       	std	Y+11, r24	; 0x0b
    69ac:	e1 ce       	rjmp	.-574    	; 0x6770 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    69ae:	e0 91 56 07 	lds	r30, 0x0756
    69b2:	f0 91 57 07 	lds	r31, 0x0757
    69b6:	86 89       	ldd	r24, Z+22	; 0x16
    69b8:	28 2f       	mov	r18, r24
    69ba:	30 e0       	ldi	r19, 0x00	; 0
    69bc:	c9 01       	movw	r24, r18
    69be:	88 0f       	add	r24, r24
    69c0:	99 1f       	adc	r25, r25
    69c2:	88 0f       	add	r24, r24
    69c4:	99 1f       	adc	r25, r25
    69c6:	88 0f       	add	r24, r24
    69c8:	99 1f       	adc	r25, r25
    69ca:	82 0f       	add	r24, r18
    69cc:	93 1f       	adc	r25, r19
    69ce:	fc 01       	movw	r30, r24
    69d0:	e8 59       	subi	r30, 0x98	; 152
    69d2:	f8 4f       	sbci	r31, 0xF8	; 248
    69d4:	80 81       	ld	r24, Z
    69d6:	82 30       	cpi	r24, 0x02	; 2
    69d8:	10 f0       	brcs	.+4      	; 0x69de <xTaskIncrementTick+0x2fa>
            {
                xSwitchRequired = pdTRUE;
    69da:	81 e0       	ldi	r24, 0x01	; 1
    69dc:	8b 87       	std	Y+11, r24	; 0x0b
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    69de:	80 91 60 07 	lds	r24, 0x0760
    69e2:	88 23       	and	r24, r24
    69e4:	61 f0       	breq	.+24     	; 0x69fe <xTaskIncrementTick+0x31a>
            {
                xSwitchRequired = pdTRUE;
    69e6:	81 e0       	ldi	r24, 0x01	; 1
    69e8:	8b 87       	std	Y+11, r24	; 0x0b
    69ea:	09 c0       	rjmp	.+18     	; 0x69fe <xTaskIncrementTick+0x31a>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    69ec:	80 91 5e 07 	lds	r24, 0x075E
    69f0:	90 91 5f 07 	lds	r25, 0x075F
    69f4:	01 96       	adiw	r24, 0x01	; 1
    69f6:	90 93 5f 07 	sts	0x075F, r25
    69fa:	80 93 5e 07 	sts	0x075E, r24
            vApplicationTickHook();
        }
        #endif
    }

    return xSwitchRequired;
    69fe:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    6a00:	2f 96       	adiw	r28, 0x0f	; 15
    6a02:	0f b6       	in	r0, 0x3f	; 63
    6a04:	f8 94       	cli
    6a06:	de bf       	out	0x3e, r29	; 62
    6a08:	0f be       	out	0x3f, r0	; 63
    6a0a:	cd bf       	out	0x3d, r28	; 61
    6a0c:	cf 91       	pop	r28
    6a0e:	df 91       	pop	r29
    6a10:	08 95       	ret

00006a12 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    6a12:	df 93       	push	r29
    6a14:	cf 93       	push	r28
    6a16:	00 d0       	rcall	.+0      	; 0x6a18 <vTaskSwitchContext+0x6>
    6a18:	0f 92       	push	r0
    6a1a:	cd b7       	in	r28, 0x3d	; 61
    6a1c:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    6a1e:	80 91 67 07 	lds	r24, 0x0767
    6a22:	88 23       	and	r24, r24
    6a24:	21 f0       	breq	.+8      	; 0x6a2e <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    6a26:	81 e0       	ldi	r24, 0x01	; 1
    6a28:	80 93 60 07 	sts	0x0760, r24
    6a2c:	59 c0       	rjmp	.+178    	; 0x6ae0 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    6a2e:	10 92 60 07 	sts	0x0760, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6a32:	80 91 5c 07 	lds	r24, 0x075C
    6a36:	8b 83       	std	Y+3, r24	; 0x03
    6a38:	03 c0       	rjmp	.+6      	; 0x6a40 <vTaskSwitchContext+0x2e>
    6a3a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a3c:	81 50       	subi	r24, 0x01	; 1
    6a3e:	8b 83       	std	Y+3, r24	; 0x03
    6a40:	8b 81       	ldd	r24, Y+3	; 0x03
    6a42:	28 2f       	mov	r18, r24
    6a44:	30 e0       	ldi	r19, 0x00	; 0
    6a46:	c9 01       	movw	r24, r18
    6a48:	88 0f       	add	r24, r24
    6a4a:	99 1f       	adc	r25, r25
    6a4c:	88 0f       	add	r24, r24
    6a4e:	99 1f       	adc	r25, r25
    6a50:	88 0f       	add	r24, r24
    6a52:	99 1f       	adc	r25, r25
    6a54:	82 0f       	add	r24, r18
    6a56:	93 1f       	adc	r25, r19
    6a58:	fc 01       	movw	r30, r24
    6a5a:	e8 59       	subi	r30, 0x98	; 152
    6a5c:	f8 4f       	sbci	r31, 0xF8	; 248
    6a5e:	80 81       	ld	r24, Z
    6a60:	88 23       	and	r24, r24
    6a62:	59 f3       	breq	.-42     	; 0x6a3a <vTaskSwitchContext+0x28>
    6a64:	8b 81       	ldd	r24, Y+3	; 0x03
    6a66:	28 2f       	mov	r18, r24
    6a68:	30 e0       	ldi	r19, 0x00	; 0
    6a6a:	c9 01       	movw	r24, r18
    6a6c:	88 0f       	add	r24, r24
    6a6e:	99 1f       	adc	r25, r25
    6a70:	88 0f       	add	r24, r24
    6a72:	99 1f       	adc	r25, r25
    6a74:	88 0f       	add	r24, r24
    6a76:	99 1f       	adc	r25, r25
    6a78:	82 0f       	add	r24, r18
    6a7a:	93 1f       	adc	r25, r19
    6a7c:	88 59       	subi	r24, 0x98	; 152
    6a7e:	98 4f       	sbci	r25, 0xF8	; 248
    6a80:	9a 83       	std	Y+2, r25	; 0x02
    6a82:	89 83       	std	Y+1, r24	; 0x01
    6a84:	e9 81       	ldd	r30, Y+1	; 0x01
    6a86:	fa 81       	ldd	r31, Y+2	; 0x02
    6a88:	01 80       	ldd	r0, Z+1	; 0x01
    6a8a:	f2 81       	ldd	r31, Z+2	; 0x02
    6a8c:	e0 2d       	mov	r30, r0
    6a8e:	82 81       	ldd	r24, Z+2	; 0x02
    6a90:	93 81       	ldd	r25, Z+3	; 0x03
    6a92:	e9 81       	ldd	r30, Y+1	; 0x01
    6a94:	fa 81       	ldd	r31, Y+2	; 0x02
    6a96:	92 83       	std	Z+2, r25	; 0x02
    6a98:	81 83       	std	Z+1, r24	; 0x01
    6a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    6a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    6a9e:	21 81       	ldd	r18, Z+1	; 0x01
    6aa0:	32 81       	ldd	r19, Z+2	; 0x02
    6aa2:	89 81       	ldd	r24, Y+1	; 0x01
    6aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    6aa6:	03 96       	adiw	r24, 0x03	; 3
    6aa8:	28 17       	cp	r18, r24
    6aaa:	39 07       	cpc	r19, r25
    6aac:	59 f4       	brne	.+22     	; 0x6ac4 <vTaskSwitchContext+0xb2>
    6aae:	e9 81       	ldd	r30, Y+1	; 0x01
    6ab0:	fa 81       	ldd	r31, Y+2	; 0x02
    6ab2:	01 80       	ldd	r0, Z+1	; 0x01
    6ab4:	f2 81       	ldd	r31, Z+2	; 0x02
    6ab6:	e0 2d       	mov	r30, r0
    6ab8:	82 81       	ldd	r24, Z+2	; 0x02
    6aba:	93 81       	ldd	r25, Z+3	; 0x03
    6abc:	e9 81       	ldd	r30, Y+1	; 0x01
    6abe:	fa 81       	ldd	r31, Y+2	; 0x02
    6ac0:	92 83       	std	Z+2, r25	; 0x02
    6ac2:	81 83       	std	Z+1, r24	; 0x01
    6ac4:	e9 81       	ldd	r30, Y+1	; 0x01
    6ac6:	fa 81       	ldd	r31, Y+2	; 0x02
    6ac8:	01 80       	ldd	r0, Z+1	; 0x01
    6aca:	f2 81       	ldd	r31, Z+2	; 0x02
    6acc:	e0 2d       	mov	r30, r0
    6ace:	86 81       	ldd	r24, Z+6	; 0x06
    6ad0:	97 81       	ldd	r25, Z+7	; 0x07
    6ad2:	90 93 57 07 	sts	0x0757, r25
    6ad6:	80 93 56 07 	sts	0x0756, r24
    6ada:	8b 81       	ldd	r24, Y+3	; 0x03
    6adc:	80 93 5c 07 	sts	0x075C, r24
             * Block specific to this task. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif
    }
}
    6ae0:	0f 90       	pop	r0
    6ae2:	0f 90       	pop	r0
    6ae4:	0f 90       	pop	r0
    6ae6:	cf 91       	pop	r28
    6ae8:	df 91       	pop	r29
    6aea:	08 95       	ret

00006aec <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    6aec:	df 93       	push	r29
    6aee:	cf 93       	push	r28
    6af0:	00 d0       	rcall	.+0      	; 0x6af2 <vTaskPlaceOnEventList+0x6>
    6af2:	00 d0       	rcall	.+0      	; 0x6af4 <vTaskPlaceOnEventList+0x8>
    6af4:	cd b7       	in	r28, 0x3d	; 61
    6af6:	de b7       	in	r29, 0x3e	; 62
    6af8:	9a 83       	std	Y+2, r25	; 0x02
    6afa:	89 83       	std	Y+1, r24	; 0x01
    6afc:	7c 83       	std	Y+4, r23	; 0x04
    6afe:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6b00:	80 91 56 07 	lds	r24, 0x0756
    6b04:	90 91 57 07 	lds	r25, 0x0757
    6b08:	9c 01       	movw	r18, r24
    6b0a:	24 5f       	subi	r18, 0xF4	; 244
    6b0c:	3f 4f       	sbci	r19, 0xFF	; 255
    6b0e:	89 81       	ldd	r24, Y+1	; 0x01
    6b10:	9a 81       	ldd	r25, Y+2	; 0x02
    6b12:	b9 01       	movw	r22, r18
    6b14:	0e 94 58 18 	call	0x30b0	; 0x30b0 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6b18:	8b 81       	ldd	r24, Y+3	; 0x03
    6b1a:	9c 81       	ldd	r25, Y+4	; 0x04
    6b1c:	61 e0       	ldi	r22, 0x01	; 1
    6b1e:	0e 94 04 44 	call	0x8808	; 0x8808 <prvAddCurrentTaskToDelayedList>
}
    6b22:	0f 90       	pop	r0
    6b24:	0f 90       	pop	r0
    6b26:	0f 90       	pop	r0
    6b28:	0f 90       	pop	r0
    6b2a:	cf 91       	pop	r28
    6b2c:	df 91       	pop	r29
    6b2e:	08 95       	ret

00006b30 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    6b30:	df 93       	push	r29
    6b32:	cf 93       	push	r28
    6b34:	cd b7       	in	r28, 0x3d	; 61
    6b36:	de b7       	in	r29, 0x3e	; 62
    6b38:	28 97       	sbiw	r28, 0x08	; 8
    6b3a:	0f b6       	in	r0, 0x3f	; 63
    6b3c:	f8 94       	cli
    6b3e:	de bf       	out	0x3e, r29	; 62
    6b40:	0f be       	out	0x3f, r0	; 63
    6b42:	cd bf       	out	0x3d, r28	; 61
    6b44:	9c 83       	std	Y+4, r25	; 0x04
    6b46:	8b 83       	std	Y+3, r24	; 0x03
    6b48:	7e 83       	std	Y+6, r23	; 0x06
    6b4a:	6d 83       	std	Y+5, r22	; 0x05
    6b4c:	58 87       	std	Y+8, r21	; 0x08
    6b4e:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    6b50:	e0 91 56 07 	lds	r30, 0x0756
    6b54:	f0 91 57 07 	lds	r31, 0x0757
    6b58:	8d 81       	ldd	r24, Y+5	; 0x05
    6b5a:	9e 81       	ldd	r25, Y+6	; 0x06
    6b5c:	90 68       	ori	r25, 0x80	; 128
    6b5e:	95 87       	std	Z+13, r25	; 0x0d
    6b60:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6b62:	eb 81       	ldd	r30, Y+3	; 0x03
    6b64:	fc 81       	ldd	r31, Y+4	; 0x04
    6b66:	81 81       	ldd	r24, Z+1	; 0x01
    6b68:	92 81       	ldd	r25, Z+2	; 0x02
    6b6a:	9a 83       	std	Y+2, r25	; 0x02
    6b6c:	89 83       	std	Y+1, r24	; 0x01
    6b6e:	e0 91 56 07 	lds	r30, 0x0756
    6b72:	f0 91 57 07 	lds	r31, 0x0757
    6b76:	89 81       	ldd	r24, Y+1	; 0x01
    6b78:	9a 81       	ldd	r25, Y+2	; 0x02
    6b7a:	97 87       	std	Z+15, r25	; 0x0f
    6b7c:	86 87       	std	Z+14, r24	; 0x0e
    6b7e:	a0 91 56 07 	lds	r26, 0x0756
    6b82:	b0 91 57 07 	lds	r27, 0x0757
    6b86:	e9 81       	ldd	r30, Y+1	; 0x01
    6b88:	fa 81       	ldd	r31, Y+2	; 0x02
    6b8a:	84 81       	ldd	r24, Z+4	; 0x04
    6b8c:	95 81       	ldd	r25, Z+5	; 0x05
    6b8e:	51 96       	adiw	r26, 0x11	; 17
    6b90:	9c 93       	st	X, r25
    6b92:	8e 93       	st	-X, r24
    6b94:	50 97       	sbiw	r26, 0x10	; 16
    6b96:	e9 81       	ldd	r30, Y+1	; 0x01
    6b98:	fa 81       	ldd	r31, Y+2	; 0x02
    6b9a:	04 80       	ldd	r0, Z+4	; 0x04
    6b9c:	f5 81       	ldd	r31, Z+5	; 0x05
    6b9e:	e0 2d       	mov	r30, r0
    6ba0:	80 91 56 07 	lds	r24, 0x0756
    6ba4:	90 91 57 07 	lds	r25, 0x0757
    6ba8:	0c 96       	adiw	r24, 0x0c	; 12
    6baa:	93 83       	std	Z+3, r25	; 0x03
    6bac:	82 83       	std	Z+2, r24	; 0x02
    6bae:	80 91 56 07 	lds	r24, 0x0756
    6bb2:	90 91 57 07 	lds	r25, 0x0757
    6bb6:	0c 96       	adiw	r24, 0x0c	; 12
    6bb8:	e9 81       	ldd	r30, Y+1	; 0x01
    6bba:	fa 81       	ldd	r31, Y+2	; 0x02
    6bbc:	95 83       	std	Z+5, r25	; 0x05
    6bbe:	84 83       	std	Z+4, r24	; 0x04
    6bc0:	e0 91 56 07 	lds	r30, 0x0756
    6bc4:	f0 91 57 07 	lds	r31, 0x0757
    6bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    6bca:	9c 81       	ldd	r25, Y+4	; 0x04
    6bcc:	95 8b       	std	Z+21, r25	; 0x15
    6bce:	84 8b       	std	Z+20, r24	; 0x14
    6bd0:	eb 81       	ldd	r30, Y+3	; 0x03
    6bd2:	fc 81       	ldd	r31, Y+4	; 0x04
    6bd4:	80 81       	ld	r24, Z
    6bd6:	8f 5f       	subi	r24, 0xFF	; 255
    6bd8:	eb 81       	ldd	r30, Y+3	; 0x03
    6bda:	fc 81       	ldd	r31, Y+4	; 0x04
    6bdc:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6bde:	8f 81       	ldd	r24, Y+7	; 0x07
    6be0:	98 85       	ldd	r25, Y+8	; 0x08
    6be2:	61 e0       	ldi	r22, 0x01	; 1
    6be4:	0e 94 04 44 	call	0x8808	; 0x8808 <prvAddCurrentTaskToDelayedList>
}
    6be8:	28 96       	adiw	r28, 0x08	; 8
    6bea:	0f b6       	in	r0, 0x3f	; 63
    6bec:	f8 94       	cli
    6bee:	de bf       	out	0x3e, r29	; 62
    6bf0:	0f be       	out	0x3f, r0	; 63
    6bf2:	cd bf       	out	0x3d, r28	; 61
    6bf4:	cf 91       	pop	r28
    6bf6:	df 91       	pop	r29
    6bf8:	08 95       	ret

00006bfa <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    6bfa:	df 93       	push	r29
    6bfc:	cf 93       	push	r28
    6bfe:	cd b7       	in	r28, 0x3d	; 61
    6c00:	de b7       	in	r29, 0x3e	; 62
    6c02:	2d 97       	sbiw	r28, 0x0d	; 13
    6c04:	0f b6       	in	r0, 0x3f	; 63
    6c06:	f8 94       	cli
    6c08:	de bf       	out	0x3e, r29	; 62
    6c0a:	0f be       	out	0x3f, r0	; 63
    6c0c:	cd bf       	out	0x3d, r28	; 61
    6c0e:	9d 87       	std	Y+13, r25	; 0x0d
    6c10:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6c12:	ec 85       	ldd	r30, Y+12	; 0x0c
    6c14:	fd 85       	ldd	r31, Y+13	; 0x0d
    6c16:	05 80       	ldd	r0, Z+5	; 0x05
    6c18:	f6 81       	ldd	r31, Z+6	; 0x06
    6c1a:	e0 2d       	mov	r30, r0
    6c1c:	86 81       	ldd	r24, Z+6	; 0x06
    6c1e:	97 81       	ldd	r25, Z+7	; 0x07
    6c20:	9b 87       	std	Y+11, r25	; 0x0b
    6c22:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    6c24:	ea 85       	ldd	r30, Y+10	; 0x0a
    6c26:	fb 85       	ldd	r31, Y+11	; 0x0b
    6c28:	84 89       	ldd	r24, Z+20	; 0x14
    6c2a:	95 89       	ldd	r25, Z+21	; 0x15
    6c2c:	98 87       	std	Y+8, r25	; 0x08
    6c2e:	8f 83       	std	Y+7, r24	; 0x07
    6c30:	ea 85       	ldd	r30, Y+10	; 0x0a
    6c32:	fb 85       	ldd	r31, Y+11	; 0x0b
    6c34:	a6 85       	ldd	r26, Z+14	; 0x0e
    6c36:	b7 85       	ldd	r27, Z+15	; 0x0f
    6c38:	ea 85       	ldd	r30, Y+10	; 0x0a
    6c3a:	fb 85       	ldd	r31, Y+11	; 0x0b
    6c3c:	80 89       	ldd	r24, Z+16	; 0x10
    6c3e:	91 89       	ldd	r25, Z+17	; 0x11
    6c40:	15 96       	adiw	r26, 0x05	; 5
    6c42:	9c 93       	st	X, r25
    6c44:	8e 93       	st	-X, r24
    6c46:	14 97       	sbiw	r26, 0x04	; 4
    6c48:	ea 85       	ldd	r30, Y+10	; 0x0a
    6c4a:	fb 85       	ldd	r31, Y+11	; 0x0b
    6c4c:	a0 89       	ldd	r26, Z+16	; 0x10
    6c4e:	b1 89       	ldd	r27, Z+17	; 0x11
    6c50:	ea 85       	ldd	r30, Y+10	; 0x0a
    6c52:	fb 85       	ldd	r31, Y+11	; 0x0b
    6c54:	86 85       	ldd	r24, Z+14	; 0x0e
    6c56:	97 85       	ldd	r25, Z+15	; 0x0f
    6c58:	13 96       	adiw	r26, 0x03	; 3
    6c5a:	9c 93       	st	X, r25
    6c5c:	8e 93       	st	-X, r24
    6c5e:	12 97       	sbiw	r26, 0x02	; 2
    6c60:	ef 81       	ldd	r30, Y+7	; 0x07
    6c62:	f8 85       	ldd	r31, Y+8	; 0x08
    6c64:	21 81       	ldd	r18, Z+1	; 0x01
    6c66:	32 81       	ldd	r19, Z+2	; 0x02
    6c68:	8a 85       	ldd	r24, Y+10	; 0x0a
    6c6a:	9b 85       	ldd	r25, Y+11	; 0x0b
    6c6c:	0c 96       	adiw	r24, 0x0c	; 12
    6c6e:	28 17       	cp	r18, r24
    6c70:	39 07       	cpc	r19, r25
    6c72:	41 f4       	brne	.+16     	; 0x6c84 <xTaskRemoveFromEventList+0x8a>
    6c74:	ea 85       	ldd	r30, Y+10	; 0x0a
    6c76:	fb 85       	ldd	r31, Y+11	; 0x0b
    6c78:	80 89       	ldd	r24, Z+16	; 0x10
    6c7a:	91 89       	ldd	r25, Z+17	; 0x11
    6c7c:	ef 81       	ldd	r30, Y+7	; 0x07
    6c7e:	f8 85       	ldd	r31, Y+8	; 0x08
    6c80:	92 83       	std	Z+2, r25	; 0x02
    6c82:	81 83       	std	Z+1, r24	; 0x01
    6c84:	ea 85       	ldd	r30, Y+10	; 0x0a
    6c86:	fb 85       	ldd	r31, Y+11	; 0x0b
    6c88:	15 8a       	std	Z+21, r1	; 0x15
    6c8a:	14 8a       	std	Z+20, r1	; 0x14
    6c8c:	ef 81       	ldd	r30, Y+7	; 0x07
    6c8e:	f8 85       	ldd	r31, Y+8	; 0x08
    6c90:	80 81       	ld	r24, Z
    6c92:	81 50       	subi	r24, 0x01	; 1
    6c94:	ef 81       	ldd	r30, Y+7	; 0x07
    6c96:	f8 85       	ldd	r31, Y+8	; 0x08
    6c98:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6c9a:	80 91 67 07 	lds	r24, 0x0767
    6c9e:	88 23       	and	r24, r24
    6ca0:	09 f0       	breq	.+2      	; 0x6ca4 <xTaskRemoveFromEventList+0xaa>
    6ca2:	a4 c0       	rjmp	.+328    	; 0x6dec <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    6ca4:	ea 85       	ldd	r30, Y+10	; 0x0a
    6ca6:	fb 85       	ldd	r31, Y+11	; 0x0b
    6ca8:	82 85       	ldd	r24, Z+10	; 0x0a
    6caa:	93 85       	ldd	r25, Z+11	; 0x0b
    6cac:	9e 83       	std	Y+6, r25	; 0x06
    6cae:	8d 83       	std	Y+5, r24	; 0x05
    6cb0:	ea 85       	ldd	r30, Y+10	; 0x0a
    6cb2:	fb 85       	ldd	r31, Y+11	; 0x0b
    6cb4:	a4 81       	ldd	r26, Z+4	; 0x04
    6cb6:	b5 81       	ldd	r27, Z+5	; 0x05
    6cb8:	ea 85       	ldd	r30, Y+10	; 0x0a
    6cba:	fb 85       	ldd	r31, Y+11	; 0x0b
    6cbc:	86 81       	ldd	r24, Z+6	; 0x06
    6cbe:	97 81       	ldd	r25, Z+7	; 0x07
    6cc0:	15 96       	adiw	r26, 0x05	; 5
    6cc2:	9c 93       	st	X, r25
    6cc4:	8e 93       	st	-X, r24
    6cc6:	14 97       	sbiw	r26, 0x04	; 4
    6cc8:	ea 85       	ldd	r30, Y+10	; 0x0a
    6cca:	fb 85       	ldd	r31, Y+11	; 0x0b
    6ccc:	a6 81       	ldd	r26, Z+6	; 0x06
    6cce:	b7 81       	ldd	r27, Z+7	; 0x07
    6cd0:	ea 85       	ldd	r30, Y+10	; 0x0a
    6cd2:	fb 85       	ldd	r31, Y+11	; 0x0b
    6cd4:	84 81       	ldd	r24, Z+4	; 0x04
    6cd6:	95 81       	ldd	r25, Z+5	; 0x05
    6cd8:	13 96       	adiw	r26, 0x03	; 3
    6cda:	9c 93       	st	X, r25
    6cdc:	8e 93       	st	-X, r24
    6cde:	12 97       	sbiw	r26, 0x02	; 2
    6ce0:	ed 81       	ldd	r30, Y+5	; 0x05
    6ce2:	fe 81       	ldd	r31, Y+6	; 0x06
    6ce4:	21 81       	ldd	r18, Z+1	; 0x01
    6ce6:	32 81       	ldd	r19, Z+2	; 0x02
    6ce8:	8a 85       	ldd	r24, Y+10	; 0x0a
    6cea:	9b 85       	ldd	r25, Y+11	; 0x0b
    6cec:	02 96       	adiw	r24, 0x02	; 2
    6cee:	28 17       	cp	r18, r24
    6cf0:	39 07       	cpc	r19, r25
    6cf2:	41 f4       	brne	.+16     	; 0x6d04 <xTaskRemoveFromEventList+0x10a>
    6cf4:	ea 85       	ldd	r30, Y+10	; 0x0a
    6cf6:	fb 85       	ldd	r31, Y+11	; 0x0b
    6cf8:	86 81       	ldd	r24, Z+6	; 0x06
    6cfa:	97 81       	ldd	r25, Z+7	; 0x07
    6cfc:	ed 81       	ldd	r30, Y+5	; 0x05
    6cfe:	fe 81       	ldd	r31, Y+6	; 0x06
    6d00:	92 83       	std	Z+2, r25	; 0x02
    6d02:	81 83       	std	Z+1, r24	; 0x01
    6d04:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d06:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d08:	13 86       	std	Z+11, r1	; 0x0b
    6d0a:	12 86       	std	Z+10, r1	; 0x0a
    6d0c:	ed 81       	ldd	r30, Y+5	; 0x05
    6d0e:	fe 81       	ldd	r31, Y+6	; 0x06
    6d10:	80 81       	ld	r24, Z
    6d12:	81 50       	subi	r24, 0x01	; 1
    6d14:	ed 81       	ldd	r30, Y+5	; 0x05
    6d16:	fe 81       	ldd	r31, Y+6	; 0x06
    6d18:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    6d1a:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d1c:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d1e:	96 89       	ldd	r25, Z+22	; 0x16
    6d20:	80 91 5c 07 	lds	r24, 0x075C
    6d24:	89 17       	cp	r24, r25
    6d26:	28 f4       	brcc	.+10     	; 0x6d32 <xTaskRemoveFromEventList+0x138>
    6d28:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d2a:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d2c:	86 89       	ldd	r24, Z+22	; 0x16
    6d2e:	80 93 5c 07 	sts	0x075C, r24
    6d32:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d34:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d36:	86 89       	ldd	r24, Z+22	; 0x16
    6d38:	28 2f       	mov	r18, r24
    6d3a:	30 e0       	ldi	r19, 0x00	; 0
    6d3c:	c9 01       	movw	r24, r18
    6d3e:	88 0f       	add	r24, r24
    6d40:	99 1f       	adc	r25, r25
    6d42:	88 0f       	add	r24, r24
    6d44:	99 1f       	adc	r25, r25
    6d46:	88 0f       	add	r24, r24
    6d48:	99 1f       	adc	r25, r25
    6d4a:	82 0f       	add	r24, r18
    6d4c:	93 1f       	adc	r25, r19
    6d4e:	fc 01       	movw	r30, r24
    6d50:	e8 59       	subi	r30, 0x98	; 152
    6d52:	f8 4f       	sbci	r31, 0xF8	; 248
    6d54:	81 81       	ldd	r24, Z+1	; 0x01
    6d56:	92 81       	ldd	r25, Z+2	; 0x02
    6d58:	9c 83       	std	Y+4, r25	; 0x04
    6d5a:	8b 83       	std	Y+3, r24	; 0x03
    6d5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d60:	8b 81       	ldd	r24, Y+3	; 0x03
    6d62:	9c 81       	ldd	r25, Y+4	; 0x04
    6d64:	95 83       	std	Z+5, r25	; 0x05
    6d66:	84 83       	std	Z+4, r24	; 0x04
    6d68:	eb 81       	ldd	r30, Y+3	; 0x03
    6d6a:	fc 81       	ldd	r31, Y+4	; 0x04
    6d6c:	84 81       	ldd	r24, Z+4	; 0x04
    6d6e:	95 81       	ldd	r25, Z+5	; 0x05
    6d70:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d72:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d74:	97 83       	std	Z+7, r25	; 0x07
    6d76:	86 83       	std	Z+6, r24	; 0x06
    6d78:	eb 81       	ldd	r30, Y+3	; 0x03
    6d7a:	fc 81       	ldd	r31, Y+4	; 0x04
    6d7c:	04 80       	ldd	r0, Z+4	; 0x04
    6d7e:	f5 81       	ldd	r31, Z+5	; 0x05
    6d80:	e0 2d       	mov	r30, r0
    6d82:	8a 85       	ldd	r24, Y+10	; 0x0a
    6d84:	9b 85       	ldd	r25, Y+11	; 0x0b
    6d86:	02 96       	adiw	r24, 0x02	; 2
    6d88:	93 83       	std	Z+3, r25	; 0x03
    6d8a:	82 83       	std	Z+2, r24	; 0x02
    6d8c:	8a 85       	ldd	r24, Y+10	; 0x0a
    6d8e:	9b 85       	ldd	r25, Y+11	; 0x0b
    6d90:	02 96       	adiw	r24, 0x02	; 2
    6d92:	eb 81       	ldd	r30, Y+3	; 0x03
    6d94:	fc 81       	ldd	r31, Y+4	; 0x04
    6d96:	95 83       	std	Z+5, r25	; 0x05
    6d98:	84 83       	std	Z+4, r24	; 0x04
    6d9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    6d9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    6d9e:	86 89       	ldd	r24, Z+22	; 0x16
    6da0:	28 2f       	mov	r18, r24
    6da2:	30 e0       	ldi	r19, 0x00	; 0
    6da4:	c9 01       	movw	r24, r18
    6da6:	88 0f       	add	r24, r24
    6da8:	99 1f       	adc	r25, r25
    6daa:	88 0f       	add	r24, r24
    6dac:	99 1f       	adc	r25, r25
    6dae:	88 0f       	add	r24, r24
    6db0:	99 1f       	adc	r25, r25
    6db2:	82 0f       	add	r24, r18
    6db4:	93 1f       	adc	r25, r19
    6db6:	88 59       	subi	r24, 0x98	; 152
    6db8:	98 4f       	sbci	r25, 0xF8	; 248
    6dba:	ea 85       	ldd	r30, Y+10	; 0x0a
    6dbc:	fb 85       	ldd	r31, Y+11	; 0x0b
    6dbe:	93 87       	std	Z+11, r25	; 0x0b
    6dc0:	82 87       	std	Z+10, r24	; 0x0a
    6dc2:	ea 85       	ldd	r30, Y+10	; 0x0a
    6dc4:	fb 85       	ldd	r31, Y+11	; 0x0b
    6dc6:	86 89       	ldd	r24, Z+22	; 0x16
    6dc8:	28 2f       	mov	r18, r24
    6dca:	30 e0       	ldi	r19, 0x00	; 0
    6dcc:	c9 01       	movw	r24, r18
    6dce:	88 0f       	add	r24, r24
    6dd0:	99 1f       	adc	r25, r25
    6dd2:	88 0f       	add	r24, r24
    6dd4:	99 1f       	adc	r25, r25
    6dd6:	88 0f       	add	r24, r24
    6dd8:	99 1f       	adc	r25, r25
    6dda:	82 0f       	add	r24, r18
    6ddc:	93 1f       	adc	r25, r19
    6dde:	fc 01       	movw	r30, r24
    6de0:	e8 59       	subi	r30, 0x98	; 152
    6de2:	f8 4f       	sbci	r31, 0xF8	; 248
    6de4:	80 81       	ld	r24, Z
    6de6:	8f 5f       	subi	r24, 0xFF	; 255
    6de8:	80 83       	st	Z, r24
    6dea:	30 c0       	rjmp	.+96     	; 0x6e4c <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    6dec:	80 91 a3 07 	lds	r24, 0x07A3
    6df0:	90 91 a4 07 	lds	r25, 0x07A4
    6df4:	9a 83       	std	Y+2, r25	; 0x02
    6df6:	89 83       	std	Y+1, r24	; 0x01
    6df8:	ea 85       	ldd	r30, Y+10	; 0x0a
    6dfa:	fb 85       	ldd	r31, Y+11	; 0x0b
    6dfc:	89 81       	ldd	r24, Y+1	; 0x01
    6dfe:	9a 81       	ldd	r25, Y+2	; 0x02
    6e00:	97 87       	std	Z+15, r25	; 0x0f
    6e02:	86 87       	std	Z+14, r24	; 0x0e
    6e04:	e9 81       	ldd	r30, Y+1	; 0x01
    6e06:	fa 81       	ldd	r31, Y+2	; 0x02
    6e08:	84 81       	ldd	r24, Z+4	; 0x04
    6e0a:	95 81       	ldd	r25, Z+5	; 0x05
    6e0c:	ea 85       	ldd	r30, Y+10	; 0x0a
    6e0e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6e10:	91 8b       	std	Z+17, r25	; 0x11
    6e12:	80 8b       	std	Z+16, r24	; 0x10
    6e14:	e9 81       	ldd	r30, Y+1	; 0x01
    6e16:	fa 81       	ldd	r31, Y+2	; 0x02
    6e18:	04 80       	ldd	r0, Z+4	; 0x04
    6e1a:	f5 81       	ldd	r31, Z+5	; 0x05
    6e1c:	e0 2d       	mov	r30, r0
    6e1e:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e20:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e22:	0c 96       	adiw	r24, 0x0c	; 12
    6e24:	93 83       	std	Z+3, r25	; 0x03
    6e26:	82 83       	std	Z+2, r24	; 0x02
    6e28:	8a 85       	ldd	r24, Y+10	; 0x0a
    6e2a:	9b 85       	ldd	r25, Y+11	; 0x0b
    6e2c:	0c 96       	adiw	r24, 0x0c	; 12
    6e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    6e30:	fa 81       	ldd	r31, Y+2	; 0x02
    6e32:	95 83       	std	Z+5, r25	; 0x05
    6e34:	84 83       	std	Z+4, r24	; 0x04
    6e36:	ea 85       	ldd	r30, Y+10	; 0x0a
    6e38:	fb 85       	ldd	r31, Y+11	; 0x0b
    6e3a:	82 ea       	ldi	r24, 0xA2	; 162
    6e3c:	97 e0       	ldi	r25, 0x07	; 7
    6e3e:	95 8b       	std	Z+21, r25	; 0x15
    6e40:	84 8b       	std	Z+20, r24	; 0x14
    6e42:	80 91 a2 07 	lds	r24, 0x07A2
    6e46:	8f 5f       	subi	r24, 0xFF	; 255
    6e48:	80 93 a2 07 	sts	0x07A2, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    6e4c:	ea 85       	ldd	r30, Y+10	; 0x0a
    6e4e:	fb 85       	ldd	r31, Y+11	; 0x0b
    6e50:	96 89       	ldd	r25, Z+22	; 0x16
    6e52:	e0 91 56 07 	lds	r30, 0x0756
    6e56:	f0 91 57 07 	lds	r31, 0x0757
    6e5a:	86 89       	ldd	r24, Z+22	; 0x16
    6e5c:	89 17       	cp	r24, r25
    6e5e:	30 f4       	brcc	.+12     	; 0x6e6c <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    6e60:	81 e0       	ldi	r24, 0x01	; 1
    6e62:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    6e64:	81 e0       	ldi	r24, 0x01	; 1
    6e66:	80 93 60 07 	sts	0x0760, r24
    6e6a:	01 c0       	rjmp	.+2      	; 0x6e6e <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    6e6c:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    6e6e:	89 85       	ldd	r24, Y+9	; 0x09
}
    6e70:	2d 96       	adiw	r28, 0x0d	; 13
    6e72:	0f b6       	in	r0, 0x3f	; 63
    6e74:	f8 94       	cli
    6e76:	de bf       	out	0x3e, r29	; 62
    6e78:	0f be       	out	0x3f, r0	; 63
    6e7a:	cd bf       	out	0x3d, r28	; 61
    6e7c:	cf 91       	pop	r28
    6e7e:	df 91       	pop	r29
    6e80:	08 95       	ret

00006e82 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    6e82:	df 93       	push	r29
    6e84:	cf 93       	push	r28
    6e86:	cd b7       	in	r28, 0x3d	; 61
    6e88:	de b7       	in	r29, 0x3e	; 62
    6e8a:	2c 97       	sbiw	r28, 0x0c	; 12
    6e8c:	0f b6       	in	r0, 0x3f	; 63
    6e8e:	f8 94       	cli
    6e90:	de bf       	out	0x3e, r29	; 62
    6e92:	0f be       	out	0x3f, r0	; 63
    6e94:	cd bf       	out	0x3d, r28	; 61
    6e96:	9a 87       	std	Y+10, r25	; 0x0a
    6e98:	89 87       	std	Y+9, r24	; 0x09
    6e9a:	7c 87       	std	Y+12, r23	; 0x0c
    6e9c:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    6e9e:	8b 85       	ldd	r24, Y+11	; 0x0b
    6ea0:	9c 85       	ldd	r25, Y+12	; 0x0c
    6ea2:	90 68       	ori	r25, 0x80	; 128
    6ea4:	e9 85       	ldd	r30, Y+9	; 0x09
    6ea6:	fa 85       	ldd	r31, Y+10	; 0x0a
    6ea8:	91 83       	std	Z+1, r25	; 0x01
    6eaa:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6eac:	e9 85       	ldd	r30, Y+9	; 0x09
    6eae:	fa 85       	ldd	r31, Y+10	; 0x0a
    6eb0:	86 81       	ldd	r24, Z+6	; 0x06
    6eb2:	97 81       	ldd	r25, Z+7	; 0x07
    6eb4:	98 87       	std	Y+8, r25	; 0x08
    6eb6:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    6eb8:	e9 85       	ldd	r30, Y+9	; 0x09
    6eba:	fa 85       	ldd	r31, Y+10	; 0x0a
    6ebc:	80 85       	ldd	r24, Z+8	; 0x08
    6ebe:	91 85       	ldd	r25, Z+9	; 0x09
    6ec0:	9e 83       	std	Y+6, r25	; 0x06
    6ec2:	8d 83       	std	Y+5, r24	; 0x05
    6ec4:	e9 85       	ldd	r30, Y+9	; 0x09
    6ec6:	fa 85       	ldd	r31, Y+10	; 0x0a
    6ec8:	a2 81       	ldd	r26, Z+2	; 0x02
    6eca:	b3 81       	ldd	r27, Z+3	; 0x03
    6ecc:	e9 85       	ldd	r30, Y+9	; 0x09
    6ece:	fa 85       	ldd	r31, Y+10	; 0x0a
    6ed0:	84 81       	ldd	r24, Z+4	; 0x04
    6ed2:	95 81       	ldd	r25, Z+5	; 0x05
    6ed4:	15 96       	adiw	r26, 0x05	; 5
    6ed6:	9c 93       	st	X, r25
    6ed8:	8e 93       	st	-X, r24
    6eda:	14 97       	sbiw	r26, 0x04	; 4
    6edc:	e9 85       	ldd	r30, Y+9	; 0x09
    6ede:	fa 85       	ldd	r31, Y+10	; 0x0a
    6ee0:	a4 81       	ldd	r26, Z+4	; 0x04
    6ee2:	b5 81       	ldd	r27, Z+5	; 0x05
    6ee4:	e9 85       	ldd	r30, Y+9	; 0x09
    6ee6:	fa 85       	ldd	r31, Y+10	; 0x0a
    6ee8:	82 81       	ldd	r24, Z+2	; 0x02
    6eea:	93 81       	ldd	r25, Z+3	; 0x03
    6eec:	13 96       	adiw	r26, 0x03	; 3
    6eee:	9c 93       	st	X, r25
    6ef0:	8e 93       	st	-X, r24
    6ef2:	12 97       	sbiw	r26, 0x02	; 2
    6ef4:	ed 81       	ldd	r30, Y+5	; 0x05
    6ef6:	fe 81       	ldd	r31, Y+6	; 0x06
    6ef8:	21 81       	ldd	r18, Z+1	; 0x01
    6efa:	32 81       	ldd	r19, Z+2	; 0x02
    6efc:	89 85       	ldd	r24, Y+9	; 0x09
    6efe:	9a 85       	ldd	r25, Y+10	; 0x0a
    6f00:	28 17       	cp	r18, r24
    6f02:	39 07       	cpc	r19, r25
    6f04:	41 f4       	brne	.+16     	; 0x6f16 <vTaskRemoveFromUnorderedEventList+0x94>
    6f06:	e9 85       	ldd	r30, Y+9	; 0x09
    6f08:	fa 85       	ldd	r31, Y+10	; 0x0a
    6f0a:	84 81       	ldd	r24, Z+4	; 0x04
    6f0c:	95 81       	ldd	r25, Z+5	; 0x05
    6f0e:	ed 81       	ldd	r30, Y+5	; 0x05
    6f10:	fe 81       	ldd	r31, Y+6	; 0x06
    6f12:	92 83       	std	Z+2, r25	; 0x02
    6f14:	81 83       	std	Z+1, r24	; 0x01
    6f16:	e9 85       	ldd	r30, Y+9	; 0x09
    6f18:	fa 85       	ldd	r31, Y+10	; 0x0a
    6f1a:	11 86       	std	Z+9, r1	; 0x09
    6f1c:	10 86       	std	Z+8, r1	; 0x08
    6f1e:	ed 81       	ldd	r30, Y+5	; 0x05
    6f20:	fe 81       	ldd	r31, Y+6	; 0x06
    6f22:	80 81       	ld	r24, Z
    6f24:	81 50       	subi	r24, 0x01	; 1
    6f26:	ed 81       	ldd	r30, Y+5	; 0x05
    6f28:	fe 81       	ldd	r31, Y+6	; 0x06
    6f2a:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    6f2c:	ef 81       	ldd	r30, Y+7	; 0x07
    6f2e:	f8 85       	ldd	r31, Y+8	; 0x08
    6f30:	82 85       	ldd	r24, Z+10	; 0x0a
    6f32:	93 85       	ldd	r25, Z+11	; 0x0b
    6f34:	9c 83       	std	Y+4, r25	; 0x04
    6f36:	8b 83       	std	Y+3, r24	; 0x03
    6f38:	ef 81       	ldd	r30, Y+7	; 0x07
    6f3a:	f8 85       	ldd	r31, Y+8	; 0x08
    6f3c:	a4 81       	ldd	r26, Z+4	; 0x04
    6f3e:	b5 81       	ldd	r27, Z+5	; 0x05
    6f40:	ef 81       	ldd	r30, Y+7	; 0x07
    6f42:	f8 85       	ldd	r31, Y+8	; 0x08
    6f44:	86 81       	ldd	r24, Z+6	; 0x06
    6f46:	97 81       	ldd	r25, Z+7	; 0x07
    6f48:	15 96       	adiw	r26, 0x05	; 5
    6f4a:	9c 93       	st	X, r25
    6f4c:	8e 93       	st	-X, r24
    6f4e:	14 97       	sbiw	r26, 0x04	; 4
    6f50:	ef 81       	ldd	r30, Y+7	; 0x07
    6f52:	f8 85       	ldd	r31, Y+8	; 0x08
    6f54:	a6 81       	ldd	r26, Z+6	; 0x06
    6f56:	b7 81       	ldd	r27, Z+7	; 0x07
    6f58:	ef 81       	ldd	r30, Y+7	; 0x07
    6f5a:	f8 85       	ldd	r31, Y+8	; 0x08
    6f5c:	84 81       	ldd	r24, Z+4	; 0x04
    6f5e:	95 81       	ldd	r25, Z+5	; 0x05
    6f60:	13 96       	adiw	r26, 0x03	; 3
    6f62:	9c 93       	st	X, r25
    6f64:	8e 93       	st	-X, r24
    6f66:	12 97       	sbiw	r26, 0x02	; 2
    6f68:	eb 81       	ldd	r30, Y+3	; 0x03
    6f6a:	fc 81       	ldd	r31, Y+4	; 0x04
    6f6c:	21 81       	ldd	r18, Z+1	; 0x01
    6f6e:	32 81       	ldd	r19, Z+2	; 0x02
    6f70:	8f 81       	ldd	r24, Y+7	; 0x07
    6f72:	98 85       	ldd	r25, Y+8	; 0x08
    6f74:	02 96       	adiw	r24, 0x02	; 2
    6f76:	28 17       	cp	r18, r24
    6f78:	39 07       	cpc	r19, r25
    6f7a:	41 f4       	brne	.+16     	; 0x6f8c <vTaskRemoveFromUnorderedEventList+0x10a>
    6f7c:	ef 81       	ldd	r30, Y+7	; 0x07
    6f7e:	f8 85       	ldd	r31, Y+8	; 0x08
    6f80:	86 81       	ldd	r24, Z+6	; 0x06
    6f82:	97 81       	ldd	r25, Z+7	; 0x07
    6f84:	eb 81       	ldd	r30, Y+3	; 0x03
    6f86:	fc 81       	ldd	r31, Y+4	; 0x04
    6f88:	92 83       	std	Z+2, r25	; 0x02
    6f8a:	81 83       	std	Z+1, r24	; 0x01
    6f8c:	ef 81       	ldd	r30, Y+7	; 0x07
    6f8e:	f8 85       	ldd	r31, Y+8	; 0x08
    6f90:	13 86       	std	Z+11, r1	; 0x0b
    6f92:	12 86       	std	Z+10, r1	; 0x0a
    6f94:	eb 81       	ldd	r30, Y+3	; 0x03
    6f96:	fc 81       	ldd	r31, Y+4	; 0x04
    6f98:	80 81       	ld	r24, Z
    6f9a:	81 50       	subi	r24, 0x01	; 1
    6f9c:	eb 81       	ldd	r30, Y+3	; 0x03
    6f9e:	fc 81       	ldd	r31, Y+4	; 0x04
    6fa0:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    6fa2:	ef 81       	ldd	r30, Y+7	; 0x07
    6fa4:	f8 85       	ldd	r31, Y+8	; 0x08
    6fa6:	96 89       	ldd	r25, Z+22	; 0x16
    6fa8:	80 91 5c 07 	lds	r24, 0x075C
    6fac:	89 17       	cp	r24, r25
    6fae:	28 f4       	brcc	.+10     	; 0x6fba <vTaskRemoveFromUnorderedEventList+0x138>
    6fb0:	ef 81       	ldd	r30, Y+7	; 0x07
    6fb2:	f8 85       	ldd	r31, Y+8	; 0x08
    6fb4:	86 89       	ldd	r24, Z+22	; 0x16
    6fb6:	80 93 5c 07 	sts	0x075C, r24
    6fba:	ef 81       	ldd	r30, Y+7	; 0x07
    6fbc:	f8 85       	ldd	r31, Y+8	; 0x08
    6fbe:	86 89       	ldd	r24, Z+22	; 0x16
    6fc0:	28 2f       	mov	r18, r24
    6fc2:	30 e0       	ldi	r19, 0x00	; 0
    6fc4:	c9 01       	movw	r24, r18
    6fc6:	88 0f       	add	r24, r24
    6fc8:	99 1f       	adc	r25, r25
    6fca:	88 0f       	add	r24, r24
    6fcc:	99 1f       	adc	r25, r25
    6fce:	88 0f       	add	r24, r24
    6fd0:	99 1f       	adc	r25, r25
    6fd2:	82 0f       	add	r24, r18
    6fd4:	93 1f       	adc	r25, r19
    6fd6:	fc 01       	movw	r30, r24
    6fd8:	e8 59       	subi	r30, 0x98	; 152
    6fda:	f8 4f       	sbci	r31, 0xF8	; 248
    6fdc:	81 81       	ldd	r24, Z+1	; 0x01
    6fde:	92 81       	ldd	r25, Z+2	; 0x02
    6fe0:	9a 83       	std	Y+2, r25	; 0x02
    6fe2:	89 83       	std	Y+1, r24	; 0x01
    6fe4:	ef 81       	ldd	r30, Y+7	; 0x07
    6fe6:	f8 85       	ldd	r31, Y+8	; 0x08
    6fe8:	89 81       	ldd	r24, Y+1	; 0x01
    6fea:	9a 81       	ldd	r25, Y+2	; 0x02
    6fec:	95 83       	std	Z+5, r25	; 0x05
    6fee:	84 83       	std	Z+4, r24	; 0x04
    6ff0:	e9 81       	ldd	r30, Y+1	; 0x01
    6ff2:	fa 81       	ldd	r31, Y+2	; 0x02
    6ff4:	84 81       	ldd	r24, Z+4	; 0x04
    6ff6:	95 81       	ldd	r25, Z+5	; 0x05
    6ff8:	ef 81       	ldd	r30, Y+7	; 0x07
    6ffa:	f8 85       	ldd	r31, Y+8	; 0x08
    6ffc:	97 83       	std	Z+7, r25	; 0x07
    6ffe:	86 83       	std	Z+6, r24	; 0x06
    7000:	e9 81       	ldd	r30, Y+1	; 0x01
    7002:	fa 81       	ldd	r31, Y+2	; 0x02
    7004:	04 80       	ldd	r0, Z+4	; 0x04
    7006:	f5 81       	ldd	r31, Z+5	; 0x05
    7008:	e0 2d       	mov	r30, r0
    700a:	8f 81       	ldd	r24, Y+7	; 0x07
    700c:	98 85       	ldd	r25, Y+8	; 0x08
    700e:	02 96       	adiw	r24, 0x02	; 2
    7010:	93 83       	std	Z+3, r25	; 0x03
    7012:	82 83       	std	Z+2, r24	; 0x02
    7014:	8f 81       	ldd	r24, Y+7	; 0x07
    7016:	98 85       	ldd	r25, Y+8	; 0x08
    7018:	02 96       	adiw	r24, 0x02	; 2
    701a:	e9 81       	ldd	r30, Y+1	; 0x01
    701c:	fa 81       	ldd	r31, Y+2	; 0x02
    701e:	95 83       	std	Z+5, r25	; 0x05
    7020:	84 83       	std	Z+4, r24	; 0x04
    7022:	ef 81       	ldd	r30, Y+7	; 0x07
    7024:	f8 85       	ldd	r31, Y+8	; 0x08
    7026:	86 89       	ldd	r24, Z+22	; 0x16
    7028:	28 2f       	mov	r18, r24
    702a:	30 e0       	ldi	r19, 0x00	; 0
    702c:	c9 01       	movw	r24, r18
    702e:	88 0f       	add	r24, r24
    7030:	99 1f       	adc	r25, r25
    7032:	88 0f       	add	r24, r24
    7034:	99 1f       	adc	r25, r25
    7036:	88 0f       	add	r24, r24
    7038:	99 1f       	adc	r25, r25
    703a:	82 0f       	add	r24, r18
    703c:	93 1f       	adc	r25, r19
    703e:	88 59       	subi	r24, 0x98	; 152
    7040:	98 4f       	sbci	r25, 0xF8	; 248
    7042:	ef 81       	ldd	r30, Y+7	; 0x07
    7044:	f8 85       	ldd	r31, Y+8	; 0x08
    7046:	93 87       	std	Z+11, r25	; 0x0b
    7048:	82 87       	std	Z+10, r24	; 0x0a
    704a:	ef 81       	ldd	r30, Y+7	; 0x07
    704c:	f8 85       	ldd	r31, Y+8	; 0x08
    704e:	86 89       	ldd	r24, Z+22	; 0x16
    7050:	28 2f       	mov	r18, r24
    7052:	30 e0       	ldi	r19, 0x00	; 0
    7054:	c9 01       	movw	r24, r18
    7056:	88 0f       	add	r24, r24
    7058:	99 1f       	adc	r25, r25
    705a:	88 0f       	add	r24, r24
    705c:	99 1f       	adc	r25, r25
    705e:	88 0f       	add	r24, r24
    7060:	99 1f       	adc	r25, r25
    7062:	82 0f       	add	r24, r18
    7064:	93 1f       	adc	r25, r19
    7066:	fc 01       	movw	r30, r24
    7068:	e8 59       	subi	r30, 0x98	; 152
    706a:	f8 4f       	sbci	r31, 0xF8	; 248
    706c:	80 81       	ld	r24, Z
    706e:	8f 5f       	subi	r24, 0xFF	; 255
    7070:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    7072:	ef 81       	ldd	r30, Y+7	; 0x07
    7074:	f8 85       	ldd	r31, Y+8	; 0x08
    7076:	96 89       	ldd	r25, Z+22	; 0x16
    7078:	e0 91 56 07 	lds	r30, 0x0756
    707c:	f0 91 57 07 	lds	r31, 0x0757
    7080:	86 89       	ldd	r24, Z+22	; 0x16
    7082:	89 17       	cp	r24, r25
    7084:	18 f4       	brcc	.+6      	; 0x708c <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    7086:	81 e0       	ldi	r24, 0x01	; 1
    7088:	80 93 60 07 	sts	0x0760, r24
    }
}
    708c:	2c 96       	adiw	r28, 0x0c	; 12
    708e:	0f b6       	in	r0, 0x3f	; 63
    7090:	f8 94       	cli
    7092:	de bf       	out	0x3e, r29	; 62
    7094:	0f be       	out	0x3f, r0	; 63
    7096:	cd bf       	out	0x3d, r28	; 61
    7098:	cf 91       	pop	r28
    709a:	df 91       	pop	r29
    709c:	08 95       	ret

0000709e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    709e:	df 93       	push	r29
    70a0:	cf 93       	push	r28
    70a2:	00 d0       	rcall	.+0      	; 0x70a4 <vTaskSetTimeOutState+0x6>
    70a4:	cd b7       	in	r28, 0x3d	; 61
    70a6:	de b7       	in	r29, 0x3e	; 62
    70a8:	9a 83       	std	Y+2, r25	; 0x02
    70aa:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    70ac:	0f b6       	in	r0, 0x3f	; 63
    70ae:	f8 94       	cli
    70b0:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    70b2:	80 91 61 07 	lds	r24, 0x0761
    70b6:	e9 81       	ldd	r30, Y+1	; 0x01
    70b8:	fa 81       	ldd	r31, Y+2	; 0x02
    70ba:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    70bc:	80 91 5a 07 	lds	r24, 0x075A
    70c0:	90 91 5b 07 	lds	r25, 0x075B
    70c4:	e9 81       	ldd	r30, Y+1	; 0x01
    70c6:	fa 81       	ldd	r31, Y+2	; 0x02
    70c8:	92 83       	std	Z+2, r25	; 0x02
    70ca:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    70cc:	0f 90       	pop	r0
    70ce:	0f be       	out	0x3f, r0	; 63
}
    70d0:	0f 90       	pop	r0
    70d2:	0f 90       	pop	r0
    70d4:	cf 91       	pop	r28
    70d6:	df 91       	pop	r29
    70d8:	08 95       	ret

000070da <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    70da:	df 93       	push	r29
    70dc:	cf 93       	push	r28
    70de:	00 d0       	rcall	.+0      	; 0x70e0 <vTaskInternalSetTimeOutState+0x6>
    70e0:	cd b7       	in	r28, 0x3d	; 61
    70e2:	de b7       	in	r29, 0x3e	; 62
    70e4:	9a 83       	std	Y+2, r25	; 0x02
    70e6:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    70e8:	80 91 61 07 	lds	r24, 0x0761
    70ec:	e9 81       	ldd	r30, Y+1	; 0x01
    70ee:	fa 81       	ldd	r31, Y+2	; 0x02
    70f0:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    70f2:	80 91 5a 07 	lds	r24, 0x075A
    70f6:	90 91 5b 07 	lds	r25, 0x075B
    70fa:	e9 81       	ldd	r30, Y+1	; 0x01
    70fc:	fa 81       	ldd	r31, Y+2	; 0x02
    70fe:	92 83       	std	Z+2, r25	; 0x02
    7100:	81 83       	std	Z+1, r24	; 0x01
}
    7102:	0f 90       	pop	r0
    7104:	0f 90       	pop	r0
    7106:	cf 91       	pop	r28
    7108:	df 91       	pop	r29
    710a:	08 95       	ret

0000710c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    710c:	df 93       	push	r29
    710e:	cf 93       	push	r28
    7110:	cd b7       	in	r28, 0x3d	; 61
    7112:	de b7       	in	r29, 0x3e	; 62
    7114:	29 97       	sbiw	r28, 0x09	; 9
    7116:	0f b6       	in	r0, 0x3f	; 63
    7118:	f8 94       	cli
    711a:	de bf       	out	0x3e, r29	; 62
    711c:	0f be       	out	0x3f, r0	; 63
    711e:	cd bf       	out	0x3d, r28	; 61
    7120:	9f 83       	std	Y+7, r25	; 0x07
    7122:	8e 83       	std	Y+6, r24	; 0x06
    7124:	79 87       	std	Y+9, r23	; 0x09
    7126:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    7128:	0f b6       	in	r0, 0x3f	; 63
    712a:	f8 94       	cli
    712c:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    712e:	80 91 5a 07 	lds	r24, 0x075A
    7132:	90 91 5b 07 	lds	r25, 0x075B
    7136:	9c 83       	std	Y+4, r25	; 0x04
    7138:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    713a:	ee 81       	ldd	r30, Y+6	; 0x06
    713c:	ff 81       	ldd	r31, Y+7	; 0x07
    713e:	21 81       	ldd	r18, Z+1	; 0x01
    7140:	32 81       	ldd	r19, Z+2	; 0x02
    7142:	8b 81       	ldd	r24, Y+3	; 0x03
    7144:	9c 81       	ldd	r25, Y+4	; 0x04
    7146:	82 1b       	sub	r24, r18
    7148:	93 0b       	sbc	r25, r19
    714a:	9a 83       	std	Y+2, r25	; 0x02
    714c:	89 83       	std	Y+1, r24	; 0x01
            }
            else
        #endif

        #if ( INCLUDE_vTaskSuspend == 1 )
            if( *pxTicksToWait == portMAX_DELAY )
    714e:	e8 85       	ldd	r30, Y+8	; 0x08
    7150:	f9 85       	ldd	r31, Y+9	; 0x09
    7152:	80 81       	ld	r24, Z
    7154:	91 81       	ldd	r25, Z+1	; 0x01
    7156:	2f ef       	ldi	r18, 0xFF	; 255
    7158:	8f 3f       	cpi	r24, 0xFF	; 255
    715a:	92 07       	cpc	r25, r18
    715c:	11 f4       	brne	.+4      	; 0x7162 <xTaskCheckForTimeOut+0x56>
            {
                /* If INCLUDE_vTaskSuspend is set to 1 and the block time
                 * specified is the maximum block time then the task should block
                 * indefinitely, and therefore never time out. */
                xReturn = pdFALSE;
    715e:	1d 82       	std	Y+5, r1	; 0x05
    7160:	3a c0       	rjmp	.+116    	; 0x71d6 <xTaskCheckForTimeOut+0xca>
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    7162:	ee 81       	ldd	r30, Y+6	; 0x06
    7164:	ff 81       	ldd	r31, Y+7	; 0x07
    7166:	90 81       	ld	r25, Z
    7168:	80 91 61 07 	lds	r24, 0x0761
    716c:	98 17       	cp	r25, r24
    716e:	81 f0       	breq	.+32     	; 0x7190 <xTaskCheckForTimeOut+0x84>
    7170:	ee 81       	ldd	r30, Y+6	; 0x06
    7172:	ff 81       	ldd	r31, Y+7	; 0x07
    7174:	21 81       	ldd	r18, Z+1	; 0x01
    7176:	32 81       	ldd	r19, Z+2	; 0x02
    7178:	8b 81       	ldd	r24, Y+3	; 0x03
    717a:	9c 81       	ldd	r25, Y+4	; 0x04
    717c:	82 17       	cp	r24, r18
    717e:	93 07       	cpc	r25, r19
    7180:	38 f0       	brcs	.+14     	; 0x7190 <xTaskCheckForTimeOut+0x84>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    7182:	81 e0       	ldi	r24, 0x01	; 1
    7184:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    7186:	e8 85       	ldd	r30, Y+8	; 0x08
    7188:	f9 85       	ldd	r31, Y+9	; 0x09
    718a:	11 82       	std	Z+1, r1	; 0x01
    718c:	10 82       	st	Z, r1
    718e:	23 c0       	rjmp	.+70     	; 0x71d6 <xTaskCheckForTimeOut+0xca>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    7190:	e8 85       	ldd	r30, Y+8	; 0x08
    7192:	f9 85       	ldd	r31, Y+9	; 0x09
    7194:	20 81       	ld	r18, Z
    7196:	31 81       	ldd	r19, Z+1	; 0x01
    7198:	89 81       	ldd	r24, Y+1	; 0x01
    719a:	9a 81       	ldd	r25, Y+2	; 0x02
    719c:	82 17       	cp	r24, r18
    719e:	93 07       	cpc	r25, r19
    71a0:	a0 f4       	brcc	.+40     	; 0x71ca <xTaskCheckForTimeOut+0xbe>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    71a2:	e8 85       	ldd	r30, Y+8	; 0x08
    71a4:	f9 85       	ldd	r31, Y+9	; 0x09
    71a6:	20 81       	ld	r18, Z
    71a8:	31 81       	ldd	r19, Z+1	; 0x01
    71aa:	89 81       	ldd	r24, Y+1	; 0x01
    71ac:	9a 81       	ldd	r25, Y+2	; 0x02
    71ae:	a9 01       	movw	r20, r18
    71b0:	48 1b       	sub	r20, r24
    71b2:	59 0b       	sbc	r21, r25
    71b4:	ca 01       	movw	r24, r20
    71b6:	e8 85       	ldd	r30, Y+8	; 0x08
    71b8:	f9 85       	ldd	r31, Y+9	; 0x09
    71ba:	91 83       	std	Z+1, r25	; 0x01
    71bc:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    71be:	8e 81       	ldd	r24, Y+6	; 0x06
    71c0:	9f 81       	ldd	r25, Y+7	; 0x07
    71c2:	0e 94 6d 38 	call	0x70da	; 0x70da <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    71c6:	1d 82       	std	Y+5, r1	; 0x05
    71c8:	06 c0       	rjmp	.+12     	; 0x71d6 <xTaskCheckForTimeOut+0xca>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    71ca:	e8 85       	ldd	r30, Y+8	; 0x08
    71cc:	f9 85       	ldd	r31, Y+9	; 0x09
    71ce:	11 82       	std	Z+1, r1	; 0x01
    71d0:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    71d2:	81 e0       	ldi	r24, 0x01	; 1
    71d4:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    71d6:	0f 90       	pop	r0
    71d8:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    71da:	8d 81       	ldd	r24, Y+5	; 0x05
}
    71dc:	29 96       	adiw	r28, 0x09	; 9
    71de:	0f b6       	in	r0, 0x3f	; 63
    71e0:	f8 94       	cli
    71e2:	de bf       	out	0x3e, r29	; 62
    71e4:	0f be       	out	0x3f, r0	; 63
    71e6:	cd bf       	out	0x3d, r28	; 61
    71e8:	cf 91       	pop	r28
    71ea:	df 91       	pop	r29
    71ec:	08 95       	ret

000071ee <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    71ee:	df 93       	push	r29
    71f0:	cf 93       	push	r28
    71f2:	cd b7       	in	r28, 0x3d	; 61
    71f4:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    71f6:	81 e0       	ldi	r24, 0x01	; 1
    71f8:	80 93 60 07 	sts	0x0760, r24
}
    71fc:	cf 91       	pop	r28
    71fe:	df 91       	pop	r29
    7200:	08 95       	ret

00007202 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    7202:	df 93       	push	r29
    7204:	cf 93       	push	r28
    7206:	00 d0       	rcall	.+0      	; 0x7208 <prvIdleTask+0x6>
    7208:	cd b7       	in	r28, 0x3d	; 61
    720a:	de b7       	in	r29, 0x3e	; 62
    720c:	9a 83       	std	Y+2, r25	; 0x02
    720e:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    7210:	0e 94 52 39 	call	0x72a4	; 0x72a4 <prvCheckTasksWaitingTermination>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    7214:	80 91 68 07 	lds	r24, 0x0768
    7218:	82 30       	cpi	r24, 0x02	; 2
    721a:	d0 f3       	brcs	.-12     	; 0x7210 <prvIdleTask+0xe>
            {
                taskYIELD();
    721c:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
    7220:	f7 cf       	rjmp	.-18     	; 0x7210 <prvIdleTask+0xe>

00007222 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    7222:	df 93       	push	r29
    7224:	cf 93       	push	r28
    7226:	0f 92       	push	r0
    7228:	cd b7       	in	r28, 0x3d	; 61
    722a:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    722c:	19 82       	std	Y+1, r1	; 0x01
    722e:	13 c0       	rjmp	.+38     	; 0x7256 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    7230:	89 81       	ldd	r24, Y+1	; 0x01
    7232:	28 2f       	mov	r18, r24
    7234:	30 e0       	ldi	r19, 0x00	; 0
    7236:	c9 01       	movw	r24, r18
    7238:	88 0f       	add	r24, r24
    723a:	99 1f       	adc	r25, r25
    723c:	88 0f       	add	r24, r24
    723e:	99 1f       	adc	r25, r25
    7240:	88 0f       	add	r24, r24
    7242:	99 1f       	adc	r25, r25
    7244:	82 0f       	add	r24, r18
    7246:	93 1f       	adc	r25, r19
    7248:	88 59       	subi	r24, 0x98	; 152
    724a:	98 4f       	sbci	r25, 0xF8	; 248
    724c:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    7250:	89 81       	ldd	r24, Y+1	; 0x01
    7252:	8f 5f       	subi	r24, 0xFF	; 255
    7254:	89 83       	std	Y+1, r24	; 0x01
    7256:	89 81       	ldd	r24, Y+1	; 0x01
    7258:	84 30       	cpi	r24, 0x04	; 4
    725a:	50 f3       	brcs	.-44     	; 0x7230 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    725c:	8c e8       	ldi	r24, 0x8C	; 140
    725e:	97 e0       	ldi	r25, 0x07	; 7
    7260:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    7264:	85 e9       	ldi	r24, 0x95	; 149
    7266:	97 e0       	ldi	r25, 0x07	; 7
    7268:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    726c:	82 ea       	ldi	r24, 0xA2	; 162
    726e:	97 e0       	ldi	r25, 0x07	; 7
    7270:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    7274:	8b ea       	ldi	r24, 0xAB	; 171
    7276:	97 e0       	ldi	r25, 0x07	; 7
    7278:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskDelete */

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        vListInitialise( &xSuspendedTaskList );
    727c:	84 eb       	ldi	r24, 0xB4	; 180
    727e:	97 e0       	ldi	r25, 0x07	; 7
    7280:	0e 94 da 17 	call	0x2fb4	; 0x2fb4 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    7284:	8c e8       	ldi	r24, 0x8C	; 140
    7286:	97 e0       	ldi	r25, 0x07	; 7
    7288:	90 93 9f 07 	sts	0x079F, r25
    728c:	80 93 9e 07 	sts	0x079E, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    7290:	85 e9       	ldi	r24, 0x95	; 149
    7292:	97 e0       	ldi	r25, 0x07	; 7
    7294:	90 93 a1 07 	sts	0x07A1, r25
    7298:	80 93 a0 07 	sts	0x07A0, r24
}
    729c:	0f 90       	pop	r0
    729e:	cf 91       	pop	r28
    72a0:	df 91       	pop	r29
    72a2:	08 95       	ret

000072a4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    72a4:	df 93       	push	r29
    72a6:	cf 93       	push	r28
    72a8:	00 d0       	rcall	.+0      	; 0x72aa <prvCheckTasksWaitingTermination+0x6>
    72aa:	cd b7       	in	r28, 0x3d	; 61
    72ac:	de b7       	in	r29, 0x3e	; 62
    72ae:	20 c0       	rjmp	.+64     	; 0x72f0 <prvCheckTasksWaitingTermination+0x4c>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    72b0:	0f b6       	in	r0, 0x3f	; 63
    72b2:	f8 94       	cli
    72b4:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    72b6:	e0 91 b0 07 	lds	r30, 0x07B0
    72ba:	f0 91 b1 07 	lds	r31, 0x07B1
    72be:	86 81       	ldd	r24, Z+6	; 0x06
    72c0:	97 81       	ldd	r25, Z+7	; 0x07
    72c2:	9a 83       	std	Y+2, r25	; 0x02
    72c4:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    72c6:	89 81       	ldd	r24, Y+1	; 0x01
    72c8:	9a 81       	ldd	r25, Y+2	; 0x02
    72ca:	02 96       	adiw	r24, 0x02	; 2
    72cc:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
                --uxCurrentNumberOfTasks;
    72d0:	80 91 59 07 	lds	r24, 0x0759
    72d4:	81 50       	subi	r24, 0x01	; 1
    72d6:	80 93 59 07 	sts	0x0759, r24
                --uxDeletedTasksWaitingCleanUp;
    72da:	80 91 58 07 	lds	r24, 0x0758
    72de:	81 50       	subi	r24, 0x01	; 1
    72e0:	80 93 58 07 	sts	0x0758, r24
            }
            taskEXIT_CRITICAL();
    72e4:	0f 90       	pop	r0
    72e6:	0f be       	out	0x3f, r0	; 63

            prvDeleteTCB( pxTCB );
    72e8:	89 81       	ldd	r24, Y+1	; 0x01
    72ea:	9a 81       	ldd	r25, Y+2	; 0x02
    72ec:	0e 94 81 39 	call	0x7302	; 0x7302 <prvDeleteTCB>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    72f0:	80 91 58 07 	lds	r24, 0x0758
    72f4:	88 23       	and	r24, r24
    72f6:	e1 f6       	brne	.-72     	; 0x72b0 <prvCheckTasksWaitingTermination+0xc>

            prvDeleteTCB( pxTCB );
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
    72f8:	0f 90       	pop	r0
    72fa:	0f 90       	pop	r0
    72fc:	cf 91       	pop	r28
    72fe:	df 91       	pop	r29
    7300:	08 95       	ret

00007302 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    7302:	df 93       	push	r29
    7304:	cf 93       	push	r28
    7306:	00 d0       	rcall	.+0      	; 0x7308 <prvDeleteTCB+0x6>
    7308:	cd b7       	in	r28, 0x3d	; 61
    730a:	de b7       	in	r29, 0x3e	; 62
    730c:	9a 83       	std	Y+2, r25	; 0x02
    730e:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    7310:	e9 81       	ldd	r30, Y+1	; 0x01
    7312:	fa 81       	ldd	r31, Y+2	; 0x02
    7314:	87 89       	ldd	r24, Z+23	; 0x17
    7316:	90 8d       	ldd	r25, Z+24	; 0x18
    7318:	0e 94 b4 17 	call	0x2f68	; 0x2f68 <vPortFree>
            vPortFree( pxTCB );
    731c:	89 81       	ldd	r24, Y+1	; 0x01
    731e:	9a 81       	ldd	r25, Y+2	; 0x02
    7320:	0e 94 b4 17 	call	0x2f68	; 0x2f68 <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    7324:	0f 90       	pop	r0
    7326:	0f 90       	pop	r0
    7328:	cf 91       	pop	r28
    732a:	df 91       	pop	r29
    732c:	08 95       	ret

0000732e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    732e:	df 93       	push	r29
    7330:	cf 93       	push	r28
    7332:	cd b7       	in	r28, 0x3d	; 61
    7334:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    7336:	e0 91 9e 07 	lds	r30, 0x079E
    733a:	f0 91 9f 07 	lds	r31, 0x079F
    733e:	80 81       	ld	r24, Z
    7340:	88 23       	and	r24, r24
    7342:	39 f4       	brne	.+14     	; 0x7352 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    7344:	8f ef       	ldi	r24, 0xFF	; 255
    7346:	9f ef       	ldi	r25, 0xFF	; 255
    7348:	90 93 64 07 	sts	0x0764, r25
    734c:	80 93 63 07 	sts	0x0763, r24
    7350:	0d c0       	rjmp	.+26     	; 0x736c <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    7352:	e0 91 9e 07 	lds	r30, 0x079E
    7356:	f0 91 9f 07 	lds	r31, 0x079F
    735a:	05 80       	ldd	r0, Z+5	; 0x05
    735c:	f6 81       	ldd	r31, Z+6	; 0x06
    735e:	e0 2d       	mov	r30, r0
    7360:	80 81       	ld	r24, Z
    7362:	91 81       	ldd	r25, Z+1	; 0x01
    7364:	90 93 64 07 	sts	0x0764, r25
    7368:	80 93 63 07 	sts	0x0763, r24
    }
}
    736c:	cf 91       	pop	r28
    736e:	df 91       	pop	r29
    7370:	08 95       	ret

00007372 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    7372:	df 93       	push	r29
    7374:	cf 93       	push	r28
    7376:	00 d0       	rcall	.+0      	; 0x7378 <xTaskGetCurrentTaskHandle+0x6>
    7378:	cd b7       	in	r28, 0x3d	; 61
    737a:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    737c:	80 91 56 07 	lds	r24, 0x0756
    7380:	90 91 57 07 	lds	r25, 0x0757
    7384:	9a 83       	std	Y+2, r25	; 0x02
    7386:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    7388:	89 81       	ldd	r24, Y+1	; 0x01
    738a:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    738c:	0f 90       	pop	r0
    738e:	0f 90       	pop	r0
    7390:	cf 91       	pop	r28
    7392:	df 91       	pop	r29
    7394:	08 95       	ret

00007396 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
    {
    7396:	df 93       	push	r29
    7398:	cf 93       	push	r28
    739a:	cd b7       	in	r28, 0x3d	; 61
    739c:	de b7       	in	r29, 0x3e	; 62
    739e:	27 97       	sbiw	r28, 0x07	; 7
    73a0:	0f b6       	in	r0, 0x3f	; 63
    73a2:	f8 94       	cli
    73a4:	de bf       	out	0x3e, r29	; 62
    73a6:	0f be       	out	0x3f, r0	; 63
    73a8:	cd bf       	out	0x3d, r28	; 61
    73aa:	9f 83       	std	Y+7, r25	; 0x07
    73ac:	8e 83       	std	Y+6, r24	; 0x06
        TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    73ae:	8e 81       	ldd	r24, Y+6	; 0x06
    73b0:	9f 81       	ldd	r25, Y+7	; 0x07
    73b2:	9d 83       	std	Y+5, r25	; 0x05
    73b4:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn = pdFALSE;
    73b6:	1b 82       	std	Y+3, r1	; 0x03

        /* If the mutex was given back by an interrupt while the queue was
         * locked then the mutex holder might now be NULL.  _RB_ Is this still
         * needed as interrupts can no longer use mutexes? */
        if( pxMutexHolder != NULL )
    73b8:	8e 81       	ldd	r24, Y+6	; 0x06
    73ba:	9f 81       	ldd	r25, Y+7	; 0x07
    73bc:	00 97       	sbiw	r24, 0x00	; 0
    73be:	09 f4       	brne	.+2      	; 0x73c2 <xTaskPriorityInherit+0x2c>
    73c0:	c5 c0       	rjmp	.+394    	; 0x754c <xTaskPriorityInherit+0x1b6>
        {
            /* If the holder of the mutex has a priority below the priority of
             * the task attempting to obtain the mutex then it will temporarily
             * inherit the priority of the task attempting to obtain the mutex. */
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    73c2:	ec 81       	ldd	r30, Y+4	; 0x04
    73c4:	fd 81       	ldd	r31, Y+5	; 0x05
    73c6:	96 89       	ldd	r25, Z+22	; 0x16
    73c8:	e0 91 56 07 	lds	r30, 0x0756
    73cc:	f0 91 57 07 	lds	r31, 0x0757
    73d0:	86 89       	ldd	r24, Z+22	; 0x16
    73d2:	98 17       	cp	r25, r24
    73d4:	08 f0       	brcs	.+2      	; 0x73d8 <xTaskPriorityInherit+0x42>
    73d6:	ae c0       	rjmp	.+348    	; 0x7534 <xTaskPriorityInherit+0x19e>
            {
                /* Adjust the mutex holder state to account for its new
                 * priority.  Only reset the event list item value if the value is
                 * not being used for anything else. */
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    73d8:	ec 81       	ldd	r30, Y+4	; 0x04
    73da:	fd 81       	ldd	r31, Y+5	; 0x05
    73dc:	84 85       	ldd	r24, Z+12	; 0x0c
    73de:	95 85       	ldd	r25, Z+13	; 0x0d
    73e0:	99 23       	and	r25, r25
    73e2:	7c f0       	brlt	.+30     	; 0x7402 <xTaskPriorityInherit+0x6c>
                {
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    73e4:	e0 91 56 07 	lds	r30, 0x0756
    73e8:	f0 91 57 07 	lds	r31, 0x0757
    73ec:	86 89       	ldd	r24, Z+22	; 0x16
    73ee:	28 2f       	mov	r18, r24
    73f0:	30 e0       	ldi	r19, 0x00	; 0
    73f2:	84 e0       	ldi	r24, 0x04	; 4
    73f4:	90 e0       	ldi	r25, 0x00	; 0
    73f6:	82 1b       	sub	r24, r18
    73f8:	93 0b       	sbc	r25, r19
    73fa:	ec 81       	ldd	r30, Y+4	; 0x04
    73fc:	fd 81       	ldd	r31, Y+5	; 0x05
    73fe:	95 87       	std	Z+13, r25	; 0x0d
    7400:	84 87       	std	Z+12, r24	; 0x0c
                    mtCOVERAGE_TEST_MARKER();
                }

                /* If the task being modified is in the ready state it will need
                 * to be moved into a new list. */
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    7402:	ec 81       	ldd	r30, Y+4	; 0x04
    7404:	fd 81       	ldd	r31, Y+5	; 0x05
    7406:	42 85       	ldd	r20, Z+10	; 0x0a
    7408:	53 85       	ldd	r21, Z+11	; 0x0b
    740a:	ec 81       	ldd	r30, Y+4	; 0x04
    740c:	fd 81       	ldd	r31, Y+5	; 0x05
    740e:	86 89       	ldd	r24, Z+22	; 0x16
    7410:	28 2f       	mov	r18, r24
    7412:	30 e0       	ldi	r19, 0x00	; 0
    7414:	c9 01       	movw	r24, r18
    7416:	88 0f       	add	r24, r24
    7418:	99 1f       	adc	r25, r25
    741a:	88 0f       	add	r24, r24
    741c:	99 1f       	adc	r25, r25
    741e:	88 0f       	add	r24, r24
    7420:	99 1f       	adc	r25, r25
    7422:	82 0f       	add	r24, r18
    7424:	93 1f       	adc	r25, r19
    7426:	88 59       	subi	r24, 0x98	; 152
    7428:	98 4f       	sbci	r25, 0xF8	; 248
    742a:	48 17       	cp	r20, r24
    742c:	59 07       	cpc	r21, r25
    742e:	09 f0       	breq	.+2      	; 0x7432 <xTaskPriorityInherit+0x9c>
    7430:	76 c0       	rjmp	.+236    	; 0x751e <xTaskPriorityInherit+0x188>
                {
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7432:	8c 81       	ldd	r24, Y+4	; 0x04
    7434:	9d 81       	ldd	r25, Y+5	; 0x05
    7436:	02 96       	adiw	r24, 0x02	; 2
    7438:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Inherit the priority before being moved into the new list. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    743c:	e0 91 56 07 	lds	r30, 0x0756
    7440:	f0 91 57 07 	lds	r31, 0x0757
    7444:	86 89       	ldd	r24, Z+22	; 0x16
    7446:	ec 81       	ldd	r30, Y+4	; 0x04
    7448:	fd 81       	ldd	r31, Y+5	; 0x05
    744a:	86 8b       	std	Z+22, r24	; 0x16
                    prvAddTaskToReadyList( pxMutexHolderTCB );
    744c:	ec 81       	ldd	r30, Y+4	; 0x04
    744e:	fd 81       	ldd	r31, Y+5	; 0x05
    7450:	96 89       	ldd	r25, Z+22	; 0x16
    7452:	80 91 5c 07 	lds	r24, 0x075C
    7456:	89 17       	cp	r24, r25
    7458:	28 f4       	brcc	.+10     	; 0x7464 <xTaskPriorityInherit+0xce>
    745a:	ec 81       	ldd	r30, Y+4	; 0x04
    745c:	fd 81       	ldd	r31, Y+5	; 0x05
    745e:	86 89       	ldd	r24, Z+22	; 0x16
    7460:	80 93 5c 07 	sts	0x075C, r24
    7464:	ec 81       	ldd	r30, Y+4	; 0x04
    7466:	fd 81       	ldd	r31, Y+5	; 0x05
    7468:	86 89       	ldd	r24, Z+22	; 0x16
    746a:	28 2f       	mov	r18, r24
    746c:	30 e0       	ldi	r19, 0x00	; 0
    746e:	c9 01       	movw	r24, r18
    7470:	88 0f       	add	r24, r24
    7472:	99 1f       	adc	r25, r25
    7474:	88 0f       	add	r24, r24
    7476:	99 1f       	adc	r25, r25
    7478:	88 0f       	add	r24, r24
    747a:	99 1f       	adc	r25, r25
    747c:	82 0f       	add	r24, r18
    747e:	93 1f       	adc	r25, r19
    7480:	fc 01       	movw	r30, r24
    7482:	e8 59       	subi	r30, 0x98	; 152
    7484:	f8 4f       	sbci	r31, 0xF8	; 248
    7486:	81 81       	ldd	r24, Z+1	; 0x01
    7488:	92 81       	ldd	r25, Z+2	; 0x02
    748a:	9a 83       	std	Y+2, r25	; 0x02
    748c:	89 83       	std	Y+1, r24	; 0x01
    748e:	ec 81       	ldd	r30, Y+4	; 0x04
    7490:	fd 81       	ldd	r31, Y+5	; 0x05
    7492:	89 81       	ldd	r24, Y+1	; 0x01
    7494:	9a 81       	ldd	r25, Y+2	; 0x02
    7496:	95 83       	std	Z+5, r25	; 0x05
    7498:	84 83       	std	Z+4, r24	; 0x04
    749a:	e9 81       	ldd	r30, Y+1	; 0x01
    749c:	fa 81       	ldd	r31, Y+2	; 0x02
    749e:	84 81       	ldd	r24, Z+4	; 0x04
    74a0:	95 81       	ldd	r25, Z+5	; 0x05
    74a2:	ec 81       	ldd	r30, Y+4	; 0x04
    74a4:	fd 81       	ldd	r31, Y+5	; 0x05
    74a6:	97 83       	std	Z+7, r25	; 0x07
    74a8:	86 83       	std	Z+6, r24	; 0x06
    74aa:	e9 81       	ldd	r30, Y+1	; 0x01
    74ac:	fa 81       	ldd	r31, Y+2	; 0x02
    74ae:	04 80       	ldd	r0, Z+4	; 0x04
    74b0:	f5 81       	ldd	r31, Z+5	; 0x05
    74b2:	e0 2d       	mov	r30, r0
    74b4:	8c 81       	ldd	r24, Y+4	; 0x04
    74b6:	9d 81       	ldd	r25, Y+5	; 0x05
    74b8:	02 96       	adiw	r24, 0x02	; 2
    74ba:	93 83       	std	Z+3, r25	; 0x03
    74bc:	82 83       	std	Z+2, r24	; 0x02
    74be:	8c 81       	ldd	r24, Y+4	; 0x04
    74c0:	9d 81       	ldd	r25, Y+5	; 0x05
    74c2:	02 96       	adiw	r24, 0x02	; 2
    74c4:	e9 81       	ldd	r30, Y+1	; 0x01
    74c6:	fa 81       	ldd	r31, Y+2	; 0x02
    74c8:	95 83       	std	Z+5, r25	; 0x05
    74ca:	84 83       	std	Z+4, r24	; 0x04
    74cc:	ec 81       	ldd	r30, Y+4	; 0x04
    74ce:	fd 81       	ldd	r31, Y+5	; 0x05
    74d0:	86 89       	ldd	r24, Z+22	; 0x16
    74d2:	28 2f       	mov	r18, r24
    74d4:	30 e0       	ldi	r19, 0x00	; 0
    74d6:	c9 01       	movw	r24, r18
    74d8:	88 0f       	add	r24, r24
    74da:	99 1f       	adc	r25, r25
    74dc:	88 0f       	add	r24, r24
    74de:	99 1f       	adc	r25, r25
    74e0:	88 0f       	add	r24, r24
    74e2:	99 1f       	adc	r25, r25
    74e4:	82 0f       	add	r24, r18
    74e6:	93 1f       	adc	r25, r19
    74e8:	88 59       	subi	r24, 0x98	; 152
    74ea:	98 4f       	sbci	r25, 0xF8	; 248
    74ec:	ec 81       	ldd	r30, Y+4	; 0x04
    74ee:	fd 81       	ldd	r31, Y+5	; 0x05
    74f0:	93 87       	std	Z+11, r25	; 0x0b
    74f2:	82 87       	std	Z+10, r24	; 0x0a
    74f4:	ec 81       	ldd	r30, Y+4	; 0x04
    74f6:	fd 81       	ldd	r31, Y+5	; 0x05
    74f8:	86 89       	ldd	r24, Z+22	; 0x16
    74fa:	28 2f       	mov	r18, r24
    74fc:	30 e0       	ldi	r19, 0x00	; 0
    74fe:	c9 01       	movw	r24, r18
    7500:	88 0f       	add	r24, r24
    7502:	99 1f       	adc	r25, r25
    7504:	88 0f       	add	r24, r24
    7506:	99 1f       	adc	r25, r25
    7508:	88 0f       	add	r24, r24
    750a:	99 1f       	adc	r25, r25
    750c:	82 0f       	add	r24, r18
    750e:	93 1f       	adc	r25, r19
    7510:	fc 01       	movw	r30, r24
    7512:	e8 59       	subi	r30, 0x98	; 152
    7514:	f8 4f       	sbci	r31, 0xF8	; 248
    7516:	80 81       	ld	r24, Z
    7518:	8f 5f       	subi	r24, 0xFF	; 255
    751a:	80 83       	st	Z, r24
    751c:	08 c0       	rjmp	.+16     	; 0x752e <xTaskPriorityInherit+0x198>
                }
                else
                {
                    /* Just inherit the priority. */
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    751e:	e0 91 56 07 	lds	r30, 0x0756
    7522:	f0 91 57 07 	lds	r31, 0x0757
    7526:	86 89       	ldd	r24, Z+22	; 0x16
    7528:	ec 81       	ldd	r30, Y+4	; 0x04
    752a:	fd 81       	ldd	r31, Y+5	; 0x05
    752c:	86 8b       	std	Z+22, r24	; 0x16
                }

                traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

                /* Inheritance occurred. */
                xReturn = pdTRUE;
    752e:	81 e0       	ldi	r24, 0x01	; 1
    7530:	8b 83       	std	Y+3, r24	; 0x03
    7532:	0c c0       	rjmp	.+24     	; 0x754c <xTaskPriorityInherit+0x1b6>
            }
            else
            {
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    7534:	ec 81       	ldd	r30, Y+4	; 0x04
    7536:	fd 81       	ldd	r31, Y+5	; 0x05
    7538:	91 a1       	ldd	r25, Z+33	; 0x21
    753a:	e0 91 56 07 	lds	r30, 0x0756
    753e:	f0 91 57 07 	lds	r31, 0x0757
    7542:	86 89       	ldd	r24, Z+22	; 0x16
    7544:	98 17       	cp	r25, r24
    7546:	10 f4       	brcc	.+4      	; 0x754c <xTaskPriorityInherit+0x1b6>
                     * current priority of the mutex holder is not lower than the
                     * priority of the task attempting to take the mutex.
                     * Therefore the mutex holder must have already inherited a
                     * priority, but inheritance would have occurred if that had
                     * not been the case. */
                    xReturn = pdTRUE;
    7548:	81 e0       	ldi	r24, 0x01	; 1
    754a:	8b 83       	std	Y+3, r24	; 0x03
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    754c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    754e:	27 96       	adiw	r28, 0x07	; 7
    7550:	0f b6       	in	r0, 0x3f	; 63
    7552:	f8 94       	cli
    7554:	de bf       	out	0x3e, r29	; 62
    7556:	0f be       	out	0x3f, r0	; 63
    7558:	cd bf       	out	0x3d, r28	; 61
    755a:	cf 91       	pop	r28
    755c:	df 91       	pop	r29
    755e:	08 95       	ret

00007560 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    7560:	df 93       	push	r29
    7562:	cf 93       	push	r28
    7564:	cd b7       	in	r28, 0x3d	; 61
    7566:	de b7       	in	r29, 0x3e	; 62
    7568:	27 97       	sbiw	r28, 0x07	; 7
    756a:	0f b6       	in	r0, 0x3f	; 63
    756c:	f8 94       	cli
    756e:	de bf       	out	0x3e, r29	; 62
    7570:	0f be       	out	0x3f, r0	; 63
    7572:	cd bf       	out	0x3d, r28	; 61
    7574:	9f 83       	std	Y+7, r25	; 0x07
    7576:	8e 83       	std	Y+6, r24	; 0x06
        TCB_t * const pxTCB = pxMutexHolder;
    7578:	8e 81       	ldd	r24, Y+6	; 0x06
    757a:	9f 81       	ldd	r25, Y+7	; 0x07
    757c:	9d 83       	std	Y+5, r25	; 0x05
    757e:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn = pdFALSE;
    7580:	1b 82       	std	Y+3, r1	; 0x03

        if( pxMutexHolder != NULL )
    7582:	8e 81       	ldd	r24, Y+6	; 0x06
    7584:	9f 81       	ldd	r25, Y+7	; 0x07
    7586:	00 97       	sbiw	r24, 0x00	; 0
    7588:	09 f4       	brne	.+2      	; 0x758c <xTaskPriorityDisinherit+0x2c>
    758a:	98 c0       	rjmp	.+304    	; 0x76bc <xTaskPriorityDisinherit+0x15c>
             * If the mutex is held by a task then it cannot be given from an
             * interrupt, and if a mutex is given by the holding task then it must
             * be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    758c:	ec 81       	ldd	r30, Y+4	; 0x04
    758e:	fd 81       	ldd	r31, Y+5	; 0x05
    7590:	82 a1       	ldd	r24, Z+34	; 0x22
    7592:	81 50       	subi	r24, 0x01	; 1
    7594:	ec 81       	ldd	r30, Y+4	; 0x04
    7596:	fd 81       	ldd	r31, Y+5	; 0x05
    7598:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
             * task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    759a:	ec 81       	ldd	r30, Y+4	; 0x04
    759c:	fd 81       	ldd	r31, Y+5	; 0x05
    759e:	96 89       	ldd	r25, Z+22	; 0x16
    75a0:	ec 81       	ldd	r30, Y+4	; 0x04
    75a2:	fd 81       	ldd	r31, Y+5	; 0x05
    75a4:	81 a1       	ldd	r24, Z+33	; 0x21
    75a6:	98 17       	cp	r25, r24
    75a8:	09 f4       	brne	.+2      	; 0x75ac <xTaskPriorityDisinherit+0x4c>
    75aa:	88 c0       	rjmp	.+272    	; 0x76bc <xTaskPriorityDisinherit+0x15c>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    75ac:	ec 81       	ldd	r30, Y+4	; 0x04
    75ae:	fd 81       	ldd	r31, Y+5	; 0x05
    75b0:	82 a1       	ldd	r24, Z+34	; 0x22
    75b2:	88 23       	and	r24, r24
    75b4:	09 f0       	breq	.+2      	; 0x75b8 <xTaskPriorityDisinherit+0x58>
    75b6:	82 c0       	rjmp	.+260    	; 0x76bc <xTaskPriorityDisinherit+0x15c>
                    /* A task can only have an inherited priority if it holds
                     * the mutex.  If the mutex is held by a task then it cannot be
                     * given from an interrupt, and if a mutex is given by the
                     * holding task then it must be the running state task.  Remove
                     * the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    75b8:	8c 81       	ldd	r24, Y+4	; 0x04
    75ba:	9d 81       	ldd	r25, Y+5	; 0x05
    75bc:	02 96       	adiw	r24, 0x02	; 2
    75be:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                     * new  ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    75c2:	ec 81       	ldd	r30, Y+4	; 0x04
    75c4:	fd 81       	ldd	r31, Y+5	; 0x05
    75c6:	81 a1       	ldd	r24, Z+33	; 0x21
    75c8:	ec 81       	ldd	r30, Y+4	; 0x04
    75ca:	fd 81       	ldd	r31, Y+5	; 0x05
    75cc:	86 8b       	std	Z+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                     * any other purpose if this task is running, and it must be
                     * running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    75ce:	ec 81       	ldd	r30, Y+4	; 0x04
    75d0:	fd 81       	ldd	r31, Y+5	; 0x05
    75d2:	86 89       	ldd	r24, Z+22	; 0x16
    75d4:	28 2f       	mov	r18, r24
    75d6:	30 e0       	ldi	r19, 0x00	; 0
    75d8:	84 e0       	ldi	r24, 0x04	; 4
    75da:	90 e0       	ldi	r25, 0x00	; 0
    75dc:	82 1b       	sub	r24, r18
    75de:	93 0b       	sbc	r25, r19
    75e0:	ec 81       	ldd	r30, Y+4	; 0x04
    75e2:	fd 81       	ldd	r31, Y+5	; 0x05
    75e4:	95 87       	std	Z+13, r25	; 0x0d
    75e6:	84 87       	std	Z+12, r24	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    75e8:	ec 81       	ldd	r30, Y+4	; 0x04
    75ea:	fd 81       	ldd	r31, Y+5	; 0x05
    75ec:	96 89       	ldd	r25, Z+22	; 0x16
    75ee:	80 91 5c 07 	lds	r24, 0x075C
    75f2:	89 17       	cp	r24, r25
    75f4:	28 f4       	brcc	.+10     	; 0x7600 <xTaskPriorityDisinherit+0xa0>
    75f6:	ec 81       	ldd	r30, Y+4	; 0x04
    75f8:	fd 81       	ldd	r31, Y+5	; 0x05
    75fa:	86 89       	ldd	r24, Z+22	; 0x16
    75fc:	80 93 5c 07 	sts	0x075C, r24
    7600:	ec 81       	ldd	r30, Y+4	; 0x04
    7602:	fd 81       	ldd	r31, Y+5	; 0x05
    7604:	86 89       	ldd	r24, Z+22	; 0x16
    7606:	28 2f       	mov	r18, r24
    7608:	30 e0       	ldi	r19, 0x00	; 0
    760a:	c9 01       	movw	r24, r18
    760c:	88 0f       	add	r24, r24
    760e:	99 1f       	adc	r25, r25
    7610:	88 0f       	add	r24, r24
    7612:	99 1f       	adc	r25, r25
    7614:	88 0f       	add	r24, r24
    7616:	99 1f       	adc	r25, r25
    7618:	82 0f       	add	r24, r18
    761a:	93 1f       	adc	r25, r19
    761c:	fc 01       	movw	r30, r24
    761e:	e8 59       	subi	r30, 0x98	; 152
    7620:	f8 4f       	sbci	r31, 0xF8	; 248
    7622:	81 81       	ldd	r24, Z+1	; 0x01
    7624:	92 81       	ldd	r25, Z+2	; 0x02
    7626:	9a 83       	std	Y+2, r25	; 0x02
    7628:	89 83       	std	Y+1, r24	; 0x01
    762a:	ec 81       	ldd	r30, Y+4	; 0x04
    762c:	fd 81       	ldd	r31, Y+5	; 0x05
    762e:	89 81       	ldd	r24, Y+1	; 0x01
    7630:	9a 81       	ldd	r25, Y+2	; 0x02
    7632:	95 83       	std	Z+5, r25	; 0x05
    7634:	84 83       	std	Z+4, r24	; 0x04
    7636:	e9 81       	ldd	r30, Y+1	; 0x01
    7638:	fa 81       	ldd	r31, Y+2	; 0x02
    763a:	84 81       	ldd	r24, Z+4	; 0x04
    763c:	95 81       	ldd	r25, Z+5	; 0x05
    763e:	ec 81       	ldd	r30, Y+4	; 0x04
    7640:	fd 81       	ldd	r31, Y+5	; 0x05
    7642:	97 83       	std	Z+7, r25	; 0x07
    7644:	86 83       	std	Z+6, r24	; 0x06
    7646:	e9 81       	ldd	r30, Y+1	; 0x01
    7648:	fa 81       	ldd	r31, Y+2	; 0x02
    764a:	04 80       	ldd	r0, Z+4	; 0x04
    764c:	f5 81       	ldd	r31, Z+5	; 0x05
    764e:	e0 2d       	mov	r30, r0
    7650:	8c 81       	ldd	r24, Y+4	; 0x04
    7652:	9d 81       	ldd	r25, Y+5	; 0x05
    7654:	02 96       	adiw	r24, 0x02	; 2
    7656:	93 83       	std	Z+3, r25	; 0x03
    7658:	82 83       	std	Z+2, r24	; 0x02
    765a:	8c 81       	ldd	r24, Y+4	; 0x04
    765c:	9d 81       	ldd	r25, Y+5	; 0x05
    765e:	02 96       	adiw	r24, 0x02	; 2
    7660:	e9 81       	ldd	r30, Y+1	; 0x01
    7662:	fa 81       	ldd	r31, Y+2	; 0x02
    7664:	95 83       	std	Z+5, r25	; 0x05
    7666:	84 83       	std	Z+4, r24	; 0x04
    7668:	ec 81       	ldd	r30, Y+4	; 0x04
    766a:	fd 81       	ldd	r31, Y+5	; 0x05
    766c:	86 89       	ldd	r24, Z+22	; 0x16
    766e:	28 2f       	mov	r18, r24
    7670:	30 e0       	ldi	r19, 0x00	; 0
    7672:	c9 01       	movw	r24, r18
    7674:	88 0f       	add	r24, r24
    7676:	99 1f       	adc	r25, r25
    7678:	88 0f       	add	r24, r24
    767a:	99 1f       	adc	r25, r25
    767c:	88 0f       	add	r24, r24
    767e:	99 1f       	adc	r25, r25
    7680:	82 0f       	add	r24, r18
    7682:	93 1f       	adc	r25, r19
    7684:	88 59       	subi	r24, 0x98	; 152
    7686:	98 4f       	sbci	r25, 0xF8	; 248
    7688:	ec 81       	ldd	r30, Y+4	; 0x04
    768a:	fd 81       	ldd	r31, Y+5	; 0x05
    768c:	93 87       	std	Z+11, r25	; 0x0b
    768e:	82 87       	std	Z+10, r24	; 0x0a
    7690:	ec 81       	ldd	r30, Y+4	; 0x04
    7692:	fd 81       	ldd	r31, Y+5	; 0x05
    7694:	86 89       	ldd	r24, Z+22	; 0x16
    7696:	28 2f       	mov	r18, r24
    7698:	30 e0       	ldi	r19, 0x00	; 0
    769a:	c9 01       	movw	r24, r18
    769c:	88 0f       	add	r24, r24
    769e:	99 1f       	adc	r25, r25
    76a0:	88 0f       	add	r24, r24
    76a2:	99 1f       	adc	r25, r25
    76a4:	88 0f       	add	r24, r24
    76a6:	99 1f       	adc	r25, r25
    76a8:	82 0f       	add	r24, r18
    76aa:	93 1f       	adc	r25, r19
    76ac:	fc 01       	movw	r30, r24
    76ae:	e8 59       	subi	r30, 0x98	; 152
    76b0:	f8 4f       	sbci	r31, 0xF8	; 248
    76b2:	80 81       	ld	r24, Z
    76b4:	8f 5f       	subi	r24, 0xFF	; 255
    76b6:	80 83       	st	Z, r24
                     * in an order different to that in which they were taken.
                     * If a context switch did not occur when the first mutex was
                     * returned, even if a task was waiting on it, then a context
                     * switch should occur when the last mutex is returned whether
                     * a task is waiting on it or not. */
                    xReturn = pdTRUE;
    76b8:	81 e0       	ldi	r24, 0x01	; 1
    76ba:	8b 83       	std	Y+3, r24	; 0x03
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    76bc:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    76be:	27 96       	adiw	r28, 0x07	; 7
    76c0:	0f b6       	in	r0, 0x3f	; 63
    76c2:	f8 94       	cli
    76c4:	de bf       	out	0x3e, r29	; 62
    76c6:	0f be       	out	0x3f, r0	; 63
    76c8:	cd bf       	out	0x3d, r28	; 61
    76ca:	cf 91       	pop	r28
    76cc:	df 91       	pop	r29
    76ce:	08 95       	ret

000076d0 <vTaskPriorityDisinheritAfterTimeout>:

#if ( configUSE_MUTEXES == 1 )

    void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
                                              UBaseType_t uxHighestPriorityWaitingTask )
    {
    76d0:	df 93       	push	r29
    76d2:	cf 93       	push	r28
    76d4:	cd b7       	in	r28, 0x3d	; 61
    76d6:	de b7       	in	r29, 0x3e	; 62
    76d8:	2a 97       	sbiw	r28, 0x0a	; 10
    76da:	0f b6       	in	r0, 0x3f	; 63
    76dc:	f8 94       	cli
    76de:	de bf       	out	0x3e, r29	; 62
    76e0:	0f be       	out	0x3f, r0	; 63
    76e2:	cd bf       	out	0x3d, r28	; 61
    76e4:	99 87       	std	Y+9, r25	; 0x09
    76e6:	88 87       	std	Y+8, r24	; 0x08
    76e8:	6a 87       	std	Y+10, r22	; 0x0a
        TCB_t * const pxTCB = pxMutexHolder;
    76ea:	88 85       	ldd	r24, Y+8	; 0x08
    76ec:	99 85       	ldd	r25, Y+9	; 0x09
    76ee:	9f 83       	std	Y+7, r25	; 0x07
    76f0:	8e 83       	std	Y+6, r24	; 0x06
        UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
        const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    76f2:	81 e0       	ldi	r24, 0x01	; 1
    76f4:	8b 83       	std	Y+3, r24	; 0x03

        if( pxMutexHolder != NULL )
    76f6:	88 85       	ldd	r24, Y+8	; 0x08
    76f8:	99 85       	ldd	r25, Y+9	; 0x09
    76fa:	00 97       	sbiw	r24, 0x00	; 0
    76fc:	09 f4       	brne	.+2      	; 0x7700 <vTaskPriorityDisinheritAfterTimeout+0x30>
    76fe:	b7 c0       	rjmp	.+366    	; 0x786e <vTaskPriorityDisinheritAfterTimeout+0x19e>

            /* Determine the priority to which the priority of the task that
             * holds the mutex should be set.  This will be the greater of the
             * holding task's base priority and the priority of the highest
             * priority task that is waiting to obtain the mutex. */
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    7700:	ee 81       	ldd	r30, Y+6	; 0x06
    7702:	ff 81       	ldd	r31, Y+7	; 0x07
    7704:	91 a1       	ldd	r25, Z+33	; 0x21
    7706:	8a 85       	ldd	r24, Y+10	; 0x0a
    7708:	98 17       	cp	r25, r24
    770a:	18 f4       	brcc	.+6      	; 0x7712 <vTaskPriorityDisinheritAfterTimeout+0x42>
            {
                uxPriorityToUse = uxHighestPriorityWaitingTask;
    770c:	8a 85       	ldd	r24, Y+10	; 0x0a
    770e:	8c 83       	std	Y+4, r24	; 0x04
    7710:	04 c0       	rjmp	.+8      	; 0x771a <vTaskPriorityDisinheritAfterTimeout+0x4a>
            }
            else
            {
                uxPriorityToUse = pxTCB->uxBasePriority;
    7712:	ee 81       	ldd	r30, Y+6	; 0x06
    7714:	ff 81       	ldd	r31, Y+7	; 0x07
    7716:	81 a1       	ldd	r24, Z+33	; 0x21
    7718:	8c 83       	std	Y+4, r24	; 0x04
            }

            /* Does the priority need to change? */
            if( pxTCB->uxPriority != uxPriorityToUse )
    771a:	ee 81       	ldd	r30, Y+6	; 0x06
    771c:	ff 81       	ldd	r31, Y+7	; 0x07
    771e:	96 89       	ldd	r25, Z+22	; 0x16
    7720:	8c 81       	ldd	r24, Y+4	; 0x04
    7722:	98 17       	cp	r25, r24
    7724:	09 f4       	brne	.+2      	; 0x7728 <vTaskPriorityDisinheritAfterTimeout+0x58>
    7726:	a3 c0       	rjmp	.+326    	; 0x786e <vTaskPriorityDisinheritAfterTimeout+0x19e>
            {
                /* Only disinherit if no other mutexes are held.  This is a
                 * simplification in the priority inheritance implementation.  If
                 * the task that holds the mutex is also holding other mutexes then
                 * the other mutexes may have caused the priority inheritance. */
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    7728:	ee 81       	ldd	r30, Y+6	; 0x06
    772a:	ff 81       	ldd	r31, Y+7	; 0x07
    772c:	92 a1       	ldd	r25, Z+34	; 0x22
    772e:	8b 81       	ldd	r24, Y+3	; 0x03
    7730:	98 17       	cp	r25, r24
    7732:	09 f0       	breq	.+2      	; 0x7736 <vTaskPriorityDisinheritAfterTimeout+0x66>
    7734:	9c c0       	rjmp	.+312    	; 0x786e <vTaskPriorityDisinheritAfterTimeout+0x19e>

                    /* Disinherit the priority, remembering the previous
                     * priority to facilitate determining the subject task's
                     * state. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
    7736:	ee 81       	ldd	r30, Y+6	; 0x06
    7738:	ff 81       	ldd	r31, Y+7	; 0x07
    773a:	86 89       	ldd	r24, Z+22	; 0x16
    773c:	8d 83       	std	Y+5, r24	; 0x05
                    pxTCB->uxPriority = uxPriorityToUse;
    773e:	ee 81       	ldd	r30, Y+6	; 0x06
    7740:	ff 81       	ldd	r31, Y+7	; 0x07
    7742:	8c 81       	ldd	r24, Y+4	; 0x04
    7744:	86 8b       	std	Z+22, r24	; 0x16

                    /* Only reset the event list item value if the value is not
                     * being used for anything else. */
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    7746:	ee 81       	ldd	r30, Y+6	; 0x06
    7748:	ff 81       	ldd	r31, Y+7	; 0x07
    774a:	84 85       	ldd	r24, Z+12	; 0x0c
    774c:	95 85       	ldd	r25, Z+13	; 0x0d
    774e:	99 23       	and	r25, r25
    7750:	5c f0       	brlt	.+22     	; 0x7768 <vTaskPriorityDisinheritAfterTimeout+0x98>
                    {
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    7752:	8c 81       	ldd	r24, Y+4	; 0x04
    7754:	28 2f       	mov	r18, r24
    7756:	30 e0       	ldi	r19, 0x00	; 0
    7758:	84 e0       	ldi	r24, 0x04	; 4
    775a:	90 e0       	ldi	r25, 0x00	; 0
    775c:	82 1b       	sub	r24, r18
    775e:	93 0b       	sbc	r25, r19
    7760:	ee 81       	ldd	r30, Y+6	; 0x06
    7762:	ff 81       	ldd	r31, Y+7	; 0x07
    7764:	95 87       	std	Z+13, r25	; 0x0d
    7766:	84 87       	std	Z+12, r24	; 0x0c
                     * then the task that holds the mutex could be in either the
                     * Ready, Blocked or Suspended states.  Only remove the task
                     * from its current state list if it is in the Ready state as
                     * the task's priority is going to change and there is one
                     * Ready list per priority. */
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    7768:	ee 81       	ldd	r30, Y+6	; 0x06
    776a:	ff 81       	ldd	r31, Y+7	; 0x07
    776c:	42 85       	ldd	r20, Z+10	; 0x0a
    776e:	53 85       	ldd	r21, Z+11	; 0x0b
    7770:	8d 81       	ldd	r24, Y+5	; 0x05
    7772:	28 2f       	mov	r18, r24
    7774:	30 e0       	ldi	r19, 0x00	; 0
    7776:	c9 01       	movw	r24, r18
    7778:	88 0f       	add	r24, r24
    777a:	99 1f       	adc	r25, r25
    777c:	88 0f       	add	r24, r24
    777e:	99 1f       	adc	r25, r25
    7780:	88 0f       	add	r24, r24
    7782:	99 1f       	adc	r25, r25
    7784:	82 0f       	add	r24, r18
    7786:	93 1f       	adc	r25, r19
    7788:	88 59       	subi	r24, 0x98	; 152
    778a:	98 4f       	sbci	r25, 0xF8	; 248
    778c:	48 17       	cp	r20, r24
    778e:	59 07       	cpc	r21, r25
    7790:	09 f0       	breq	.+2      	; 0x7794 <vTaskPriorityDisinheritAfterTimeout+0xc4>
    7792:	6d c0       	rjmp	.+218    	; 0x786e <vTaskPriorityDisinheritAfterTimeout+0x19e>
                    {
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7794:	8e 81       	ldd	r24, Y+6	; 0x06
    7796:	9f 81       	ldd	r25, Y+7	; 0x07
    7798:	02 96       	adiw	r24, 0x02	; 2
    779a:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }

                        prvAddTaskToReadyList( pxTCB );
    779e:	ee 81       	ldd	r30, Y+6	; 0x06
    77a0:	ff 81       	ldd	r31, Y+7	; 0x07
    77a2:	96 89       	ldd	r25, Z+22	; 0x16
    77a4:	80 91 5c 07 	lds	r24, 0x075C
    77a8:	89 17       	cp	r24, r25
    77aa:	28 f4       	brcc	.+10     	; 0x77b6 <vTaskPriorityDisinheritAfterTimeout+0xe6>
    77ac:	ee 81       	ldd	r30, Y+6	; 0x06
    77ae:	ff 81       	ldd	r31, Y+7	; 0x07
    77b0:	86 89       	ldd	r24, Z+22	; 0x16
    77b2:	80 93 5c 07 	sts	0x075C, r24
    77b6:	ee 81       	ldd	r30, Y+6	; 0x06
    77b8:	ff 81       	ldd	r31, Y+7	; 0x07
    77ba:	86 89       	ldd	r24, Z+22	; 0x16
    77bc:	28 2f       	mov	r18, r24
    77be:	30 e0       	ldi	r19, 0x00	; 0
    77c0:	c9 01       	movw	r24, r18
    77c2:	88 0f       	add	r24, r24
    77c4:	99 1f       	adc	r25, r25
    77c6:	88 0f       	add	r24, r24
    77c8:	99 1f       	adc	r25, r25
    77ca:	88 0f       	add	r24, r24
    77cc:	99 1f       	adc	r25, r25
    77ce:	82 0f       	add	r24, r18
    77d0:	93 1f       	adc	r25, r19
    77d2:	fc 01       	movw	r30, r24
    77d4:	e8 59       	subi	r30, 0x98	; 152
    77d6:	f8 4f       	sbci	r31, 0xF8	; 248
    77d8:	81 81       	ldd	r24, Z+1	; 0x01
    77da:	92 81       	ldd	r25, Z+2	; 0x02
    77dc:	9a 83       	std	Y+2, r25	; 0x02
    77de:	89 83       	std	Y+1, r24	; 0x01
    77e0:	ee 81       	ldd	r30, Y+6	; 0x06
    77e2:	ff 81       	ldd	r31, Y+7	; 0x07
    77e4:	89 81       	ldd	r24, Y+1	; 0x01
    77e6:	9a 81       	ldd	r25, Y+2	; 0x02
    77e8:	95 83       	std	Z+5, r25	; 0x05
    77ea:	84 83       	std	Z+4, r24	; 0x04
    77ec:	e9 81       	ldd	r30, Y+1	; 0x01
    77ee:	fa 81       	ldd	r31, Y+2	; 0x02
    77f0:	84 81       	ldd	r24, Z+4	; 0x04
    77f2:	95 81       	ldd	r25, Z+5	; 0x05
    77f4:	ee 81       	ldd	r30, Y+6	; 0x06
    77f6:	ff 81       	ldd	r31, Y+7	; 0x07
    77f8:	97 83       	std	Z+7, r25	; 0x07
    77fa:	86 83       	std	Z+6, r24	; 0x06
    77fc:	e9 81       	ldd	r30, Y+1	; 0x01
    77fe:	fa 81       	ldd	r31, Y+2	; 0x02
    7800:	04 80       	ldd	r0, Z+4	; 0x04
    7802:	f5 81       	ldd	r31, Z+5	; 0x05
    7804:	e0 2d       	mov	r30, r0
    7806:	8e 81       	ldd	r24, Y+6	; 0x06
    7808:	9f 81       	ldd	r25, Y+7	; 0x07
    780a:	02 96       	adiw	r24, 0x02	; 2
    780c:	93 83       	std	Z+3, r25	; 0x03
    780e:	82 83       	std	Z+2, r24	; 0x02
    7810:	8e 81       	ldd	r24, Y+6	; 0x06
    7812:	9f 81       	ldd	r25, Y+7	; 0x07
    7814:	02 96       	adiw	r24, 0x02	; 2
    7816:	e9 81       	ldd	r30, Y+1	; 0x01
    7818:	fa 81       	ldd	r31, Y+2	; 0x02
    781a:	95 83       	std	Z+5, r25	; 0x05
    781c:	84 83       	std	Z+4, r24	; 0x04
    781e:	ee 81       	ldd	r30, Y+6	; 0x06
    7820:	ff 81       	ldd	r31, Y+7	; 0x07
    7822:	86 89       	ldd	r24, Z+22	; 0x16
    7824:	28 2f       	mov	r18, r24
    7826:	30 e0       	ldi	r19, 0x00	; 0
    7828:	c9 01       	movw	r24, r18
    782a:	88 0f       	add	r24, r24
    782c:	99 1f       	adc	r25, r25
    782e:	88 0f       	add	r24, r24
    7830:	99 1f       	adc	r25, r25
    7832:	88 0f       	add	r24, r24
    7834:	99 1f       	adc	r25, r25
    7836:	82 0f       	add	r24, r18
    7838:	93 1f       	adc	r25, r19
    783a:	88 59       	subi	r24, 0x98	; 152
    783c:	98 4f       	sbci	r25, 0xF8	; 248
    783e:	ee 81       	ldd	r30, Y+6	; 0x06
    7840:	ff 81       	ldd	r31, Y+7	; 0x07
    7842:	93 87       	std	Z+11, r25	; 0x0b
    7844:	82 87       	std	Z+10, r24	; 0x0a
    7846:	ee 81       	ldd	r30, Y+6	; 0x06
    7848:	ff 81       	ldd	r31, Y+7	; 0x07
    784a:	86 89       	ldd	r24, Z+22	; 0x16
    784c:	28 2f       	mov	r18, r24
    784e:	30 e0       	ldi	r19, 0x00	; 0
    7850:	c9 01       	movw	r24, r18
    7852:	88 0f       	add	r24, r24
    7854:	99 1f       	adc	r25, r25
    7856:	88 0f       	add	r24, r24
    7858:	99 1f       	adc	r25, r25
    785a:	88 0f       	add	r24, r24
    785c:	99 1f       	adc	r25, r25
    785e:	82 0f       	add	r24, r18
    7860:	93 1f       	adc	r25, r19
    7862:	fc 01       	movw	r30, r24
    7864:	e8 59       	subi	r30, 0x98	; 152
    7866:	f8 4f       	sbci	r31, 0xF8	; 248
    7868:	80 81       	ld	r24, Z
    786a:	8f 5f       	subi	r24, 0xFF	; 255
    786c:	80 83       	st	Z, r24
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    786e:	2a 96       	adiw	r28, 0x0a	; 10
    7870:	0f b6       	in	r0, 0x3f	; 63
    7872:	f8 94       	cli
    7874:	de bf       	out	0x3e, r29	; 62
    7876:	0f be       	out	0x3f, r0	; 63
    7878:	cd bf       	out	0x3d, r28	; 61
    787a:	cf 91       	pop	r28
    787c:	df 91       	pop	r29
    787e:	08 95       	ret

00007880 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    7880:	df 93       	push	r29
    7882:	cf 93       	push	r28
    7884:	00 d0       	rcall	.+0      	; 0x7886 <uxTaskResetEventItemValue+0x6>
    7886:	cd b7       	in	r28, 0x3d	; 61
    7888:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    788a:	e0 91 56 07 	lds	r30, 0x0756
    788e:	f0 91 57 07 	lds	r31, 0x0757
    7892:	84 85       	ldd	r24, Z+12	; 0x0c
    7894:	95 85       	ldd	r25, Z+13	; 0x0d
    7896:	9a 83       	std	Y+2, r25	; 0x02
    7898:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    789a:	a0 91 56 07 	lds	r26, 0x0756
    789e:	b0 91 57 07 	lds	r27, 0x0757
    78a2:	e0 91 56 07 	lds	r30, 0x0756
    78a6:	f0 91 57 07 	lds	r31, 0x0757
    78aa:	86 89       	ldd	r24, Z+22	; 0x16
    78ac:	28 2f       	mov	r18, r24
    78ae:	30 e0       	ldi	r19, 0x00	; 0
    78b0:	84 e0       	ldi	r24, 0x04	; 4
    78b2:	90 e0       	ldi	r25, 0x00	; 0
    78b4:	82 1b       	sub	r24, r18
    78b6:	93 0b       	sbc	r25, r19
    78b8:	1d 96       	adiw	r26, 0x0d	; 13
    78ba:	9c 93       	st	X, r25
    78bc:	8e 93       	st	-X, r24
    78be:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    78c0:	89 81       	ldd	r24, Y+1	; 0x01
    78c2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    78c4:	0f 90       	pop	r0
    78c6:	0f 90       	pop	r0
    78c8:	cf 91       	pop	r28
    78ca:	df 91       	pop	r29
    78cc:	08 95       	ret

000078ce <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
    78ce:	df 93       	push	r29
    78d0:	cf 93       	push	r28
    78d2:	cd b7       	in	r28, 0x3d	; 61
    78d4:	de b7       	in	r29, 0x3e	; 62
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
         * then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    78d6:	80 91 56 07 	lds	r24, 0x0756
    78da:	90 91 57 07 	lds	r25, 0x0757
    78de:	00 97       	sbiw	r24, 0x00	; 0
    78e0:	39 f0       	breq	.+14     	; 0x78f0 <pvTaskIncrementMutexHeldCount+0x22>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    78e2:	e0 91 56 07 	lds	r30, 0x0756
    78e6:	f0 91 57 07 	lds	r31, 0x0757
    78ea:	82 a1       	ldd	r24, Z+34	; 0x22
    78ec:	8f 5f       	subi	r24, 0xFF	; 255
    78ee:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    78f0:	80 91 56 07 	lds	r24, 0x0756
    78f4:	90 91 57 07 	lds	r25, 0x0757
    }
    78f8:	cf 91       	pop	r28
    78fa:	df 91       	pop	r29
    78fc:	08 95       	ret

000078fe <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    78fe:	df 93       	push	r29
    7900:	cf 93       	push	r28
    7902:	cd b7       	in	r28, 0x3d	; 61
    7904:	de b7       	in	r29, 0x3e	; 62
    7906:	28 97       	sbiw	r28, 0x08	; 8
    7908:	0f b6       	in	r0, 0x3f	; 63
    790a:	f8 94       	cli
    790c:	de bf       	out	0x3e, r29	; 62
    790e:	0f be       	out	0x3f, r0	; 63
    7910:	cd bf       	out	0x3d, r28	; 61
    7912:	8d 83       	std	Y+5, r24	; 0x05
    7914:	6e 83       	std	Y+6, r22	; 0x06
    7916:	58 87       	std	Y+8, r21	; 0x08
    7918:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    791a:	0f b6       	in	r0, 0x3f	; 63
    791c:	f8 94       	cli
    791e:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    7920:	20 91 56 07 	lds	r18, 0x0756
    7924:	30 91 57 07 	lds	r19, 0x0757
    7928:	8d 81       	ldd	r24, Y+5	; 0x05
    792a:	88 2f       	mov	r24, r24
    792c:	90 e0       	ldi	r25, 0x00	; 0
    792e:	88 0f       	add	r24, r24
    7930:	99 1f       	adc	r25, r25
    7932:	88 0f       	add	r24, r24
    7934:	99 1f       	adc	r25, r25
    7936:	82 0f       	add	r24, r18
    7938:	93 1f       	adc	r25, r19
    793a:	fc 01       	movw	r30, r24
    793c:	b3 96       	adiw	r30, 0x23	; 35
    793e:	80 81       	ld	r24, Z
    7940:	91 81       	ldd	r25, Z+1	; 0x01
    7942:	a2 81       	ldd	r26, Z+2	; 0x02
    7944:	b3 81       	ldd	r27, Z+3	; 0x03
    7946:	00 97       	sbiw	r24, 0x00	; 0
    7948:	a1 05       	cpc	r26, r1
    794a:	b1 05       	cpc	r27, r1
    794c:	c1 f4       	brne	.+48     	; 0x797e <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    794e:	20 91 56 07 	lds	r18, 0x0756
    7952:	30 91 57 07 	lds	r19, 0x0757
    7956:	8d 81       	ldd	r24, Y+5	; 0x05
    7958:	88 2f       	mov	r24, r24
    795a:	90 e0       	ldi	r25, 0x00	; 0
    795c:	82 0f       	add	r24, r18
    795e:	93 1f       	adc	r25, r19
    7960:	fc 01       	movw	r30, r24
    7962:	b7 96       	adiw	r30, 0x27	; 39
    7964:	81 e0       	ldi	r24, 0x01	; 1
    7966:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    7968:	8f 81       	ldd	r24, Y+7	; 0x07
    796a:	98 85       	ldd	r25, Y+8	; 0x08
    796c:	00 97       	sbiw	r24, 0x00	; 0
    796e:	39 f0       	breq	.+14     	; 0x797e <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7970:	8f 81       	ldd	r24, Y+7	; 0x07
    7972:	98 85       	ldd	r25, Y+8	; 0x08
    7974:	61 e0       	ldi	r22, 0x01	; 1
    7976:	0e 94 04 44 	call	0x8808	; 0x8808 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    797a:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    797e:	0f 90       	pop	r0
    7980:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    7982:	0f b6       	in	r0, 0x3f	; 63
    7984:	f8 94       	cli
    7986:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    7988:	20 91 56 07 	lds	r18, 0x0756
    798c:	30 91 57 07 	lds	r19, 0x0757
    7990:	8d 81       	ldd	r24, Y+5	; 0x05
    7992:	88 2f       	mov	r24, r24
    7994:	90 e0       	ldi	r25, 0x00	; 0
    7996:	88 0f       	add	r24, r24
    7998:	99 1f       	adc	r25, r25
    799a:	88 0f       	add	r24, r24
    799c:	99 1f       	adc	r25, r25
    799e:	82 0f       	add	r24, r18
    79a0:	93 1f       	adc	r25, r19
    79a2:	fc 01       	movw	r30, r24
    79a4:	b3 96       	adiw	r30, 0x23	; 35
    79a6:	80 81       	ld	r24, Z
    79a8:	91 81       	ldd	r25, Z+1	; 0x01
    79aa:	a2 81       	ldd	r26, Z+2	; 0x02
    79ac:	b3 81       	ldd	r27, Z+3	; 0x03
    79ae:	89 83       	std	Y+1, r24	; 0x01
    79b0:	9a 83       	std	Y+2, r25	; 0x02
    79b2:	ab 83       	std	Y+3, r26	; 0x03
    79b4:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    79b6:	89 81       	ldd	r24, Y+1	; 0x01
    79b8:	9a 81       	ldd	r25, Y+2	; 0x02
    79ba:	ab 81       	ldd	r26, Y+3	; 0x03
    79bc:	bc 81       	ldd	r27, Y+4	; 0x04
    79be:	00 97       	sbiw	r24, 0x00	; 0
    79c0:	a1 05       	cpc	r26, r1
    79c2:	b1 05       	cpc	r27, r1
    79c4:	a9 f1       	breq	.+106    	; 0x7a30 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    79c6:	8e 81       	ldd	r24, Y+6	; 0x06
    79c8:	88 23       	and	r24, r24
    79ca:	a1 f0       	breq	.+40     	; 0x79f4 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    79cc:	20 91 56 07 	lds	r18, 0x0756
    79d0:	30 91 57 07 	lds	r19, 0x0757
    79d4:	8d 81       	ldd	r24, Y+5	; 0x05
    79d6:	88 2f       	mov	r24, r24
    79d8:	90 e0       	ldi	r25, 0x00	; 0
    79da:	88 0f       	add	r24, r24
    79dc:	99 1f       	adc	r25, r25
    79de:	88 0f       	add	r24, r24
    79e0:	99 1f       	adc	r25, r25
    79e2:	82 0f       	add	r24, r18
    79e4:	93 1f       	adc	r25, r19
    79e6:	fc 01       	movw	r30, r24
    79e8:	b3 96       	adiw	r30, 0x23	; 35
    79ea:	10 82       	st	Z, r1
    79ec:	11 82       	std	Z+1, r1	; 0x01
    79ee:	12 82       	std	Z+2, r1	; 0x02
    79f0:	13 82       	std	Z+3, r1	; 0x03
    79f2:	1e c0       	rjmp	.+60     	; 0x7a30 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    79f4:	e0 91 56 07 	lds	r30, 0x0756
    79f8:	f0 91 57 07 	lds	r31, 0x0757
    79fc:	8d 81       	ldd	r24, Y+5	; 0x05
    79fe:	68 2f       	mov	r22, r24
    7a00:	70 e0       	ldi	r23, 0x00	; 0
    7a02:	89 81       	ldd	r24, Y+1	; 0x01
    7a04:	9a 81       	ldd	r25, Y+2	; 0x02
    7a06:	ab 81       	ldd	r26, Y+3	; 0x03
    7a08:	bc 81       	ldd	r27, Y+4	; 0x04
    7a0a:	9c 01       	movw	r18, r24
    7a0c:	ad 01       	movw	r20, r26
    7a0e:	21 50       	subi	r18, 0x01	; 1
    7a10:	30 40       	sbci	r19, 0x00	; 0
    7a12:	40 40       	sbci	r20, 0x00	; 0
    7a14:	50 40       	sbci	r21, 0x00	; 0
    7a16:	cb 01       	movw	r24, r22
    7a18:	88 0f       	add	r24, r24
    7a1a:	99 1f       	adc	r25, r25
    7a1c:	88 0f       	add	r24, r24
    7a1e:	99 1f       	adc	r25, r25
    7a20:	8e 0f       	add	r24, r30
    7a22:	9f 1f       	adc	r25, r31
    7a24:	fc 01       	movw	r30, r24
    7a26:	b3 96       	adiw	r30, 0x23	; 35
    7a28:	20 83       	st	Z, r18
    7a2a:	31 83       	std	Z+1, r19	; 0x01
    7a2c:	42 83       	std	Z+2, r20	; 0x02
    7a2e:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    7a30:	20 91 56 07 	lds	r18, 0x0756
    7a34:	30 91 57 07 	lds	r19, 0x0757
    7a38:	8d 81       	ldd	r24, Y+5	; 0x05
    7a3a:	88 2f       	mov	r24, r24
    7a3c:	90 e0       	ldi	r25, 0x00	; 0
    7a3e:	82 0f       	add	r24, r18
    7a40:	93 1f       	adc	r25, r19
    7a42:	fc 01       	movw	r30, r24
    7a44:	b7 96       	adiw	r30, 0x27	; 39
    7a46:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    7a48:	0f 90       	pop	r0
    7a4a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    7a4c:	89 81       	ldd	r24, Y+1	; 0x01
    7a4e:	9a 81       	ldd	r25, Y+2	; 0x02
    7a50:	ab 81       	ldd	r26, Y+3	; 0x03
    7a52:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    7a54:	bc 01       	movw	r22, r24
    7a56:	cd 01       	movw	r24, r26
    7a58:	28 96       	adiw	r28, 0x08	; 8
    7a5a:	0f b6       	in	r0, 0x3f	; 63
    7a5c:	f8 94       	cli
    7a5e:	de bf       	out	0x3e, r29	; 62
    7a60:	0f be       	out	0x3f, r0	; 63
    7a62:	cd bf       	out	0x3d, r28	; 61
    7a64:	cf 91       	pop	r28
    7a66:	df 91       	pop	r29
    7a68:	08 95       	ret

00007a6a <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    7a6a:	cf 92       	push	r12
    7a6c:	df 92       	push	r13
    7a6e:	ef 92       	push	r14
    7a70:	ff 92       	push	r15
    7a72:	0f 93       	push	r16
    7a74:	1f 93       	push	r17
    7a76:	df 93       	push	r29
    7a78:	cf 93       	push	r28
    7a7a:	cd b7       	in	r28, 0x3d	; 61
    7a7c:	de b7       	in	r29, 0x3e	; 62
    7a7e:	2e 97       	sbiw	r28, 0x0e	; 14
    7a80:	0f b6       	in	r0, 0x3f	; 63
    7a82:	f8 94       	cli
    7a84:	de bf       	out	0x3e, r29	; 62
    7a86:	0f be       	out	0x3f, r0	; 63
    7a88:	cd bf       	out	0x3d, r28	; 61
    7a8a:	8a 83       	std	Y+2, r24	; 0x02
    7a8c:	4b 83       	std	Y+3, r20	; 0x03
    7a8e:	5c 83       	std	Y+4, r21	; 0x04
    7a90:	6d 83       	std	Y+5, r22	; 0x05
    7a92:	7e 83       	std	Y+6, r23	; 0x06
    7a94:	0f 83       	std	Y+7, r16	; 0x07
    7a96:	18 87       	std	Y+8, r17	; 0x08
    7a98:	29 87       	std	Y+9, r18	; 0x09
    7a9a:	3a 87       	std	Y+10, r19	; 0x0a
    7a9c:	fc 86       	std	Y+12, r15	; 0x0c
    7a9e:	eb 86       	std	Y+11, r14	; 0x0b
    7aa0:	de 86       	std	Y+14, r13	; 0x0e
    7aa2:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    7aa4:	0f b6       	in	r0, 0x3f	; 63
    7aa6:	f8 94       	cli
    7aa8:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    7aaa:	20 91 56 07 	lds	r18, 0x0756
    7aae:	30 91 57 07 	lds	r19, 0x0757
    7ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    7ab4:	88 2f       	mov	r24, r24
    7ab6:	90 e0       	ldi	r25, 0x00	; 0
    7ab8:	82 0f       	add	r24, r18
    7aba:	93 1f       	adc	r25, r19
    7abc:	fc 01       	movw	r30, r24
    7abe:	b7 96       	adiw	r30, 0x27	; 39
    7ac0:	80 81       	ld	r24, Z
    7ac2:	82 30       	cpi	r24, 0x02	; 2
    7ac4:	09 f4       	brne	.+2      	; 0x7ac8 <xTaskGenericNotifyWait+0x5e>
    7ac6:	47 c0       	rjmp	.+142    	; 0x7b56 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    7ac8:	60 91 56 07 	lds	r22, 0x0756
    7acc:	70 91 57 07 	lds	r23, 0x0757
    7ad0:	8a 81       	ldd	r24, Y+2	; 0x02
    7ad2:	08 2f       	mov	r16, r24
    7ad4:	10 e0       	ldi	r17, 0x00	; 0
    7ad6:	8a 81       	ldd	r24, Y+2	; 0x02
    7ad8:	88 2f       	mov	r24, r24
    7ada:	90 e0       	ldi	r25, 0x00	; 0
    7adc:	88 0f       	add	r24, r24
    7ade:	99 1f       	adc	r25, r25
    7ae0:	88 0f       	add	r24, r24
    7ae2:	99 1f       	adc	r25, r25
    7ae4:	86 0f       	add	r24, r22
    7ae6:	97 1f       	adc	r25, r23
    7ae8:	fc 01       	movw	r30, r24
    7aea:	b3 96       	adiw	r30, 0x23	; 35
    7aec:	20 81       	ld	r18, Z
    7aee:	31 81       	ldd	r19, Z+1	; 0x01
    7af0:	42 81       	ldd	r20, Z+2	; 0x02
    7af2:	53 81       	ldd	r21, Z+3	; 0x03
    7af4:	8b 81       	ldd	r24, Y+3	; 0x03
    7af6:	9c 81       	ldd	r25, Y+4	; 0x04
    7af8:	ad 81       	ldd	r26, Y+5	; 0x05
    7afa:	be 81       	ldd	r27, Y+6	; 0x06
    7afc:	80 95       	com	r24
    7afe:	90 95       	com	r25
    7b00:	a0 95       	com	r26
    7b02:	b0 95       	com	r27
    7b04:	28 23       	and	r18, r24
    7b06:	39 23       	and	r19, r25
    7b08:	4a 23       	and	r20, r26
    7b0a:	5b 23       	and	r21, r27
    7b0c:	c8 01       	movw	r24, r16
    7b0e:	88 0f       	add	r24, r24
    7b10:	99 1f       	adc	r25, r25
    7b12:	88 0f       	add	r24, r24
    7b14:	99 1f       	adc	r25, r25
    7b16:	86 0f       	add	r24, r22
    7b18:	97 1f       	adc	r25, r23
    7b1a:	fc 01       	movw	r30, r24
    7b1c:	b3 96       	adiw	r30, 0x23	; 35
    7b1e:	20 83       	st	Z, r18
    7b20:	31 83       	std	Z+1, r19	; 0x01
    7b22:	42 83       	std	Z+2, r20	; 0x02
    7b24:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    7b26:	20 91 56 07 	lds	r18, 0x0756
    7b2a:	30 91 57 07 	lds	r19, 0x0757
    7b2e:	8a 81       	ldd	r24, Y+2	; 0x02
    7b30:	88 2f       	mov	r24, r24
    7b32:	90 e0       	ldi	r25, 0x00	; 0
    7b34:	82 0f       	add	r24, r18
    7b36:	93 1f       	adc	r25, r19
    7b38:	fc 01       	movw	r30, r24
    7b3a:	b7 96       	adiw	r30, 0x27	; 39
    7b3c:	81 e0       	ldi	r24, 0x01	; 1
    7b3e:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    7b40:	8d 85       	ldd	r24, Y+13	; 0x0d
    7b42:	9e 85       	ldd	r25, Y+14	; 0x0e
    7b44:	00 97       	sbiw	r24, 0x00	; 0
    7b46:	39 f0       	breq	.+14     	; 0x7b56 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7b48:	8d 85       	ldd	r24, Y+13	; 0x0d
    7b4a:	9e 85       	ldd	r25, Y+14	; 0x0e
    7b4c:	61 e0       	ldi	r22, 0x01	; 1
    7b4e:	0e 94 04 44 	call	0x8808	; 0x8808 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    7b52:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    7b56:	0f 90       	pop	r0
    7b58:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    7b5a:	0f b6       	in	r0, 0x3f	; 63
    7b5c:	f8 94       	cli
    7b5e:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    7b60:	8b 85       	ldd	r24, Y+11	; 0x0b
    7b62:	9c 85       	ldd	r25, Y+12	; 0x0c
    7b64:	00 97       	sbiw	r24, 0x00	; 0
    7b66:	c9 f0       	breq	.+50     	; 0x7b9a <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    7b68:	20 91 56 07 	lds	r18, 0x0756
    7b6c:	30 91 57 07 	lds	r19, 0x0757
    7b70:	8a 81       	ldd	r24, Y+2	; 0x02
    7b72:	88 2f       	mov	r24, r24
    7b74:	90 e0       	ldi	r25, 0x00	; 0
    7b76:	88 0f       	add	r24, r24
    7b78:	99 1f       	adc	r25, r25
    7b7a:	88 0f       	add	r24, r24
    7b7c:	99 1f       	adc	r25, r25
    7b7e:	82 0f       	add	r24, r18
    7b80:	93 1f       	adc	r25, r19
    7b82:	fc 01       	movw	r30, r24
    7b84:	b3 96       	adiw	r30, 0x23	; 35
    7b86:	80 81       	ld	r24, Z
    7b88:	91 81       	ldd	r25, Z+1	; 0x01
    7b8a:	a2 81       	ldd	r26, Z+2	; 0x02
    7b8c:	b3 81       	ldd	r27, Z+3	; 0x03
    7b8e:	eb 85       	ldd	r30, Y+11	; 0x0b
    7b90:	fc 85       	ldd	r31, Y+12	; 0x0c
    7b92:	80 83       	st	Z, r24
    7b94:	91 83       	std	Z+1, r25	; 0x01
    7b96:	a2 83       	std	Z+2, r26	; 0x02
    7b98:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    7b9a:	20 91 56 07 	lds	r18, 0x0756
    7b9e:	30 91 57 07 	lds	r19, 0x0757
    7ba2:	8a 81       	ldd	r24, Y+2	; 0x02
    7ba4:	88 2f       	mov	r24, r24
    7ba6:	90 e0       	ldi	r25, 0x00	; 0
    7ba8:	82 0f       	add	r24, r18
    7baa:	93 1f       	adc	r25, r19
    7bac:	fc 01       	movw	r30, r24
    7bae:	b7 96       	adiw	r30, 0x27	; 39
    7bb0:	80 81       	ld	r24, Z
    7bb2:	82 30       	cpi	r24, 0x02	; 2
    7bb4:	11 f0       	breq	.+4      	; 0x7bba <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    7bb6:	19 82       	std	Y+1, r1	; 0x01
    7bb8:	31 c0       	rjmp	.+98     	; 0x7c1c <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    7bba:	60 91 56 07 	lds	r22, 0x0756
    7bbe:	70 91 57 07 	lds	r23, 0x0757
    7bc2:	8a 81       	ldd	r24, Y+2	; 0x02
    7bc4:	08 2f       	mov	r16, r24
    7bc6:	10 e0       	ldi	r17, 0x00	; 0
    7bc8:	8a 81       	ldd	r24, Y+2	; 0x02
    7bca:	88 2f       	mov	r24, r24
    7bcc:	90 e0       	ldi	r25, 0x00	; 0
    7bce:	88 0f       	add	r24, r24
    7bd0:	99 1f       	adc	r25, r25
    7bd2:	88 0f       	add	r24, r24
    7bd4:	99 1f       	adc	r25, r25
    7bd6:	86 0f       	add	r24, r22
    7bd8:	97 1f       	adc	r25, r23
    7bda:	fc 01       	movw	r30, r24
    7bdc:	b3 96       	adiw	r30, 0x23	; 35
    7bde:	20 81       	ld	r18, Z
    7be0:	31 81       	ldd	r19, Z+1	; 0x01
    7be2:	42 81       	ldd	r20, Z+2	; 0x02
    7be4:	53 81       	ldd	r21, Z+3	; 0x03
    7be6:	8f 81       	ldd	r24, Y+7	; 0x07
    7be8:	98 85       	ldd	r25, Y+8	; 0x08
    7bea:	a9 85       	ldd	r26, Y+9	; 0x09
    7bec:	ba 85       	ldd	r27, Y+10	; 0x0a
    7bee:	80 95       	com	r24
    7bf0:	90 95       	com	r25
    7bf2:	a0 95       	com	r26
    7bf4:	b0 95       	com	r27
    7bf6:	28 23       	and	r18, r24
    7bf8:	39 23       	and	r19, r25
    7bfa:	4a 23       	and	r20, r26
    7bfc:	5b 23       	and	r21, r27
    7bfe:	c8 01       	movw	r24, r16
    7c00:	88 0f       	add	r24, r24
    7c02:	99 1f       	adc	r25, r25
    7c04:	88 0f       	add	r24, r24
    7c06:	99 1f       	adc	r25, r25
    7c08:	86 0f       	add	r24, r22
    7c0a:	97 1f       	adc	r25, r23
    7c0c:	fc 01       	movw	r30, r24
    7c0e:	b3 96       	adiw	r30, 0x23	; 35
    7c10:	20 83       	st	Z, r18
    7c12:	31 83       	std	Z+1, r19	; 0x01
    7c14:	42 83       	std	Z+2, r20	; 0x02
    7c16:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    7c18:	81 e0       	ldi	r24, 0x01	; 1
    7c1a:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    7c1c:	20 91 56 07 	lds	r18, 0x0756
    7c20:	30 91 57 07 	lds	r19, 0x0757
    7c24:	8a 81       	ldd	r24, Y+2	; 0x02
    7c26:	88 2f       	mov	r24, r24
    7c28:	90 e0       	ldi	r25, 0x00	; 0
    7c2a:	82 0f       	add	r24, r18
    7c2c:	93 1f       	adc	r25, r19
    7c2e:	fc 01       	movw	r30, r24
    7c30:	b7 96       	adiw	r30, 0x27	; 39
    7c32:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    7c34:	0f 90       	pop	r0
    7c36:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    7c38:	89 81       	ldd	r24, Y+1	; 0x01
    }
    7c3a:	2e 96       	adiw	r28, 0x0e	; 14
    7c3c:	0f b6       	in	r0, 0x3f	; 63
    7c3e:	f8 94       	cli
    7c40:	de bf       	out	0x3e, r29	; 62
    7c42:	0f be       	out	0x3f, r0	; 63
    7c44:	cd bf       	out	0x3d, r28	; 61
    7c46:	cf 91       	pop	r28
    7c48:	df 91       	pop	r29
    7c4a:	1f 91       	pop	r17
    7c4c:	0f 91       	pop	r16
    7c4e:	ff 90       	pop	r15
    7c50:	ef 90       	pop	r14
    7c52:	df 90       	pop	r13
    7c54:	cf 90       	pop	r12
    7c56:	08 95       	ret

00007c58 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    7c58:	ef 92       	push	r14
    7c5a:	ff 92       	push	r15
    7c5c:	0f 93       	push	r16
    7c5e:	1f 93       	push	r17
    7c60:	df 93       	push	r29
    7c62:	cf 93       	push	r28
    7c64:	cd b7       	in	r28, 0x3d	; 61
    7c66:	de b7       	in	r29, 0x3e	; 62
    7c68:	64 97       	sbiw	r28, 0x14	; 20
    7c6a:	0f b6       	in	r0, 0x3f	; 63
    7c6c:	f8 94       	cli
    7c6e:	de bf       	out	0x3e, r29	; 62
    7c70:	0f be       	out	0x3f, r0	; 63
    7c72:	cd bf       	out	0x3d, r28	; 61
    7c74:	9a 87       	std	Y+10, r25	; 0x0a
    7c76:	89 87       	std	Y+9, r24	; 0x09
    7c78:	6b 87       	std	Y+11, r22	; 0x0b
    7c7a:	2c 87       	std	Y+12, r18	; 0x0c
    7c7c:	3d 87       	std	Y+13, r19	; 0x0d
    7c7e:	4e 87       	std	Y+14, r20	; 0x0e
    7c80:	5f 87       	std	Y+15, r21	; 0x0f
    7c82:	08 8b       	std	Y+16, r16	; 0x10
    7c84:	fa 8a       	std	Y+18, r15	; 0x12
    7c86:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    7c88:	81 e0       	ldi	r24, 0x01	; 1
    7c8a:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    7c8c:	89 85       	ldd	r24, Y+9	; 0x09
    7c8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    7c90:	98 87       	std	Y+8, r25	; 0x08
    7c92:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    7c94:	0f b6       	in	r0, 0x3f	; 63
    7c96:	f8 94       	cli
    7c98:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    7c9a:	89 89       	ldd	r24, Y+17	; 0x11
    7c9c:	9a 89       	ldd	r25, Y+18	; 0x12
    7c9e:	00 97       	sbiw	r24, 0x00	; 0
    7ca0:	b9 f0       	breq	.+46     	; 0x7cd0 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    7ca2:	8b 85       	ldd	r24, Y+11	; 0x0b
    7ca4:	88 2f       	mov	r24, r24
    7ca6:	90 e0       	ldi	r25, 0x00	; 0
    7ca8:	2f 81       	ldd	r18, Y+7	; 0x07
    7caa:	38 85       	ldd	r19, Y+8	; 0x08
    7cac:	88 0f       	add	r24, r24
    7cae:	99 1f       	adc	r25, r25
    7cb0:	88 0f       	add	r24, r24
    7cb2:	99 1f       	adc	r25, r25
    7cb4:	82 0f       	add	r24, r18
    7cb6:	93 1f       	adc	r25, r19
    7cb8:	fc 01       	movw	r30, r24
    7cba:	b3 96       	adiw	r30, 0x23	; 35
    7cbc:	80 81       	ld	r24, Z
    7cbe:	91 81       	ldd	r25, Z+1	; 0x01
    7cc0:	a2 81       	ldd	r26, Z+2	; 0x02
    7cc2:	b3 81       	ldd	r27, Z+3	; 0x03
    7cc4:	e9 89       	ldd	r30, Y+17	; 0x11
    7cc6:	fa 89       	ldd	r31, Y+18	; 0x12
    7cc8:	80 83       	st	Z, r24
    7cca:	91 83       	std	Z+1, r25	; 0x01
    7ccc:	a2 83       	std	Z+2, r26	; 0x02
    7cce:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    7cd0:	8b 85       	ldd	r24, Y+11	; 0x0b
    7cd2:	28 2f       	mov	r18, r24
    7cd4:	30 e0       	ldi	r19, 0x00	; 0
    7cd6:	8f 81       	ldd	r24, Y+7	; 0x07
    7cd8:	98 85       	ldd	r25, Y+8	; 0x08
    7cda:	82 0f       	add	r24, r18
    7cdc:	93 1f       	adc	r25, r19
    7cde:	fc 01       	movw	r30, r24
    7ce0:	b7 96       	adiw	r30, 0x27	; 39
    7ce2:	80 81       	ld	r24, Z
    7ce4:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    7ce6:	8b 85       	ldd	r24, Y+11	; 0x0b
    7ce8:	28 2f       	mov	r18, r24
    7cea:	30 e0       	ldi	r19, 0x00	; 0
    7cec:	8f 81       	ldd	r24, Y+7	; 0x07
    7cee:	98 85       	ldd	r25, Y+8	; 0x08
    7cf0:	82 0f       	add	r24, r18
    7cf2:	93 1f       	adc	r25, r19
    7cf4:	fc 01       	movw	r30, r24
    7cf6:	b7 96       	adiw	r30, 0x27	; 39
    7cf8:	82 e0       	ldi	r24, 0x02	; 2
    7cfa:	80 83       	st	Z, r24

            switch( eAction )
    7cfc:	88 89       	ldd	r24, Y+16	; 0x10
    7cfe:	28 2f       	mov	r18, r24
    7d00:	30 e0       	ldi	r19, 0x00	; 0
    7d02:	3c 8b       	std	Y+20, r19	; 0x14
    7d04:	2b 8b       	std	Y+19, r18	; 0x13
    7d06:	8b 89       	ldd	r24, Y+19	; 0x13
    7d08:	9c 89       	ldd	r25, Y+20	; 0x14
    7d0a:	82 30       	cpi	r24, 0x02	; 2
    7d0c:	91 05       	cpc	r25, r1
    7d0e:	09 f4       	brne	.+2      	; 0x7d12 <xTaskGenericNotify+0xba>
    7d10:	46 c0       	rjmp	.+140    	; 0x7d9e <xTaskGenericNotify+0x146>
    7d12:	2b 89       	ldd	r18, Y+19	; 0x13
    7d14:	3c 89       	ldd	r19, Y+20	; 0x14
    7d16:	23 30       	cpi	r18, 0x03	; 3
    7d18:	31 05       	cpc	r19, r1
    7d1a:	34 f4       	brge	.+12     	; 0x7d28 <xTaskGenericNotify+0xd0>
    7d1c:	8b 89       	ldd	r24, Y+19	; 0x13
    7d1e:	9c 89       	ldd	r25, Y+20	; 0x14
    7d20:	81 30       	cpi	r24, 0x01	; 1
    7d22:	91 05       	cpc	r25, r1
    7d24:	71 f0       	breq	.+28     	; 0x7d42 <xTaskGenericNotify+0xea>
    7d26:	93 c0       	rjmp	.+294    	; 0x7e4e <xTaskGenericNotify+0x1f6>
    7d28:	2b 89       	ldd	r18, Y+19	; 0x13
    7d2a:	3c 89       	ldd	r19, Y+20	; 0x14
    7d2c:	23 30       	cpi	r18, 0x03	; 3
    7d2e:	31 05       	cpc	r19, r1
    7d30:	09 f4       	brne	.+2      	; 0x7d34 <xTaskGenericNotify+0xdc>
    7d32:	5d c0       	rjmp	.+186    	; 0x7dee <xTaskGenericNotify+0x196>
    7d34:	8b 89       	ldd	r24, Y+19	; 0x13
    7d36:	9c 89       	ldd	r25, Y+20	; 0x14
    7d38:	84 30       	cpi	r24, 0x04	; 4
    7d3a:	91 05       	cpc	r25, r1
    7d3c:	09 f4       	brne	.+2      	; 0x7d40 <xTaskGenericNotify+0xe8>
    7d3e:	6d c0       	rjmp	.+218    	; 0x7e1a <xTaskGenericNotify+0x1c2>
    7d40:	86 c0       	rjmp	.+268    	; 0x7e4e <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    7d42:	8b 85       	ldd	r24, Y+11	; 0x0b
    7d44:	08 2f       	mov	r16, r24
    7d46:	10 e0       	ldi	r17, 0x00	; 0
    7d48:	8b 85       	ldd	r24, Y+11	; 0x0b
    7d4a:	88 2f       	mov	r24, r24
    7d4c:	90 e0       	ldi	r25, 0x00	; 0
    7d4e:	2f 81       	ldd	r18, Y+7	; 0x07
    7d50:	38 85       	ldd	r19, Y+8	; 0x08
    7d52:	88 0f       	add	r24, r24
    7d54:	99 1f       	adc	r25, r25
    7d56:	88 0f       	add	r24, r24
    7d58:	99 1f       	adc	r25, r25
    7d5a:	82 0f       	add	r24, r18
    7d5c:	93 1f       	adc	r25, r19
    7d5e:	fc 01       	movw	r30, r24
    7d60:	b3 96       	adiw	r30, 0x23	; 35
    7d62:	20 81       	ld	r18, Z
    7d64:	31 81       	ldd	r19, Z+1	; 0x01
    7d66:	42 81       	ldd	r20, Z+2	; 0x02
    7d68:	53 81       	ldd	r21, Z+3	; 0x03
    7d6a:	8c 85       	ldd	r24, Y+12	; 0x0c
    7d6c:	9d 85       	ldd	r25, Y+13	; 0x0d
    7d6e:	ae 85       	ldd	r26, Y+14	; 0x0e
    7d70:	bf 85       	ldd	r27, Y+15	; 0x0f
    7d72:	ba 01       	movw	r22, r20
    7d74:	a9 01       	movw	r20, r18
    7d76:	48 2b       	or	r20, r24
    7d78:	59 2b       	or	r21, r25
    7d7a:	6a 2b       	or	r22, r26
    7d7c:	7b 2b       	or	r23, r27
    7d7e:	2f 81       	ldd	r18, Y+7	; 0x07
    7d80:	38 85       	ldd	r19, Y+8	; 0x08
    7d82:	c8 01       	movw	r24, r16
    7d84:	88 0f       	add	r24, r24
    7d86:	99 1f       	adc	r25, r25
    7d88:	88 0f       	add	r24, r24
    7d8a:	99 1f       	adc	r25, r25
    7d8c:	82 0f       	add	r24, r18
    7d8e:	93 1f       	adc	r25, r19
    7d90:	fc 01       	movw	r30, r24
    7d92:	b3 96       	adiw	r30, 0x23	; 35
    7d94:	40 83       	st	Z, r20
    7d96:	51 83       	std	Z+1, r21	; 0x01
    7d98:	62 83       	std	Z+2, r22	; 0x02
    7d9a:	73 83       	std	Z+3, r23	; 0x03
    7d9c:	58 c0       	rjmp	.+176    	; 0x7e4e <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    7d9e:	8b 85       	ldd	r24, Y+11	; 0x0b
    7da0:	08 2f       	mov	r16, r24
    7da2:	10 e0       	ldi	r17, 0x00	; 0
    7da4:	2f 81       	ldd	r18, Y+7	; 0x07
    7da6:	38 85       	ldd	r19, Y+8	; 0x08
    7da8:	c8 01       	movw	r24, r16
    7daa:	88 0f       	add	r24, r24
    7dac:	99 1f       	adc	r25, r25
    7dae:	88 0f       	add	r24, r24
    7db0:	99 1f       	adc	r25, r25
    7db2:	82 0f       	add	r24, r18
    7db4:	93 1f       	adc	r25, r19
    7db6:	fc 01       	movw	r30, r24
    7db8:	b3 96       	adiw	r30, 0x23	; 35
    7dba:	80 81       	ld	r24, Z
    7dbc:	91 81       	ldd	r25, Z+1	; 0x01
    7dbe:	a2 81       	ldd	r26, Z+2	; 0x02
    7dc0:	b3 81       	ldd	r27, Z+3	; 0x03
    7dc2:	ac 01       	movw	r20, r24
    7dc4:	bd 01       	movw	r22, r26
    7dc6:	4f 5f       	subi	r20, 0xFF	; 255
    7dc8:	5f 4f       	sbci	r21, 0xFF	; 255
    7dca:	6f 4f       	sbci	r22, 0xFF	; 255
    7dcc:	7f 4f       	sbci	r23, 0xFF	; 255
    7dce:	2f 81       	ldd	r18, Y+7	; 0x07
    7dd0:	38 85       	ldd	r19, Y+8	; 0x08
    7dd2:	c8 01       	movw	r24, r16
    7dd4:	88 0f       	add	r24, r24
    7dd6:	99 1f       	adc	r25, r25
    7dd8:	88 0f       	add	r24, r24
    7dda:	99 1f       	adc	r25, r25
    7ddc:	82 0f       	add	r24, r18
    7dde:	93 1f       	adc	r25, r19
    7de0:	fc 01       	movw	r30, r24
    7de2:	b3 96       	adiw	r30, 0x23	; 35
    7de4:	40 83       	st	Z, r20
    7de6:	51 83       	std	Z+1, r21	; 0x01
    7de8:	62 83       	std	Z+2, r22	; 0x02
    7dea:	73 83       	std	Z+3, r23	; 0x03
    7dec:	30 c0       	rjmp	.+96     	; 0x7e4e <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    7dee:	8b 85       	ldd	r24, Y+11	; 0x0b
    7df0:	88 2f       	mov	r24, r24
    7df2:	90 e0       	ldi	r25, 0x00	; 0
    7df4:	2f 81       	ldd	r18, Y+7	; 0x07
    7df6:	38 85       	ldd	r19, Y+8	; 0x08
    7df8:	88 0f       	add	r24, r24
    7dfa:	99 1f       	adc	r25, r25
    7dfc:	88 0f       	add	r24, r24
    7dfe:	99 1f       	adc	r25, r25
    7e00:	82 0f       	add	r24, r18
    7e02:	93 1f       	adc	r25, r19
    7e04:	fc 01       	movw	r30, r24
    7e06:	b3 96       	adiw	r30, 0x23	; 35
    7e08:	8c 85       	ldd	r24, Y+12	; 0x0c
    7e0a:	9d 85       	ldd	r25, Y+13	; 0x0d
    7e0c:	ae 85       	ldd	r26, Y+14	; 0x0e
    7e0e:	bf 85       	ldd	r27, Y+15	; 0x0f
    7e10:	80 83       	st	Z, r24
    7e12:	91 83       	std	Z+1, r25	; 0x01
    7e14:	a2 83       	std	Z+2, r26	; 0x02
    7e16:	b3 83       	std	Z+3, r27	; 0x03
    7e18:	1a c0       	rjmp	.+52     	; 0x7e4e <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    7e1a:	8d 81       	ldd	r24, Y+5	; 0x05
    7e1c:	82 30       	cpi	r24, 0x02	; 2
    7e1e:	b1 f0       	breq	.+44     	; 0x7e4c <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    7e20:	8b 85       	ldd	r24, Y+11	; 0x0b
    7e22:	88 2f       	mov	r24, r24
    7e24:	90 e0       	ldi	r25, 0x00	; 0
    7e26:	2f 81       	ldd	r18, Y+7	; 0x07
    7e28:	38 85       	ldd	r19, Y+8	; 0x08
    7e2a:	88 0f       	add	r24, r24
    7e2c:	99 1f       	adc	r25, r25
    7e2e:	88 0f       	add	r24, r24
    7e30:	99 1f       	adc	r25, r25
    7e32:	82 0f       	add	r24, r18
    7e34:	93 1f       	adc	r25, r19
    7e36:	fc 01       	movw	r30, r24
    7e38:	b3 96       	adiw	r30, 0x23	; 35
    7e3a:	8c 85       	ldd	r24, Y+12	; 0x0c
    7e3c:	9d 85       	ldd	r25, Y+13	; 0x0d
    7e3e:	ae 85       	ldd	r26, Y+14	; 0x0e
    7e40:	bf 85       	ldd	r27, Y+15	; 0x0f
    7e42:	80 83       	st	Z, r24
    7e44:	91 83       	std	Z+1, r25	; 0x01
    7e46:	a2 83       	std	Z+2, r26	; 0x02
    7e48:	b3 83       	std	Z+3, r27	; 0x03
    7e4a:	01 c0       	rjmp	.+2      	; 0x7e4e <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    7e4c:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    7e4e:	8d 81       	ldd	r24, Y+5	; 0x05
    7e50:	81 30       	cpi	r24, 0x01	; 1
    7e52:	09 f0       	breq	.+2      	; 0x7e56 <xTaskGenericNotify+0x1fe>
    7e54:	af c0       	rjmp	.+350    	; 0x7fb4 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    7e56:	ef 81       	ldd	r30, Y+7	; 0x07
    7e58:	f8 85       	ldd	r31, Y+8	; 0x08
    7e5a:	82 85       	ldd	r24, Z+10	; 0x0a
    7e5c:	93 85       	ldd	r25, Z+11	; 0x0b
    7e5e:	9c 83       	std	Y+4, r25	; 0x04
    7e60:	8b 83       	std	Y+3, r24	; 0x03
    7e62:	ef 81       	ldd	r30, Y+7	; 0x07
    7e64:	f8 85       	ldd	r31, Y+8	; 0x08
    7e66:	a4 81       	ldd	r26, Z+4	; 0x04
    7e68:	b5 81       	ldd	r27, Z+5	; 0x05
    7e6a:	ef 81       	ldd	r30, Y+7	; 0x07
    7e6c:	f8 85       	ldd	r31, Y+8	; 0x08
    7e6e:	86 81       	ldd	r24, Z+6	; 0x06
    7e70:	97 81       	ldd	r25, Z+7	; 0x07
    7e72:	15 96       	adiw	r26, 0x05	; 5
    7e74:	9c 93       	st	X, r25
    7e76:	8e 93       	st	-X, r24
    7e78:	14 97       	sbiw	r26, 0x04	; 4
    7e7a:	ef 81       	ldd	r30, Y+7	; 0x07
    7e7c:	f8 85       	ldd	r31, Y+8	; 0x08
    7e7e:	a6 81       	ldd	r26, Z+6	; 0x06
    7e80:	b7 81       	ldd	r27, Z+7	; 0x07
    7e82:	ef 81       	ldd	r30, Y+7	; 0x07
    7e84:	f8 85       	ldd	r31, Y+8	; 0x08
    7e86:	84 81       	ldd	r24, Z+4	; 0x04
    7e88:	95 81       	ldd	r25, Z+5	; 0x05
    7e8a:	13 96       	adiw	r26, 0x03	; 3
    7e8c:	9c 93       	st	X, r25
    7e8e:	8e 93       	st	-X, r24
    7e90:	12 97       	sbiw	r26, 0x02	; 2
    7e92:	eb 81       	ldd	r30, Y+3	; 0x03
    7e94:	fc 81       	ldd	r31, Y+4	; 0x04
    7e96:	21 81       	ldd	r18, Z+1	; 0x01
    7e98:	32 81       	ldd	r19, Z+2	; 0x02
    7e9a:	8f 81       	ldd	r24, Y+7	; 0x07
    7e9c:	98 85       	ldd	r25, Y+8	; 0x08
    7e9e:	02 96       	adiw	r24, 0x02	; 2
    7ea0:	28 17       	cp	r18, r24
    7ea2:	39 07       	cpc	r19, r25
    7ea4:	41 f4       	brne	.+16     	; 0x7eb6 <xTaskGenericNotify+0x25e>
    7ea6:	ef 81       	ldd	r30, Y+7	; 0x07
    7ea8:	f8 85       	ldd	r31, Y+8	; 0x08
    7eaa:	86 81       	ldd	r24, Z+6	; 0x06
    7eac:	97 81       	ldd	r25, Z+7	; 0x07
    7eae:	eb 81       	ldd	r30, Y+3	; 0x03
    7eb0:	fc 81       	ldd	r31, Y+4	; 0x04
    7eb2:	92 83       	std	Z+2, r25	; 0x02
    7eb4:	81 83       	std	Z+1, r24	; 0x01
    7eb6:	ef 81       	ldd	r30, Y+7	; 0x07
    7eb8:	f8 85       	ldd	r31, Y+8	; 0x08
    7eba:	13 86       	std	Z+11, r1	; 0x0b
    7ebc:	12 86       	std	Z+10, r1	; 0x0a
    7ebe:	eb 81       	ldd	r30, Y+3	; 0x03
    7ec0:	fc 81       	ldd	r31, Y+4	; 0x04
    7ec2:	80 81       	ld	r24, Z
    7ec4:	81 50       	subi	r24, 0x01	; 1
    7ec6:	eb 81       	ldd	r30, Y+3	; 0x03
    7ec8:	fc 81       	ldd	r31, Y+4	; 0x04
    7eca:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    7ecc:	ef 81       	ldd	r30, Y+7	; 0x07
    7ece:	f8 85       	ldd	r31, Y+8	; 0x08
    7ed0:	96 89       	ldd	r25, Z+22	; 0x16
    7ed2:	80 91 5c 07 	lds	r24, 0x075C
    7ed6:	89 17       	cp	r24, r25
    7ed8:	28 f4       	brcc	.+10     	; 0x7ee4 <xTaskGenericNotify+0x28c>
    7eda:	ef 81       	ldd	r30, Y+7	; 0x07
    7edc:	f8 85       	ldd	r31, Y+8	; 0x08
    7ede:	86 89       	ldd	r24, Z+22	; 0x16
    7ee0:	80 93 5c 07 	sts	0x075C, r24
    7ee4:	ef 81       	ldd	r30, Y+7	; 0x07
    7ee6:	f8 85       	ldd	r31, Y+8	; 0x08
    7ee8:	86 89       	ldd	r24, Z+22	; 0x16
    7eea:	28 2f       	mov	r18, r24
    7eec:	30 e0       	ldi	r19, 0x00	; 0
    7eee:	c9 01       	movw	r24, r18
    7ef0:	88 0f       	add	r24, r24
    7ef2:	99 1f       	adc	r25, r25
    7ef4:	88 0f       	add	r24, r24
    7ef6:	99 1f       	adc	r25, r25
    7ef8:	88 0f       	add	r24, r24
    7efa:	99 1f       	adc	r25, r25
    7efc:	82 0f       	add	r24, r18
    7efe:	93 1f       	adc	r25, r19
    7f00:	fc 01       	movw	r30, r24
    7f02:	e8 59       	subi	r30, 0x98	; 152
    7f04:	f8 4f       	sbci	r31, 0xF8	; 248
    7f06:	81 81       	ldd	r24, Z+1	; 0x01
    7f08:	92 81       	ldd	r25, Z+2	; 0x02
    7f0a:	9a 83       	std	Y+2, r25	; 0x02
    7f0c:	89 83       	std	Y+1, r24	; 0x01
    7f0e:	ef 81       	ldd	r30, Y+7	; 0x07
    7f10:	f8 85       	ldd	r31, Y+8	; 0x08
    7f12:	89 81       	ldd	r24, Y+1	; 0x01
    7f14:	9a 81       	ldd	r25, Y+2	; 0x02
    7f16:	95 83       	std	Z+5, r25	; 0x05
    7f18:	84 83       	std	Z+4, r24	; 0x04
    7f1a:	e9 81       	ldd	r30, Y+1	; 0x01
    7f1c:	fa 81       	ldd	r31, Y+2	; 0x02
    7f1e:	84 81       	ldd	r24, Z+4	; 0x04
    7f20:	95 81       	ldd	r25, Z+5	; 0x05
    7f22:	ef 81       	ldd	r30, Y+7	; 0x07
    7f24:	f8 85       	ldd	r31, Y+8	; 0x08
    7f26:	97 83       	std	Z+7, r25	; 0x07
    7f28:	86 83       	std	Z+6, r24	; 0x06
    7f2a:	e9 81       	ldd	r30, Y+1	; 0x01
    7f2c:	fa 81       	ldd	r31, Y+2	; 0x02
    7f2e:	04 80       	ldd	r0, Z+4	; 0x04
    7f30:	f5 81       	ldd	r31, Z+5	; 0x05
    7f32:	e0 2d       	mov	r30, r0
    7f34:	8f 81       	ldd	r24, Y+7	; 0x07
    7f36:	98 85       	ldd	r25, Y+8	; 0x08
    7f38:	02 96       	adiw	r24, 0x02	; 2
    7f3a:	93 83       	std	Z+3, r25	; 0x03
    7f3c:	82 83       	std	Z+2, r24	; 0x02
    7f3e:	8f 81       	ldd	r24, Y+7	; 0x07
    7f40:	98 85       	ldd	r25, Y+8	; 0x08
    7f42:	02 96       	adiw	r24, 0x02	; 2
    7f44:	e9 81       	ldd	r30, Y+1	; 0x01
    7f46:	fa 81       	ldd	r31, Y+2	; 0x02
    7f48:	95 83       	std	Z+5, r25	; 0x05
    7f4a:	84 83       	std	Z+4, r24	; 0x04
    7f4c:	ef 81       	ldd	r30, Y+7	; 0x07
    7f4e:	f8 85       	ldd	r31, Y+8	; 0x08
    7f50:	86 89       	ldd	r24, Z+22	; 0x16
    7f52:	28 2f       	mov	r18, r24
    7f54:	30 e0       	ldi	r19, 0x00	; 0
    7f56:	c9 01       	movw	r24, r18
    7f58:	88 0f       	add	r24, r24
    7f5a:	99 1f       	adc	r25, r25
    7f5c:	88 0f       	add	r24, r24
    7f5e:	99 1f       	adc	r25, r25
    7f60:	88 0f       	add	r24, r24
    7f62:	99 1f       	adc	r25, r25
    7f64:	82 0f       	add	r24, r18
    7f66:	93 1f       	adc	r25, r19
    7f68:	88 59       	subi	r24, 0x98	; 152
    7f6a:	98 4f       	sbci	r25, 0xF8	; 248
    7f6c:	ef 81       	ldd	r30, Y+7	; 0x07
    7f6e:	f8 85       	ldd	r31, Y+8	; 0x08
    7f70:	93 87       	std	Z+11, r25	; 0x0b
    7f72:	82 87       	std	Z+10, r24	; 0x0a
    7f74:	ef 81       	ldd	r30, Y+7	; 0x07
    7f76:	f8 85       	ldd	r31, Y+8	; 0x08
    7f78:	86 89       	ldd	r24, Z+22	; 0x16
    7f7a:	28 2f       	mov	r18, r24
    7f7c:	30 e0       	ldi	r19, 0x00	; 0
    7f7e:	c9 01       	movw	r24, r18
    7f80:	88 0f       	add	r24, r24
    7f82:	99 1f       	adc	r25, r25
    7f84:	88 0f       	add	r24, r24
    7f86:	99 1f       	adc	r25, r25
    7f88:	88 0f       	add	r24, r24
    7f8a:	99 1f       	adc	r25, r25
    7f8c:	82 0f       	add	r24, r18
    7f8e:	93 1f       	adc	r25, r19
    7f90:	fc 01       	movw	r30, r24
    7f92:	e8 59       	subi	r30, 0x98	; 152
    7f94:	f8 4f       	sbci	r31, 0xF8	; 248
    7f96:	80 81       	ld	r24, Z
    7f98:	8f 5f       	subi	r24, 0xFF	; 255
    7f9a:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    7f9c:	ef 81       	ldd	r30, Y+7	; 0x07
    7f9e:	f8 85       	ldd	r31, Y+8	; 0x08
    7fa0:	96 89       	ldd	r25, Z+22	; 0x16
    7fa2:	e0 91 56 07 	lds	r30, 0x0756
    7fa6:	f0 91 57 07 	lds	r31, 0x0757
    7faa:	86 89       	ldd	r24, Z+22	; 0x16
    7fac:	89 17       	cp	r24, r25
    7fae:	10 f4       	brcc	.+4      	; 0x7fb4 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    7fb0:	0e 94 cf 1a 	call	0x359e	; 0x359e <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    7fb4:	0f 90       	pop	r0
    7fb6:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    7fb8:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    7fba:	64 96       	adiw	r28, 0x14	; 20
    7fbc:	0f b6       	in	r0, 0x3f	; 63
    7fbe:	f8 94       	cli
    7fc0:	de bf       	out	0x3e, r29	; 62
    7fc2:	0f be       	out	0x3f, r0	; 63
    7fc4:	cd bf       	out	0x3d, r28	; 61
    7fc6:	cf 91       	pop	r28
    7fc8:	df 91       	pop	r29
    7fca:	1f 91       	pop	r17
    7fcc:	0f 91       	pop	r16
    7fce:	ff 90       	pop	r15
    7fd0:	ef 90       	pop	r14
    7fd2:	08 95       	ret

00007fd4 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    7fd4:	cf 92       	push	r12
    7fd6:	df 92       	push	r13
    7fd8:	ef 92       	push	r14
    7fda:	ff 92       	push	r15
    7fdc:	0f 93       	push	r16
    7fde:	1f 93       	push	r17
    7fe0:	df 93       	push	r29
    7fe2:	cf 93       	push	r28
    7fe4:	cd b7       	in	r28, 0x3d	; 61
    7fe6:	de b7       	in	r29, 0x3e	; 62
    7fe8:	69 97       	sbiw	r28, 0x19	; 25
    7fea:	0f b6       	in	r0, 0x3f	; 63
    7fec:	f8 94       	cli
    7fee:	de bf       	out	0x3e, r29	; 62
    7ff0:	0f be       	out	0x3f, r0	; 63
    7ff2:	cd bf       	out	0x3d, r28	; 61
    7ff4:	9d 87       	std	Y+13, r25	; 0x0d
    7ff6:	8c 87       	std	Y+12, r24	; 0x0c
    7ff8:	6e 87       	std	Y+14, r22	; 0x0e
    7ffa:	2f 87       	std	Y+15, r18	; 0x0f
    7ffc:	38 8b       	std	Y+16, r19	; 0x10
    7ffe:	49 8b       	std	Y+17, r20	; 0x11
    8000:	5a 8b       	std	Y+18, r21	; 0x12
    8002:	0b 8b       	std	Y+19, r16	; 0x13
    8004:	fd 8a       	std	Y+21, r15	; 0x15
    8006:	ec 8a       	std	Y+20, r14	; 0x14
    8008:	df 8a       	std	Y+23, r13	; 0x17
    800a:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    800c:	81 e0       	ldi	r24, 0x01	; 1
    800e:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    8010:	8c 85       	ldd	r24, Y+12	; 0x0c
    8012:	9d 85       	ldd	r25, Y+13	; 0x0d
    8014:	9b 87       	std	Y+11, r25	; 0x0b
    8016:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    8018:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    801a:	8c 89       	ldd	r24, Y+20	; 0x14
    801c:	9d 89       	ldd	r25, Y+21	; 0x15
    801e:	00 97       	sbiw	r24, 0x00	; 0
    8020:	b9 f0       	breq	.+46     	; 0x8050 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    8022:	8e 85       	ldd	r24, Y+14	; 0x0e
    8024:	88 2f       	mov	r24, r24
    8026:	90 e0       	ldi	r25, 0x00	; 0
    8028:	2a 85       	ldd	r18, Y+10	; 0x0a
    802a:	3b 85       	ldd	r19, Y+11	; 0x0b
    802c:	88 0f       	add	r24, r24
    802e:	99 1f       	adc	r25, r25
    8030:	88 0f       	add	r24, r24
    8032:	99 1f       	adc	r25, r25
    8034:	82 0f       	add	r24, r18
    8036:	93 1f       	adc	r25, r19
    8038:	fc 01       	movw	r30, r24
    803a:	b3 96       	adiw	r30, 0x23	; 35
    803c:	80 81       	ld	r24, Z
    803e:	91 81       	ldd	r25, Z+1	; 0x01
    8040:	a2 81       	ldd	r26, Z+2	; 0x02
    8042:	b3 81       	ldd	r27, Z+3	; 0x03
    8044:	ec 89       	ldd	r30, Y+20	; 0x14
    8046:	fd 89       	ldd	r31, Y+21	; 0x15
    8048:	80 83       	st	Z, r24
    804a:	91 83       	std	Z+1, r25	; 0x01
    804c:	a2 83       	std	Z+2, r26	; 0x02
    804e:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    8050:	8e 85       	ldd	r24, Y+14	; 0x0e
    8052:	28 2f       	mov	r18, r24
    8054:	30 e0       	ldi	r19, 0x00	; 0
    8056:	8a 85       	ldd	r24, Y+10	; 0x0a
    8058:	9b 85       	ldd	r25, Y+11	; 0x0b
    805a:	82 0f       	add	r24, r18
    805c:	93 1f       	adc	r25, r19
    805e:	fc 01       	movw	r30, r24
    8060:	b7 96       	adiw	r30, 0x27	; 39
    8062:	80 81       	ld	r24, Z
    8064:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    8066:	8e 85       	ldd	r24, Y+14	; 0x0e
    8068:	28 2f       	mov	r18, r24
    806a:	30 e0       	ldi	r19, 0x00	; 0
    806c:	8a 85       	ldd	r24, Y+10	; 0x0a
    806e:	9b 85       	ldd	r25, Y+11	; 0x0b
    8070:	82 0f       	add	r24, r18
    8072:	93 1f       	adc	r25, r19
    8074:	fc 01       	movw	r30, r24
    8076:	b7 96       	adiw	r30, 0x27	; 39
    8078:	82 e0       	ldi	r24, 0x02	; 2
    807a:	80 83       	st	Z, r24

            switch( eAction )
    807c:	8b 89       	ldd	r24, Y+19	; 0x13
    807e:	28 2f       	mov	r18, r24
    8080:	30 e0       	ldi	r19, 0x00	; 0
    8082:	39 8f       	std	Y+25, r19	; 0x19
    8084:	28 8f       	std	Y+24, r18	; 0x18
    8086:	88 8d       	ldd	r24, Y+24	; 0x18
    8088:	99 8d       	ldd	r25, Y+25	; 0x19
    808a:	82 30       	cpi	r24, 0x02	; 2
    808c:	91 05       	cpc	r25, r1
    808e:	09 f4       	brne	.+2      	; 0x8092 <xTaskGenericNotifyFromISR+0xbe>
    8090:	46 c0       	rjmp	.+140    	; 0x811e <xTaskGenericNotifyFromISR+0x14a>
    8092:	28 8d       	ldd	r18, Y+24	; 0x18
    8094:	39 8d       	ldd	r19, Y+25	; 0x19
    8096:	23 30       	cpi	r18, 0x03	; 3
    8098:	31 05       	cpc	r19, r1
    809a:	34 f4       	brge	.+12     	; 0x80a8 <xTaskGenericNotifyFromISR+0xd4>
    809c:	88 8d       	ldd	r24, Y+24	; 0x18
    809e:	99 8d       	ldd	r25, Y+25	; 0x19
    80a0:	81 30       	cpi	r24, 0x01	; 1
    80a2:	91 05       	cpc	r25, r1
    80a4:	71 f0       	breq	.+28     	; 0x80c2 <xTaskGenericNotifyFromISR+0xee>
    80a6:	93 c0       	rjmp	.+294    	; 0x81ce <xTaskGenericNotifyFromISR+0x1fa>
    80a8:	28 8d       	ldd	r18, Y+24	; 0x18
    80aa:	39 8d       	ldd	r19, Y+25	; 0x19
    80ac:	23 30       	cpi	r18, 0x03	; 3
    80ae:	31 05       	cpc	r19, r1
    80b0:	09 f4       	brne	.+2      	; 0x80b4 <xTaskGenericNotifyFromISR+0xe0>
    80b2:	5d c0       	rjmp	.+186    	; 0x816e <xTaskGenericNotifyFromISR+0x19a>
    80b4:	88 8d       	ldd	r24, Y+24	; 0x18
    80b6:	99 8d       	ldd	r25, Y+25	; 0x19
    80b8:	84 30       	cpi	r24, 0x04	; 4
    80ba:	91 05       	cpc	r25, r1
    80bc:	09 f4       	brne	.+2      	; 0x80c0 <xTaskGenericNotifyFromISR+0xec>
    80be:	6d c0       	rjmp	.+218    	; 0x819a <xTaskGenericNotifyFromISR+0x1c6>
    80c0:	86 c0       	rjmp	.+268    	; 0x81ce <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    80c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    80c4:	08 2f       	mov	r16, r24
    80c6:	10 e0       	ldi	r17, 0x00	; 0
    80c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    80ca:	88 2f       	mov	r24, r24
    80cc:	90 e0       	ldi	r25, 0x00	; 0
    80ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    80d0:	3b 85       	ldd	r19, Y+11	; 0x0b
    80d2:	88 0f       	add	r24, r24
    80d4:	99 1f       	adc	r25, r25
    80d6:	88 0f       	add	r24, r24
    80d8:	99 1f       	adc	r25, r25
    80da:	82 0f       	add	r24, r18
    80dc:	93 1f       	adc	r25, r19
    80de:	fc 01       	movw	r30, r24
    80e0:	b3 96       	adiw	r30, 0x23	; 35
    80e2:	20 81       	ld	r18, Z
    80e4:	31 81       	ldd	r19, Z+1	; 0x01
    80e6:	42 81       	ldd	r20, Z+2	; 0x02
    80e8:	53 81       	ldd	r21, Z+3	; 0x03
    80ea:	8f 85       	ldd	r24, Y+15	; 0x0f
    80ec:	98 89       	ldd	r25, Y+16	; 0x10
    80ee:	a9 89       	ldd	r26, Y+17	; 0x11
    80f0:	ba 89       	ldd	r27, Y+18	; 0x12
    80f2:	ba 01       	movw	r22, r20
    80f4:	a9 01       	movw	r20, r18
    80f6:	48 2b       	or	r20, r24
    80f8:	59 2b       	or	r21, r25
    80fa:	6a 2b       	or	r22, r26
    80fc:	7b 2b       	or	r23, r27
    80fe:	2a 85       	ldd	r18, Y+10	; 0x0a
    8100:	3b 85       	ldd	r19, Y+11	; 0x0b
    8102:	c8 01       	movw	r24, r16
    8104:	88 0f       	add	r24, r24
    8106:	99 1f       	adc	r25, r25
    8108:	88 0f       	add	r24, r24
    810a:	99 1f       	adc	r25, r25
    810c:	82 0f       	add	r24, r18
    810e:	93 1f       	adc	r25, r19
    8110:	fc 01       	movw	r30, r24
    8112:	b3 96       	adiw	r30, 0x23	; 35
    8114:	40 83       	st	Z, r20
    8116:	51 83       	std	Z+1, r21	; 0x01
    8118:	62 83       	std	Z+2, r22	; 0x02
    811a:	73 83       	std	Z+3, r23	; 0x03
    811c:	58 c0       	rjmp	.+176    	; 0x81ce <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    811e:	8e 85       	ldd	r24, Y+14	; 0x0e
    8120:	08 2f       	mov	r16, r24
    8122:	10 e0       	ldi	r17, 0x00	; 0
    8124:	2a 85       	ldd	r18, Y+10	; 0x0a
    8126:	3b 85       	ldd	r19, Y+11	; 0x0b
    8128:	c8 01       	movw	r24, r16
    812a:	88 0f       	add	r24, r24
    812c:	99 1f       	adc	r25, r25
    812e:	88 0f       	add	r24, r24
    8130:	99 1f       	adc	r25, r25
    8132:	82 0f       	add	r24, r18
    8134:	93 1f       	adc	r25, r19
    8136:	fc 01       	movw	r30, r24
    8138:	b3 96       	adiw	r30, 0x23	; 35
    813a:	80 81       	ld	r24, Z
    813c:	91 81       	ldd	r25, Z+1	; 0x01
    813e:	a2 81       	ldd	r26, Z+2	; 0x02
    8140:	b3 81       	ldd	r27, Z+3	; 0x03
    8142:	ac 01       	movw	r20, r24
    8144:	bd 01       	movw	r22, r26
    8146:	4f 5f       	subi	r20, 0xFF	; 255
    8148:	5f 4f       	sbci	r21, 0xFF	; 255
    814a:	6f 4f       	sbci	r22, 0xFF	; 255
    814c:	7f 4f       	sbci	r23, 0xFF	; 255
    814e:	2a 85       	ldd	r18, Y+10	; 0x0a
    8150:	3b 85       	ldd	r19, Y+11	; 0x0b
    8152:	c8 01       	movw	r24, r16
    8154:	88 0f       	add	r24, r24
    8156:	99 1f       	adc	r25, r25
    8158:	88 0f       	add	r24, r24
    815a:	99 1f       	adc	r25, r25
    815c:	82 0f       	add	r24, r18
    815e:	93 1f       	adc	r25, r19
    8160:	fc 01       	movw	r30, r24
    8162:	b3 96       	adiw	r30, 0x23	; 35
    8164:	40 83       	st	Z, r20
    8166:	51 83       	std	Z+1, r21	; 0x01
    8168:	62 83       	std	Z+2, r22	; 0x02
    816a:	73 83       	std	Z+3, r23	; 0x03
    816c:	30 c0       	rjmp	.+96     	; 0x81ce <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    816e:	8e 85       	ldd	r24, Y+14	; 0x0e
    8170:	88 2f       	mov	r24, r24
    8172:	90 e0       	ldi	r25, 0x00	; 0
    8174:	2a 85       	ldd	r18, Y+10	; 0x0a
    8176:	3b 85       	ldd	r19, Y+11	; 0x0b
    8178:	88 0f       	add	r24, r24
    817a:	99 1f       	adc	r25, r25
    817c:	88 0f       	add	r24, r24
    817e:	99 1f       	adc	r25, r25
    8180:	82 0f       	add	r24, r18
    8182:	93 1f       	adc	r25, r19
    8184:	fc 01       	movw	r30, r24
    8186:	b3 96       	adiw	r30, 0x23	; 35
    8188:	8f 85       	ldd	r24, Y+15	; 0x0f
    818a:	98 89       	ldd	r25, Y+16	; 0x10
    818c:	a9 89       	ldd	r26, Y+17	; 0x11
    818e:	ba 89       	ldd	r27, Y+18	; 0x12
    8190:	80 83       	st	Z, r24
    8192:	91 83       	std	Z+1, r25	; 0x01
    8194:	a2 83       	std	Z+2, r26	; 0x02
    8196:	b3 83       	std	Z+3, r27	; 0x03
    8198:	1a c0       	rjmp	.+52     	; 0x81ce <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    819a:	89 85       	ldd	r24, Y+9	; 0x09
    819c:	82 30       	cpi	r24, 0x02	; 2
    819e:	b1 f0       	breq	.+44     	; 0x81cc <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    81a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    81a2:	88 2f       	mov	r24, r24
    81a4:	90 e0       	ldi	r25, 0x00	; 0
    81a6:	2a 85       	ldd	r18, Y+10	; 0x0a
    81a8:	3b 85       	ldd	r19, Y+11	; 0x0b
    81aa:	88 0f       	add	r24, r24
    81ac:	99 1f       	adc	r25, r25
    81ae:	88 0f       	add	r24, r24
    81b0:	99 1f       	adc	r25, r25
    81b2:	82 0f       	add	r24, r18
    81b4:	93 1f       	adc	r25, r19
    81b6:	fc 01       	movw	r30, r24
    81b8:	b3 96       	adiw	r30, 0x23	; 35
    81ba:	8f 85       	ldd	r24, Y+15	; 0x0f
    81bc:	98 89       	ldd	r25, Y+16	; 0x10
    81be:	a9 89       	ldd	r26, Y+17	; 0x11
    81c0:	ba 89       	ldd	r27, Y+18	; 0x12
    81c2:	80 83       	st	Z, r24
    81c4:	91 83       	std	Z+1, r25	; 0x01
    81c6:	a2 83       	std	Z+2, r26	; 0x02
    81c8:	b3 83       	std	Z+3, r27	; 0x03
    81ca:	01 c0       	rjmp	.+2      	; 0x81ce <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    81cc:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    81ce:	89 85       	ldd	r24, Y+9	; 0x09
    81d0:	81 30       	cpi	r24, 0x01	; 1
    81d2:	09 f0       	breq	.+2      	; 0x81d6 <xTaskGenericNotifyFromISR+0x202>
    81d4:	ee c0       	rjmp	.+476    	; 0x83b2 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    81d6:	80 91 67 07 	lds	r24, 0x0767
    81da:	88 23       	and	r24, r24
    81dc:	09 f0       	breq	.+2      	; 0x81e0 <xTaskGenericNotifyFromISR+0x20c>
    81de:	a4 c0       	rjmp	.+328    	; 0x8328 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    81e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    81e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    81e4:	82 85       	ldd	r24, Z+10	; 0x0a
    81e6:	93 85       	ldd	r25, Z+11	; 0x0b
    81e8:	9e 83       	std	Y+6, r25	; 0x06
    81ea:	8d 83       	std	Y+5, r24	; 0x05
    81ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    81ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    81f0:	a4 81       	ldd	r26, Z+4	; 0x04
    81f2:	b5 81       	ldd	r27, Z+5	; 0x05
    81f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    81f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    81f8:	86 81       	ldd	r24, Z+6	; 0x06
    81fa:	97 81       	ldd	r25, Z+7	; 0x07
    81fc:	15 96       	adiw	r26, 0x05	; 5
    81fe:	9c 93       	st	X, r25
    8200:	8e 93       	st	-X, r24
    8202:	14 97       	sbiw	r26, 0x04	; 4
    8204:	ea 85       	ldd	r30, Y+10	; 0x0a
    8206:	fb 85       	ldd	r31, Y+11	; 0x0b
    8208:	a6 81       	ldd	r26, Z+6	; 0x06
    820a:	b7 81       	ldd	r27, Z+7	; 0x07
    820c:	ea 85       	ldd	r30, Y+10	; 0x0a
    820e:	fb 85       	ldd	r31, Y+11	; 0x0b
    8210:	84 81       	ldd	r24, Z+4	; 0x04
    8212:	95 81       	ldd	r25, Z+5	; 0x05
    8214:	13 96       	adiw	r26, 0x03	; 3
    8216:	9c 93       	st	X, r25
    8218:	8e 93       	st	-X, r24
    821a:	12 97       	sbiw	r26, 0x02	; 2
    821c:	ed 81       	ldd	r30, Y+5	; 0x05
    821e:	fe 81       	ldd	r31, Y+6	; 0x06
    8220:	21 81       	ldd	r18, Z+1	; 0x01
    8222:	32 81       	ldd	r19, Z+2	; 0x02
    8224:	8a 85       	ldd	r24, Y+10	; 0x0a
    8226:	9b 85       	ldd	r25, Y+11	; 0x0b
    8228:	02 96       	adiw	r24, 0x02	; 2
    822a:	28 17       	cp	r18, r24
    822c:	39 07       	cpc	r19, r25
    822e:	41 f4       	brne	.+16     	; 0x8240 <xTaskGenericNotifyFromISR+0x26c>
    8230:	ea 85       	ldd	r30, Y+10	; 0x0a
    8232:	fb 85       	ldd	r31, Y+11	; 0x0b
    8234:	86 81       	ldd	r24, Z+6	; 0x06
    8236:	97 81       	ldd	r25, Z+7	; 0x07
    8238:	ed 81       	ldd	r30, Y+5	; 0x05
    823a:	fe 81       	ldd	r31, Y+6	; 0x06
    823c:	92 83       	std	Z+2, r25	; 0x02
    823e:	81 83       	std	Z+1, r24	; 0x01
    8240:	ea 85       	ldd	r30, Y+10	; 0x0a
    8242:	fb 85       	ldd	r31, Y+11	; 0x0b
    8244:	13 86       	std	Z+11, r1	; 0x0b
    8246:	12 86       	std	Z+10, r1	; 0x0a
    8248:	ed 81       	ldd	r30, Y+5	; 0x05
    824a:	fe 81       	ldd	r31, Y+6	; 0x06
    824c:	80 81       	ld	r24, Z
    824e:	81 50       	subi	r24, 0x01	; 1
    8250:	ed 81       	ldd	r30, Y+5	; 0x05
    8252:	fe 81       	ldd	r31, Y+6	; 0x06
    8254:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    8256:	ea 85       	ldd	r30, Y+10	; 0x0a
    8258:	fb 85       	ldd	r31, Y+11	; 0x0b
    825a:	96 89       	ldd	r25, Z+22	; 0x16
    825c:	80 91 5c 07 	lds	r24, 0x075C
    8260:	89 17       	cp	r24, r25
    8262:	28 f4       	brcc	.+10     	; 0x826e <xTaskGenericNotifyFromISR+0x29a>
    8264:	ea 85       	ldd	r30, Y+10	; 0x0a
    8266:	fb 85       	ldd	r31, Y+11	; 0x0b
    8268:	86 89       	ldd	r24, Z+22	; 0x16
    826a:	80 93 5c 07 	sts	0x075C, r24
    826e:	ea 85       	ldd	r30, Y+10	; 0x0a
    8270:	fb 85       	ldd	r31, Y+11	; 0x0b
    8272:	86 89       	ldd	r24, Z+22	; 0x16
    8274:	28 2f       	mov	r18, r24
    8276:	30 e0       	ldi	r19, 0x00	; 0
    8278:	c9 01       	movw	r24, r18
    827a:	88 0f       	add	r24, r24
    827c:	99 1f       	adc	r25, r25
    827e:	88 0f       	add	r24, r24
    8280:	99 1f       	adc	r25, r25
    8282:	88 0f       	add	r24, r24
    8284:	99 1f       	adc	r25, r25
    8286:	82 0f       	add	r24, r18
    8288:	93 1f       	adc	r25, r19
    828a:	fc 01       	movw	r30, r24
    828c:	e8 59       	subi	r30, 0x98	; 152
    828e:	f8 4f       	sbci	r31, 0xF8	; 248
    8290:	81 81       	ldd	r24, Z+1	; 0x01
    8292:	92 81       	ldd	r25, Z+2	; 0x02
    8294:	9c 83       	std	Y+4, r25	; 0x04
    8296:	8b 83       	std	Y+3, r24	; 0x03
    8298:	ea 85       	ldd	r30, Y+10	; 0x0a
    829a:	fb 85       	ldd	r31, Y+11	; 0x0b
    829c:	8b 81       	ldd	r24, Y+3	; 0x03
    829e:	9c 81       	ldd	r25, Y+4	; 0x04
    82a0:	95 83       	std	Z+5, r25	; 0x05
    82a2:	84 83       	std	Z+4, r24	; 0x04
    82a4:	eb 81       	ldd	r30, Y+3	; 0x03
    82a6:	fc 81       	ldd	r31, Y+4	; 0x04
    82a8:	84 81       	ldd	r24, Z+4	; 0x04
    82aa:	95 81       	ldd	r25, Z+5	; 0x05
    82ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    82ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    82b0:	97 83       	std	Z+7, r25	; 0x07
    82b2:	86 83       	std	Z+6, r24	; 0x06
    82b4:	eb 81       	ldd	r30, Y+3	; 0x03
    82b6:	fc 81       	ldd	r31, Y+4	; 0x04
    82b8:	04 80       	ldd	r0, Z+4	; 0x04
    82ba:	f5 81       	ldd	r31, Z+5	; 0x05
    82bc:	e0 2d       	mov	r30, r0
    82be:	8a 85       	ldd	r24, Y+10	; 0x0a
    82c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    82c2:	02 96       	adiw	r24, 0x02	; 2
    82c4:	93 83       	std	Z+3, r25	; 0x03
    82c6:	82 83       	std	Z+2, r24	; 0x02
    82c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    82ca:	9b 85       	ldd	r25, Y+11	; 0x0b
    82cc:	02 96       	adiw	r24, 0x02	; 2
    82ce:	eb 81       	ldd	r30, Y+3	; 0x03
    82d0:	fc 81       	ldd	r31, Y+4	; 0x04
    82d2:	95 83       	std	Z+5, r25	; 0x05
    82d4:	84 83       	std	Z+4, r24	; 0x04
    82d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    82d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    82da:	86 89       	ldd	r24, Z+22	; 0x16
    82dc:	28 2f       	mov	r18, r24
    82de:	30 e0       	ldi	r19, 0x00	; 0
    82e0:	c9 01       	movw	r24, r18
    82e2:	88 0f       	add	r24, r24
    82e4:	99 1f       	adc	r25, r25
    82e6:	88 0f       	add	r24, r24
    82e8:	99 1f       	adc	r25, r25
    82ea:	88 0f       	add	r24, r24
    82ec:	99 1f       	adc	r25, r25
    82ee:	82 0f       	add	r24, r18
    82f0:	93 1f       	adc	r25, r19
    82f2:	88 59       	subi	r24, 0x98	; 152
    82f4:	98 4f       	sbci	r25, 0xF8	; 248
    82f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    82f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    82fa:	93 87       	std	Z+11, r25	; 0x0b
    82fc:	82 87       	std	Z+10, r24	; 0x0a
    82fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    8300:	fb 85       	ldd	r31, Y+11	; 0x0b
    8302:	86 89       	ldd	r24, Z+22	; 0x16
    8304:	28 2f       	mov	r18, r24
    8306:	30 e0       	ldi	r19, 0x00	; 0
    8308:	c9 01       	movw	r24, r18
    830a:	88 0f       	add	r24, r24
    830c:	99 1f       	adc	r25, r25
    830e:	88 0f       	add	r24, r24
    8310:	99 1f       	adc	r25, r25
    8312:	88 0f       	add	r24, r24
    8314:	99 1f       	adc	r25, r25
    8316:	82 0f       	add	r24, r18
    8318:	93 1f       	adc	r25, r19
    831a:	fc 01       	movw	r30, r24
    831c:	e8 59       	subi	r30, 0x98	; 152
    831e:	f8 4f       	sbci	r31, 0xF8	; 248
    8320:	80 81       	ld	r24, Z
    8322:	8f 5f       	subi	r24, 0xFF	; 255
    8324:	80 83       	st	Z, r24
    8326:	30 c0       	rjmp	.+96     	; 0x8388 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    8328:	80 91 a3 07 	lds	r24, 0x07A3
    832c:	90 91 a4 07 	lds	r25, 0x07A4
    8330:	9a 83       	std	Y+2, r25	; 0x02
    8332:	89 83       	std	Y+1, r24	; 0x01
    8334:	ea 85       	ldd	r30, Y+10	; 0x0a
    8336:	fb 85       	ldd	r31, Y+11	; 0x0b
    8338:	89 81       	ldd	r24, Y+1	; 0x01
    833a:	9a 81       	ldd	r25, Y+2	; 0x02
    833c:	97 87       	std	Z+15, r25	; 0x0f
    833e:	86 87       	std	Z+14, r24	; 0x0e
    8340:	e9 81       	ldd	r30, Y+1	; 0x01
    8342:	fa 81       	ldd	r31, Y+2	; 0x02
    8344:	84 81       	ldd	r24, Z+4	; 0x04
    8346:	95 81       	ldd	r25, Z+5	; 0x05
    8348:	ea 85       	ldd	r30, Y+10	; 0x0a
    834a:	fb 85       	ldd	r31, Y+11	; 0x0b
    834c:	91 8b       	std	Z+17, r25	; 0x11
    834e:	80 8b       	std	Z+16, r24	; 0x10
    8350:	e9 81       	ldd	r30, Y+1	; 0x01
    8352:	fa 81       	ldd	r31, Y+2	; 0x02
    8354:	04 80       	ldd	r0, Z+4	; 0x04
    8356:	f5 81       	ldd	r31, Z+5	; 0x05
    8358:	e0 2d       	mov	r30, r0
    835a:	8a 85       	ldd	r24, Y+10	; 0x0a
    835c:	9b 85       	ldd	r25, Y+11	; 0x0b
    835e:	0c 96       	adiw	r24, 0x0c	; 12
    8360:	93 83       	std	Z+3, r25	; 0x03
    8362:	82 83       	std	Z+2, r24	; 0x02
    8364:	8a 85       	ldd	r24, Y+10	; 0x0a
    8366:	9b 85       	ldd	r25, Y+11	; 0x0b
    8368:	0c 96       	adiw	r24, 0x0c	; 12
    836a:	e9 81       	ldd	r30, Y+1	; 0x01
    836c:	fa 81       	ldd	r31, Y+2	; 0x02
    836e:	95 83       	std	Z+5, r25	; 0x05
    8370:	84 83       	std	Z+4, r24	; 0x04
    8372:	ea 85       	ldd	r30, Y+10	; 0x0a
    8374:	fb 85       	ldd	r31, Y+11	; 0x0b
    8376:	82 ea       	ldi	r24, 0xA2	; 162
    8378:	97 e0       	ldi	r25, 0x07	; 7
    837a:	95 8b       	std	Z+21, r25	; 0x15
    837c:	84 8b       	std	Z+20, r24	; 0x14
    837e:	80 91 a2 07 	lds	r24, 0x07A2
    8382:	8f 5f       	subi	r24, 0xFF	; 255
    8384:	80 93 a2 07 	sts	0x07A2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    8388:	ea 85       	ldd	r30, Y+10	; 0x0a
    838a:	fb 85       	ldd	r31, Y+11	; 0x0b
    838c:	96 89       	ldd	r25, Z+22	; 0x16
    838e:	e0 91 56 07 	lds	r30, 0x0756
    8392:	f0 91 57 07 	lds	r31, 0x0757
    8396:	86 89       	ldd	r24, Z+22	; 0x16
    8398:	89 17       	cp	r24, r25
    839a:	58 f4       	brcc	.+22     	; 0x83b2 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    839c:	8e 89       	ldd	r24, Y+22	; 0x16
    839e:	9f 89       	ldd	r25, Y+23	; 0x17
    83a0:	00 97       	sbiw	r24, 0x00	; 0
    83a2:	21 f0       	breq	.+8      	; 0x83ac <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    83a4:	ee 89       	ldd	r30, Y+22	; 0x16
    83a6:	ff 89       	ldd	r31, Y+23	; 0x17
    83a8:	81 e0       	ldi	r24, 0x01	; 1
    83aa:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    83ac:	81 e0       	ldi	r24, 0x01	; 1
    83ae:	80 93 60 07 	sts	0x0760, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    83b2:	88 85       	ldd	r24, Y+8	; 0x08
    }
    83b4:	69 96       	adiw	r28, 0x19	; 25
    83b6:	0f b6       	in	r0, 0x3f	; 63
    83b8:	f8 94       	cli
    83ba:	de bf       	out	0x3e, r29	; 62
    83bc:	0f be       	out	0x3f, r0	; 63
    83be:	cd bf       	out	0x3d, r28	; 61
    83c0:	cf 91       	pop	r28
    83c2:	df 91       	pop	r29
    83c4:	1f 91       	pop	r17
    83c6:	0f 91       	pop	r16
    83c8:	ff 90       	pop	r15
    83ca:	ef 90       	pop	r14
    83cc:	df 90       	pop	r13
    83ce:	cf 90       	pop	r12
    83d0:	08 95       	ret

000083d2 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    83d2:	0f 93       	push	r16
    83d4:	1f 93       	push	r17
    83d6:	df 93       	push	r29
    83d8:	cf 93       	push	r28
    83da:	cd b7       	in	r28, 0x3d	; 61
    83dc:	de b7       	in	r29, 0x3e	; 62
    83de:	2f 97       	sbiw	r28, 0x0f	; 15
    83e0:	0f b6       	in	r0, 0x3f	; 63
    83e2:	f8 94       	cli
    83e4:	de bf       	out	0x3e, r29	; 62
    83e6:	0f be       	out	0x3f, r0	; 63
    83e8:	cd bf       	out	0x3d, r28	; 61
    83ea:	9c 87       	std	Y+12, r25	; 0x0c
    83ec:	8b 87       	std	Y+11, r24	; 0x0b
    83ee:	6d 87       	std	Y+13, r22	; 0x0d
    83f0:	5f 87       	std	Y+15, r21	; 0x0f
    83f2:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    83f4:	8b 85       	ldd	r24, Y+11	; 0x0b
    83f6:	9c 85       	ldd	r25, Y+12	; 0x0c
    83f8:	9a 87       	std	Y+10, r25	; 0x0a
    83fa:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    83fc:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    83fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    8400:	28 2f       	mov	r18, r24
    8402:	30 e0       	ldi	r19, 0x00	; 0
    8404:	89 85       	ldd	r24, Y+9	; 0x09
    8406:	9a 85       	ldd	r25, Y+10	; 0x0a
    8408:	82 0f       	add	r24, r18
    840a:	93 1f       	adc	r25, r19
    840c:	fc 01       	movw	r30, r24
    840e:	b7 96       	adiw	r30, 0x27	; 39
    8410:	80 81       	ld	r24, Z
    8412:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    8414:	8d 85       	ldd	r24, Y+13	; 0x0d
    8416:	28 2f       	mov	r18, r24
    8418:	30 e0       	ldi	r19, 0x00	; 0
    841a:	89 85       	ldd	r24, Y+9	; 0x09
    841c:	9a 85       	ldd	r25, Y+10	; 0x0a
    841e:	82 0f       	add	r24, r18
    8420:	93 1f       	adc	r25, r19
    8422:	fc 01       	movw	r30, r24
    8424:	b7 96       	adiw	r30, 0x27	; 39
    8426:	82 e0       	ldi	r24, 0x02	; 2
    8428:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    842a:	8d 85       	ldd	r24, Y+13	; 0x0d
    842c:	08 2f       	mov	r16, r24
    842e:	10 e0       	ldi	r17, 0x00	; 0
    8430:	29 85       	ldd	r18, Y+9	; 0x09
    8432:	3a 85       	ldd	r19, Y+10	; 0x0a
    8434:	c8 01       	movw	r24, r16
    8436:	88 0f       	add	r24, r24
    8438:	99 1f       	adc	r25, r25
    843a:	88 0f       	add	r24, r24
    843c:	99 1f       	adc	r25, r25
    843e:	82 0f       	add	r24, r18
    8440:	93 1f       	adc	r25, r19
    8442:	fc 01       	movw	r30, r24
    8444:	b3 96       	adiw	r30, 0x23	; 35
    8446:	80 81       	ld	r24, Z
    8448:	91 81       	ldd	r25, Z+1	; 0x01
    844a:	a2 81       	ldd	r26, Z+2	; 0x02
    844c:	b3 81       	ldd	r27, Z+3	; 0x03
    844e:	ac 01       	movw	r20, r24
    8450:	bd 01       	movw	r22, r26
    8452:	4f 5f       	subi	r20, 0xFF	; 255
    8454:	5f 4f       	sbci	r21, 0xFF	; 255
    8456:	6f 4f       	sbci	r22, 0xFF	; 255
    8458:	7f 4f       	sbci	r23, 0xFF	; 255
    845a:	29 85       	ldd	r18, Y+9	; 0x09
    845c:	3a 85       	ldd	r19, Y+10	; 0x0a
    845e:	c8 01       	movw	r24, r16
    8460:	88 0f       	add	r24, r24
    8462:	99 1f       	adc	r25, r25
    8464:	88 0f       	add	r24, r24
    8466:	99 1f       	adc	r25, r25
    8468:	82 0f       	add	r24, r18
    846a:	93 1f       	adc	r25, r19
    846c:	fc 01       	movw	r30, r24
    846e:	b3 96       	adiw	r30, 0x23	; 35
    8470:	40 83       	st	Z, r20
    8472:	51 83       	std	Z+1, r21	; 0x01
    8474:	62 83       	std	Z+2, r22	; 0x02
    8476:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    8478:	88 85       	ldd	r24, Y+8	; 0x08
    847a:	81 30       	cpi	r24, 0x01	; 1
    847c:	09 f0       	breq	.+2      	; 0x8480 <vTaskGenericNotifyGiveFromISR+0xae>
    847e:	ee c0       	rjmp	.+476    	; 0x865c <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    8480:	80 91 67 07 	lds	r24, 0x0767
    8484:	88 23       	and	r24, r24
    8486:	09 f0       	breq	.+2      	; 0x848a <vTaskGenericNotifyGiveFromISR+0xb8>
    8488:	a4 c0       	rjmp	.+328    	; 0x85d2 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    848a:	e9 85       	ldd	r30, Y+9	; 0x09
    848c:	fa 85       	ldd	r31, Y+10	; 0x0a
    848e:	82 85       	ldd	r24, Z+10	; 0x0a
    8490:	93 85       	ldd	r25, Z+11	; 0x0b
    8492:	9e 83       	std	Y+6, r25	; 0x06
    8494:	8d 83       	std	Y+5, r24	; 0x05
    8496:	e9 85       	ldd	r30, Y+9	; 0x09
    8498:	fa 85       	ldd	r31, Y+10	; 0x0a
    849a:	a4 81       	ldd	r26, Z+4	; 0x04
    849c:	b5 81       	ldd	r27, Z+5	; 0x05
    849e:	e9 85       	ldd	r30, Y+9	; 0x09
    84a0:	fa 85       	ldd	r31, Y+10	; 0x0a
    84a2:	86 81       	ldd	r24, Z+6	; 0x06
    84a4:	97 81       	ldd	r25, Z+7	; 0x07
    84a6:	15 96       	adiw	r26, 0x05	; 5
    84a8:	9c 93       	st	X, r25
    84aa:	8e 93       	st	-X, r24
    84ac:	14 97       	sbiw	r26, 0x04	; 4
    84ae:	e9 85       	ldd	r30, Y+9	; 0x09
    84b0:	fa 85       	ldd	r31, Y+10	; 0x0a
    84b2:	a6 81       	ldd	r26, Z+6	; 0x06
    84b4:	b7 81       	ldd	r27, Z+7	; 0x07
    84b6:	e9 85       	ldd	r30, Y+9	; 0x09
    84b8:	fa 85       	ldd	r31, Y+10	; 0x0a
    84ba:	84 81       	ldd	r24, Z+4	; 0x04
    84bc:	95 81       	ldd	r25, Z+5	; 0x05
    84be:	13 96       	adiw	r26, 0x03	; 3
    84c0:	9c 93       	st	X, r25
    84c2:	8e 93       	st	-X, r24
    84c4:	12 97       	sbiw	r26, 0x02	; 2
    84c6:	ed 81       	ldd	r30, Y+5	; 0x05
    84c8:	fe 81       	ldd	r31, Y+6	; 0x06
    84ca:	21 81       	ldd	r18, Z+1	; 0x01
    84cc:	32 81       	ldd	r19, Z+2	; 0x02
    84ce:	89 85       	ldd	r24, Y+9	; 0x09
    84d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    84d2:	02 96       	adiw	r24, 0x02	; 2
    84d4:	28 17       	cp	r18, r24
    84d6:	39 07       	cpc	r19, r25
    84d8:	41 f4       	brne	.+16     	; 0x84ea <vTaskGenericNotifyGiveFromISR+0x118>
    84da:	e9 85       	ldd	r30, Y+9	; 0x09
    84dc:	fa 85       	ldd	r31, Y+10	; 0x0a
    84de:	86 81       	ldd	r24, Z+6	; 0x06
    84e0:	97 81       	ldd	r25, Z+7	; 0x07
    84e2:	ed 81       	ldd	r30, Y+5	; 0x05
    84e4:	fe 81       	ldd	r31, Y+6	; 0x06
    84e6:	92 83       	std	Z+2, r25	; 0x02
    84e8:	81 83       	std	Z+1, r24	; 0x01
    84ea:	e9 85       	ldd	r30, Y+9	; 0x09
    84ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    84ee:	13 86       	std	Z+11, r1	; 0x0b
    84f0:	12 86       	std	Z+10, r1	; 0x0a
    84f2:	ed 81       	ldd	r30, Y+5	; 0x05
    84f4:	fe 81       	ldd	r31, Y+6	; 0x06
    84f6:	80 81       	ld	r24, Z
    84f8:	81 50       	subi	r24, 0x01	; 1
    84fa:	ed 81       	ldd	r30, Y+5	; 0x05
    84fc:	fe 81       	ldd	r31, Y+6	; 0x06
    84fe:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    8500:	e9 85       	ldd	r30, Y+9	; 0x09
    8502:	fa 85       	ldd	r31, Y+10	; 0x0a
    8504:	96 89       	ldd	r25, Z+22	; 0x16
    8506:	80 91 5c 07 	lds	r24, 0x075C
    850a:	89 17       	cp	r24, r25
    850c:	28 f4       	brcc	.+10     	; 0x8518 <vTaskGenericNotifyGiveFromISR+0x146>
    850e:	e9 85       	ldd	r30, Y+9	; 0x09
    8510:	fa 85       	ldd	r31, Y+10	; 0x0a
    8512:	86 89       	ldd	r24, Z+22	; 0x16
    8514:	80 93 5c 07 	sts	0x075C, r24
    8518:	e9 85       	ldd	r30, Y+9	; 0x09
    851a:	fa 85       	ldd	r31, Y+10	; 0x0a
    851c:	86 89       	ldd	r24, Z+22	; 0x16
    851e:	28 2f       	mov	r18, r24
    8520:	30 e0       	ldi	r19, 0x00	; 0
    8522:	c9 01       	movw	r24, r18
    8524:	88 0f       	add	r24, r24
    8526:	99 1f       	adc	r25, r25
    8528:	88 0f       	add	r24, r24
    852a:	99 1f       	adc	r25, r25
    852c:	88 0f       	add	r24, r24
    852e:	99 1f       	adc	r25, r25
    8530:	82 0f       	add	r24, r18
    8532:	93 1f       	adc	r25, r19
    8534:	fc 01       	movw	r30, r24
    8536:	e8 59       	subi	r30, 0x98	; 152
    8538:	f8 4f       	sbci	r31, 0xF8	; 248
    853a:	81 81       	ldd	r24, Z+1	; 0x01
    853c:	92 81       	ldd	r25, Z+2	; 0x02
    853e:	9c 83       	std	Y+4, r25	; 0x04
    8540:	8b 83       	std	Y+3, r24	; 0x03
    8542:	e9 85       	ldd	r30, Y+9	; 0x09
    8544:	fa 85       	ldd	r31, Y+10	; 0x0a
    8546:	8b 81       	ldd	r24, Y+3	; 0x03
    8548:	9c 81       	ldd	r25, Y+4	; 0x04
    854a:	95 83       	std	Z+5, r25	; 0x05
    854c:	84 83       	std	Z+4, r24	; 0x04
    854e:	eb 81       	ldd	r30, Y+3	; 0x03
    8550:	fc 81       	ldd	r31, Y+4	; 0x04
    8552:	84 81       	ldd	r24, Z+4	; 0x04
    8554:	95 81       	ldd	r25, Z+5	; 0x05
    8556:	e9 85       	ldd	r30, Y+9	; 0x09
    8558:	fa 85       	ldd	r31, Y+10	; 0x0a
    855a:	97 83       	std	Z+7, r25	; 0x07
    855c:	86 83       	std	Z+6, r24	; 0x06
    855e:	eb 81       	ldd	r30, Y+3	; 0x03
    8560:	fc 81       	ldd	r31, Y+4	; 0x04
    8562:	04 80       	ldd	r0, Z+4	; 0x04
    8564:	f5 81       	ldd	r31, Z+5	; 0x05
    8566:	e0 2d       	mov	r30, r0
    8568:	89 85       	ldd	r24, Y+9	; 0x09
    856a:	9a 85       	ldd	r25, Y+10	; 0x0a
    856c:	02 96       	adiw	r24, 0x02	; 2
    856e:	93 83       	std	Z+3, r25	; 0x03
    8570:	82 83       	std	Z+2, r24	; 0x02
    8572:	89 85       	ldd	r24, Y+9	; 0x09
    8574:	9a 85       	ldd	r25, Y+10	; 0x0a
    8576:	02 96       	adiw	r24, 0x02	; 2
    8578:	eb 81       	ldd	r30, Y+3	; 0x03
    857a:	fc 81       	ldd	r31, Y+4	; 0x04
    857c:	95 83       	std	Z+5, r25	; 0x05
    857e:	84 83       	std	Z+4, r24	; 0x04
    8580:	e9 85       	ldd	r30, Y+9	; 0x09
    8582:	fa 85       	ldd	r31, Y+10	; 0x0a
    8584:	86 89       	ldd	r24, Z+22	; 0x16
    8586:	28 2f       	mov	r18, r24
    8588:	30 e0       	ldi	r19, 0x00	; 0
    858a:	c9 01       	movw	r24, r18
    858c:	88 0f       	add	r24, r24
    858e:	99 1f       	adc	r25, r25
    8590:	88 0f       	add	r24, r24
    8592:	99 1f       	adc	r25, r25
    8594:	88 0f       	add	r24, r24
    8596:	99 1f       	adc	r25, r25
    8598:	82 0f       	add	r24, r18
    859a:	93 1f       	adc	r25, r19
    859c:	88 59       	subi	r24, 0x98	; 152
    859e:	98 4f       	sbci	r25, 0xF8	; 248
    85a0:	e9 85       	ldd	r30, Y+9	; 0x09
    85a2:	fa 85       	ldd	r31, Y+10	; 0x0a
    85a4:	93 87       	std	Z+11, r25	; 0x0b
    85a6:	82 87       	std	Z+10, r24	; 0x0a
    85a8:	e9 85       	ldd	r30, Y+9	; 0x09
    85aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    85ac:	86 89       	ldd	r24, Z+22	; 0x16
    85ae:	28 2f       	mov	r18, r24
    85b0:	30 e0       	ldi	r19, 0x00	; 0
    85b2:	c9 01       	movw	r24, r18
    85b4:	88 0f       	add	r24, r24
    85b6:	99 1f       	adc	r25, r25
    85b8:	88 0f       	add	r24, r24
    85ba:	99 1f       	adc	r25, r25
    85bc:	88 0f       	add	r24, r24
    85be:	99 1f       	adc	r25, r25
    85c0:	82 0f       	add	r24, r18
    85c2:	93 1f       	adc	r25, r19
    85c4:	fc 01       	movw	r30, r24
    85c6:	e8 59       	subi	r30, 0x98	; 152
    85c8:	f8 4f       	sbci	r31, 0xF8	; 248
    85ca:	80 81       	ld	r24, Z
    85cc:	8f 5f       	subi	r24, 0xFF	; 255
    85ce:	80 83       	st	Z, r24
    85d0:	30 c0       	rjmp	.+96     	; 0x8632 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    85d2:	80 91 a3 07 	lds	r24, 0x07A3
    85d6:	90 91 a4 07 	lds	r25, 0x07A4
    85da:	9a 83       	std	Y+2, r25	; 0x02
    85dc:	89 83       	std	Y+1, r24	; 0x01
    85de:	e9 85       	ldd	r30, Y+9	; 0x09
    85e0:	fa 85       	ldd	r31, Y+10	; 0x0a
    85e2:	89 81       	ldd	r24, Y+1	; 0x01
    85e4:	9a 81       	ldd	r25, Y+2	; 0x02
    85e6:	97 87       	std	Z+15, r25	; 0x0f
    85e8:	86 87       	std	Z+14, r24	; 0x0e
    85ea:	e9 81       	ldd	r30, Y+1	; 0x01
    85ec:	fa 81       	ldd	r31, Y+2	; 0x02
    85ee:	84 81       	ldd	r24, Z+4	; 0x04
    85f0:	95 81       	ldd	r25, Z+5	; 0x05
    85f2:	e9 85       	ldd	r30, Y+9	; 0x09
    85f4:	fa 85       	ldd	r31, Y+10	; 0x0a
    85f6:	91 8b       	std	Z+17, r25	; 0x11
    85f8:	80 8b       	std	Z+16, r24	; 0x10
    85fa:	e9 81       	ldd	r30, Y+1	; 0x01
    85fc:	fa 81       	ldd	r31, Y+2	; 0x02
    85fe:	04 80       	ldd	r0, Z+4	; 0x04
    8600:	f5 81       	ldd	r31, Z+5	; 0x05
    8602:	e0 2d       	mov	r30, r0
    8604:	89 85       	ldd	r24, Y+9	; 0x09
    8606:	9a 85       	ldd	r25, Y+10	; 0x0a
    8608:	0c 96       	adiw	r24, 0x0c	; 12
    860a:	93 83       	std	Z+3, r25	; 0x03
    860c:	82 83       	std	Z+2, r24	; 0x02
    860e:	89 85       	ldd	r24, Y+9	; 0x09
    8610:	9a 85       	ldd	r25, Y+10	; 0x0a
    8612:	0c 96       	adiw	r24, 0x0c	; 12
    8614:	e9 81       	ldd	r30, Y+1	; 0x01
    8616:	fa 81       	ldd	r31, Y+2	; 0x02
    8618:	95 83       	std	Z+5, r25	; 0x05
    861a:	84 83       	std	Z+4, r24	; 0x04
    861c:	e9 85       	ldd	r30, Y+9	; 0x09
    861e:	fa 85       	ldd	r31, Y+10	; 0x0a
    8620:	82 ea       	ldi	r24, 0xA2	; 162
    8622:	97 e0       	ldi	r25, 0x07	; 7
    8624:	95 8b       	std	Z+21, r25	; 0x15
    8626:	84 8b       	std	Z+20, r24	; 0x14
    8628:	80 91 a2 07 	lds	r24, 0x07A2
    862c:	8f 5f       	subi	r24, 0xFF	; 255
    862e:	80 93 a2 07 	sts	0x07A2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    8632:	e9 85       	ldd	r30, Y+9	; 0x09
    8634:	fa 85       	ldd	r31, Y+10	; 0x0a
    8636:	96 89       	ldd	r25, Z+22	; 0x16
    8638:	e0 91 56 07 	lds	r30, 0x0756
    863c:	f0 91 57 07 	lds	r31, 0x0757
    8640:	86 89       	ldd	r24, Z+22	; 0x16
    8642:	89 17       	cp	r24, r25
    8644:	58 f4       	brcc	.+22     	; 0x865c <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    8646:	8e 85       	ldd	r24, Y+14	; 0x0e
    8648:	9f 85       	ldd	r25, Y+15	; 0x0f
    864a:	00 97       	sbiw	r24, 0x00	; 0
    864c:	21 f0       	breq	.+8      	; 0x8656 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    864e:	ee 85       	ldd	r30, Y+14	; 0x0e
    8650:	ff 85       	ldd	r31, Y+15	; 0x0f
    8652:	81 e0       	ldi	r24, 0x01	; 1
    8654:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    8656:	81 e0       	ldi	r24, 0x01	; 1
    8658:	80 93 60 07 	sts	0x0760, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    865c:	2f 96       	adiw	r28, 0x0f	; 15
    865e:	0f b6       	in	r0, 0x3f	; 63
    8660:	f8 94       	cli
    8662:	de bf       	out	0x3e, r29	; 62
    8664:	0f be       	out	0x3f, r0	; 63
    8666:	cd bf       	out	0x3d, r28	; 61
    8668:	cf 91       	pop	r28
    866a:	df 91       	pop	r29
    866c:	1f 91       	pop	r17
    866e:	0f 91       	pop	r16
    8670:	08 95       	ret

00008672 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    8672:	df 93       	push	r29
    8674:	cf 93       	push	r28
    8676:	cd b7       	in	r28, 0x3d	; 61
    8678:	de b7       	in	r29, 0x3e	; 62
    867a:	28 97       	sbiw	r28, 0x08	; 8
    867c:	0f b6       	in	r0, 0x3f	; 63
    867e:	f8 94       	cli
    8680:	de bf       	out	0x3e, r29	; 62
    8682:	0f be       	out	0x3f, r0	; 63
    8684:	cd bf       	out	0x3d, r28	; 61
    8686:	9d 83       	std	Y+5, r25	; 0x05
    8688:	8c 83       	std	Y+4, r24	; 0x04
    868a:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    868c:	8c 81       	ldd	r24, Y+4	; 0x04
    868e:	9d 81       	ldd	r25, Y+5	; 0x05
    8690:	00 97       	sbiw	r24, 0x00	; 0
    8692:	39 f4       	brne	.+14     	; 0x86a2 <xTaskGenericNotifyStateClear+0x30>
    8694:	80 91 56 07 	lds	r24, 0x0756
    8698:	90 91 57 07 	lds	r25, 0x0757
    869c:	98 87       	std	Y+8, r25	; 0x08
    869e:	8f 83       	std	Y+7, r24	; 0x07
    86a0:	04 c0       	rjmp	.+8      	; 0x86aa <xTaskGenericNotifyStateClear+0x38>
    86a2:	8c 81       	ldd	r24, Y+4	; 0x04
    86a4:	9d 81       	ldd	r25, Y+5	; 0x05
    86a6:	98 87       	std	Y+8, r25	; 0x08
    86a8:	8f 83       	std	Y+7, r24	; 0x07
    86aa:	8f 81       	ldd	r24, Y+7	; 0x07
    86ac:	98 85       	ldd	r25, Y+8	; 0x08
    86ae:	9b 83       	std	Y+3, r25	; 0x03
    86b0:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    86b2:	0f b6       	in	r0, 0x3f	; 63
    86b4:	f8 94       	cli
    86b6:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    86b8:	8e 81       	ldd	r24, Y+6	; 0x06
    86ba:	28 2f       	mov	r18, r24
    86bc:	30 e0       	ldi	r19, 0x00	; 0
    86be:	8a 81       	ldd	r24, Y+2	; 0x02
    86c0:	9b 81       	ldd	r25, Y+3	; 0x03
    86c2:	82 0f       	add	r24, r18
    86c4:	93 1f       	adc	r25, r19
    86c6:	fc 01       	movw	r30, r24
    86c8:	b7 96       	adiw	r30, 0x27	; 39
    86ca:	80 81       	ld	r24, Z
    86cc:	82 30       	cpi	r24, 0x02	; 2
    86ce:	69 f4       	brne	.+26     	; 0x86ea <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    86d0:	8e 81       	ldd	r24, Y+6	; 0x06
    86d2:	28 2f       	mov	r18, r24
    86d4:	30 e0       	ldi	r19, 0x00	; 0
    86d6:	8a 81       	ldd	r24, Y+2	; 0x02
    86d8:	9b 81       	ldd	r25, Y+3	; 0x03
    86da:	82 0f       	add	r24, r18
    86dc:	93 1f       	adc	r25, r19
    86de:	fc 01       	movw	r30, r24
    86e0:	b7 96       	adiw	r30, 0x27	; 39
    86e2:	10 82       	st	Z, r1
                xReturn = pdPASS;
    86e4:	81 e0       	ldi	r24, 0x01	; 1
    86e6:	89 83       	std	Y+1, r24	; 0x01
    86e8:	01 c0       	rjmp	.+2      	; 0x86ec <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    86ea:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    86ec:	0f 90       	pop	r0
    86ee:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    86f0:	89 81       	ldd	r24, Y+1	; 0x01
    }
    86f2:	28 96       	adiw	r28, 0x08	; 8
    86f4:	0f b6       	in	r0, 0x3f	; 63
    86f6:	f8 94       	cli
    86f8:	de bf       	out	0x3e, r29	; 62
    86fa:	0f be       	out	0x3f, r0	; 63
    86fc:	cd bf       	out	0x3d, r28	; 61
    86fe:	cf 91       	pop	r28
    8700:	df 91       	pop	r29
    8702:	08 95       	ret

00008704 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    8704:	0f 93       	push	r16
    8706:	1f 93       	push	r17
    8708:	df 93       	push	r29
    870a:	cf 93       	push	r28
    870c:	cd b7       	in	r28, 0x3d	; 61
    870e:	de b7       	in	r29, 0x3e	; 62
    8710:	2f 97       	sbiw	r28, 0x0f	; 15
    8712:	0f b6       	in	r0, 0x3f	; 63
    8714:	f8 94       	cli
    8716:	de bf       	out	0x3e, r29	; 62
    8718:	0f be       	out	0x3f, r0	; 63
    871a:	cd bf       	out	0x3d, r28	; 61
    871c:	98 87       	std	Y+8, r25	; 0x08
    871e:	8f 83       	std	Y+7, r24	; 0x07
    8720:	69 87       	std	Y+9, r22	; 0x09
    8722:	2a 87       	std	Y+10, r18	; 0x0a
    8724:	3b 87       	std	Y+11, r19	; 0x0b
    8726:	4c 87       	std	Y+12, r20	; 0x0c
    8728:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    872a:	8f 81       	ldd	r24, Y+7	; 0x07
    872c:	98 85       	ldd	r25, Y+8	; 0x08
    872e:	00 97       	sbiw	r24, 0x00	; 0
    8730:	39 f4       	brne	.+14     	; 0x8740 <ulTaskGenericNotifyValueClear+0x3c>
    8732:	80 91 56 07 	lds	r24, 0x0756
    8736:	90 91 57 07 	lds	r25, 0x0757
    873a:	9f 87       	std	Y+15, r25	; 0x0f
    873c:	8e 87       	std	Y+14, r24	; 0x0e
    873e:	04 c0       	rjmp	.+8      	; 0x8748 <ulTaskGenericNotifyValueClear+0x44>
    8740:	8f 81       	ldd	r24, Y+7	; 0x07
    8742:	98 85       	ldd	r25, Y+8	; 0x08
    8744:	9f 87       	std	Y+15, r25	; 0x0f
    8746:	8e 87       	std	Y+14, r24	; 0x0e
    8748:	8e 85       	ldd	r24, Y+14	; 0x0e
    874a:	9f 85       	ldd	r25, Y+15	; 0x0f
    874c:	9e 83       	std	Y+6, r25	; 0x06
    874e:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    8750:	0f b6       	in	r0, 0x3f	; 63
    8752:	f8 94       	cli
    8754:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    8756:	89 85       	ldd	r24, Y+9	; 0x09
    8758:	88 2f       	mov	r24, r24
    875a:	90 e0       	ldi	r25, 0x00	; 0
    875c:	2d 81       	ldd	r18, Y+5	; 0x05
    875e:	3e 81       	ldd	r19, Y+6	; 0x06
    8760:	88 0f       	add	r24, r24
    8762:	99 1f       	adc	r25, r25
    8764:	88 0f       	add	r24, r24
    8766:	99 1f       	adc	r25, r25
    8768:	82 0f       	add	r24, r18
    876a:	93 1f       	adc	r25, r19
    876c:	fc 01       	movw	r30, r24
    876e:	b3 96       	adiw	r30, 0x23	; 35
    8770:	80 81       	ld	r24, Z
    8772:	91 81       	ldd	r25, Z+1	; 0x01
    8774:	a2 81       	ldd	r26, Z+2	; 0x02
    8776:	b3 81       	ldd	r27, Z+3	; 0x03
    8778:	89 83       	std	Y+1, r24	; 0x01
    877a:	9a 83       	std	Y+2, r25	; 0x02
    877c:	ab 83       	std	Y+3, r26	; 0x03
    877e:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    8780:	89 85       	ldd	r24, Y+9	; 0x09
    8782:	08 2f       	mov	r16, r24
    8784:	10 e0       	ldi	r17, 0x00	; 0
    8786:	89 85       	ldd	r24, Y+9	; 0x09
    8788:	88 2f       	mov	r24, r24
    878a:	90 e0       	ldi	r25, 0x00	; 0
    878c:	2d 81       	ldd	r18, Y+5	; 0x05
    878e:	3e 81       	ldd	r19, Y+6	; 0x06
    8790:	88 0f       	add	r24, r24
    8792:	99 1f       	adc	r25, r25
    8794:	88 0f       	add	r24, r24
    8796:	99 1f       	adc	r25, r25
    8798:	82 0f       	add	r24, r18
    879a:	93 1f       	adc	r25, r19
    879c:	fc 01       	movw	r30, r24
    879e:	b3 96       	adiw	r30, 0x23	; 35
    87a0:	20 81       	ld	r18, Z
    87a2:	31 81       	ldd	r19, Z+1	; 0x01
    87a4:	42 81       	ldd	r20, Z+2	; 0x02
    87a6:	53 81       	ldd	r21, Z+3	; 0x03
    87a8:	8a 85       	ldd	r24, Y+10	; 0x0a
    87aa:	9b 85       	ldd	r25, Y+11	; 0x0b
    87ac:	ac 85       	ldd	r26, Y+12	; 0x0c
    87ae:	bd 85       	ldd	r27, Y+13	; 0x0d
    87b0:	80 95       	com	r24
    87b2:	90 95       	com	r25
    87b4:	a0 95       	com	r26
    87b6:	b0 95       	com	r27
    87b8:	ba 01       	movw	r22, r20
    87ba:	a9 01       	movw	r20, r18
    87bc:	48 23       	and	r20, r24
    87be:	59 23       	and	r21, r25
    87c0:	6a 23       	and	r22, r26
    87c2:	7b 23       	and	r23, r27
    87c4:	2d 81       	ldd	r18, Y+5	; 0x05
    87c6:	3e 81       	ldd	r19, Y+6	; 0x06
    87c8:	c8 01       	movw	r24, r16
    87ca:	88 0f       	add	r24, r24
    87cc:	99 1f       	adc	r25, r25
    87ce:	88 0f       	add	r24, r24
    87d0:	99 1f       	adc	r25, r25
    87d2:	82 0f       	add	r24, r18
    87d4:	93 1f       	adc	r25, r19
    87d6:	fc 01       	movw	r30, r24
    87d8:	b3 96       	adiw	r30, 0x23	; 35
    87da:	40 83       	st	Z, r20
    87dc:	51 83       	std	Z+1, r21	; 0x01
    87de:	62 83       	std	Z+2, r22	; 0x02
    87e0:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    87e2:	0f 90       	pop	r0
    87e4:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    87e6:	89 81       	ldd	r24, Y+1	; 0x01
    87e8:	9a 81       	ldd	r25, Y+2	; 0x02
    87ea:	ab 81       	ldd	r26, Y+3	; 0x03
    87ec:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    87ee:	bc 01       	movw	r22, r24
    87f0:	cd 01       	movw	r24, r26
    87f2:	2f 96       	adiw	r28, 0x0f	; 15
    87f4:	0f b6       	in	r0, 0x3f	; 63
    87f6:	f8 94       	cli
    87f8:	de bf       	out	0x3e, r29	; 62
    87fa:	0f be       	out	0x3f, r0	; 63
    87fc:	cd bf       	out	0x3d, r28	; 61
    87fe:	cf 91       	pop	r28
    8800:	df 91       	pop	r29
    8802:	1f 91       	pop	r17
    8804:	0f 91       	pop	r16
    8806:	08 95       	ret

00008808 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    8808:	df 93       	push	r29
    880a:	cf 93       	push	r28
    880c:	cd b7       	in	r28, 0x3d	; 61
    880e:	de b7       	in	r29, 0x3e	; 62
    8810:	29 97       	sbiw	r28, 0x09	; 9
    8812:	0f b6       	in	r0, 0x3f	; 63
    8814:	f8 94       	cli
    8816:	de bf       	out	0x3e, r29	; 62
    8818:	0f be       	out	0x3f, r0	; 63
    881a:	cd bf       	out	0x3d, r28	; 61
    881c:	98 87       	std	Y+8, r25	; 0x08
    881e:	8f 83       	std	Y+7, r24	; 0x07
    8820:	69 87       	std	Y+9, r22	; 0x09
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    8822:	80 91 5a 07 	lds	r24, 0x075A
    8826:	90 91 5b 07 	lds	r25, 0x075B
    882a:	9c 83       	std	Y+4, r25	; 0x04
    882c:	8b 83       	std	Y+3, r24	; 0x03
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    882e:	80 91 56 07 	lds	r24, 0x0756
    8832:	90 91 57 07 	lds	r25, 0x0757
    8836:	02 96       	adiw	r24, 0x02	; 2
    8838:	0e 94 c4 18 	call	0x3188	; 0x3188 <uxListRemove>
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    883c:	8f 81       	ldd	r24, Y+7	; 0x07
    883e:	98 85       	ldd	r25, Y+8	; 0x08
    8840:	2f ef       	ldi	r18, 0xFF	; 255
    8842:	8f 3f       	cpi	r24, 0xFF	; 255
    8844:	92 07       	cpc	r25, r18
    8846:	09 f0       	breq	.+2      	; 0x884a <prvAddCurrentTaskToDelayedList+0x42>
    8848:	40 c0       	rjmp	.+128    	; 0x88ca <prvAddCurrentTaskToDelayedList+0xc2>
    884a:	89 85       	ldd	r24, Y+9	; 0x09
    884c:	88 23       	and	r24, r24
    884e:	e9 f1       	breq	.+122    	; 0x88ca <prvAddCurrentTaskToDelayedList+0xc2>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    8850:	80 91 b5 07 	lds	r24, 0x07B5
    8854:	90 91 b6 07 	lds	r25, 0x07B6
    8858:	9a 83       	std	Y+2, r25	; 0x02
    885a:	89 83       	std	Y+1, r24	; 0x01
    885c:	e0 91 56 07 	lds	r30, 0x0756
    8860:	f0 91 57 07 	lds	r31, 0x0757
    8864:	89 81       	ldd	r24, Y+1	; 0x01
    8866:	9a 81       	ldd	r25, Y+2	; 0x02
    8868:	95 83       	std	Z+5, r25	; 0x05
    886a:	84 83       	std	Z+4, r24	; 0x04
    886c:	a0 91 56 07 	lds	r26, 0x0756
    8870:	b0 91 57 07 	lds	r27, 0x0757
    8874:	e9 81       	ldd	r30, Y+1	; 0x01
    8876:	fa 81       	ldd	r31, Y+2	; 0x02
    8878:	84 81       	ldd	r24, Z+4	; 0x04
    887a:	95 81       	ldd	r25, Z+5	; 0x05
    887c:	17 96       	adiw	r26, 0x07	; 7
    887e:	9c 93       	st	X, r25
    8880:	8e 93       	st	-X, r24
    8882:	16 97       	sbiw	r26, 0x06	; 6
    8884:	e9 81       	ldd	r30, Y+1	; 0x01
    8886:	fa 81       	ldd	r31, Y+2	; 0x02
    8888:	04 80       	ldd	r0, Z+4	; 0x04
    888a:	f5 81       	ldd	r31, Z+5	; 0x05
    888c:	e0 2d       	mov	r30, r0
    888e:	80 91 56 07 	lds	r24, 0x0756
    8892:	90 91 57 07 	lds	r25, 0x0757
    8896:	02 96       	adiw	r24, 0x02	; 2
    8898:	93 83       	std	Z+3, r25	; 0x03
    889a:	82 83       	std	Z+2, r24	; 0x02
    889c:	80 91 56 07 	lds	r24, 0x0756
    88a0:	90 91 57 07 	lds	r25, 0x0757
    88a4:	02 96       	adiw	r24, 0x02	; 2
    88a6:	e9 81       	ldd	r30, Y+1	; 0x01
    88a8:	fa 81       	ldd	r31, Y+2	; 0x02
    88aa:	95 83       	std	Z+5, r25	; 0x05
    88ac:	84 83       	std	Z+4, r24	; 0x04
    88ae:	e0 91 56 07 	lds	r30, 0x0756
    88b2:	f0 91 57 07 	lds	r31, 0x0757
    88b6:	84 eb       	ldi	r24, 0xB4	; 180
    88b8:	97 e0       	ldi	r25, 0x07	; 7
    88ba:	93 87       	std	Z+11, r25	; 0x0b
    88bc:	82 87       	std	Z+10, r24	; 0x0a
    88be:	80 91 b4 07 	lds	r24, 0x07B4
    88c2:	8f 5f       	subi	r24, 0xFF	; 255
    88c4:	80 93 b4 07 	sts	0x07B4, r24
    88c8:	43 c0       	rjmp	.+134    	; 0x8950 <prvAddCurrentTaskToDelayedList+0x148>
        else
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    88ca:	2b 81       	ldd	r18, Y+3	; 0x03
    88cc:	3c 81       	ldd	r19, Y+4	; 0x04
    88ce:	8f 81       	ldd	r24, Y+7	; 0x07
    88d0:	98 85       	ldd	r25, Y+8	; 0x08
    88d2:	82 0f       	add	r24, r18
    88d4:	93 1f       	adc	r25, r19
    88d6:	9e 83       	std	Y+6, r25	; 0x06
    88d8:	8d 83       	std	Y+5, r24	; 0x05

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    88da:	e0 91 56 07 	lds	r30, 0x0756
    88de:	f0 91 57 07 	lds	r31, 0x0757
    88e2:	8d 81       	ldd	r24, Y+5	; 0x05
    88e4:	9e 81       	ldd	r25, Y+6	; 0x06
    88e6:	93 83       	std	Z+3, r25	; 0x03
    88e8:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    88ea:	2d 81       	ldd	r18, Y+5	; 0x05
    88ec:	3e 81       	ldd	r19, Y+6	; 0x06
    88ee:	8b 81       	ldd	r24, Y+3	; 0x03
    88f0:	9c 81       	ldd	r25, Y+4	; 0x04
    88f2:	28 17       	cp	r18, r24
    88f4:	39 07       	cpc	r19, r25
    88f6:	70 f4       	brcc	.+28     	; 0x8914 <prvAddCurrentTaskToDelayedList+0x10c>
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    88f8:	80 91 a0 07 	lds	r24, 0x07A0
    88fc:	90 91 a1 07 	lds	r25, 0x07A1
    8900:	20 91 56 07 	lds	r18, 0x0756
    8904:	30 91 57 07 	lds	r19, 0x0757
    8908:	2e 5f       	subi	r18, 0xFE	; 254
    890a:	3f 4f       	sbci	r19, 0xFF	; 255
    890c:	b9 01       	movw	r22, r18
    890e:	0e 94 58 18 	call	0x30b0	; 0x30b0 <vListInsert>
    8912:	1e c0       	rjmp	.+60     	; 0x8950 <prvAddCurrentTaskToDelayedList+0x148>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    8914:	40 91 9e 07 	lds	r20, 0x079E
    8918:	50 91 9f 07 	lds	r21, 0x079F
    891c:	80 91 56 07 	lds	r24, 0x0756
    8920:	90 91 57 07 	lds	r25, 0x0757
    8924:	9c 01       	movw	r18, r24
    8926:	2e 5f       	subi	r18, 0xFE	; 254
    8928:	3f 4f       	sbci	r19, 0xFF	; 255
    892a:	ca 01       	movw	r24, r20
    892c:	b9 01       	movw	r22, r18
    892e:	0e 94 58 18 	call	0x30b0	; 0x30b0 <vListInsert>

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    8932:	20 91 63 07 	lds	r18, 0x0763
    8936:	30 91 64 07 	lds	r19, 0x0764
    893a:	8d 81       	ldd	r24, Y+5	; 0x05
    893c:	9e 81       	ldd	r25, Y+6	; 0x06
    893e:	82 17       	cp	r24, r18
    8940:	93 07       	cpc	r25, r19
    8942:	30 f4       	brcc	.+12     	; 0x8950 <prvAddCurrentTaskToDelayedList+0x148>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    8944:	8d 81       	ldd	r24, Y+5	; 0x05
    8946:	9e 81       	ldd	r25, Y+6	; 0x06
    8948:	90 93 64 07 	sts	0x0764, r25
    894c:	80 93 63 07 	sts	0x0763, r24

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    8950:	29 96       	adiw	r28, 0x09	; 9
    8952:	0f b6       	in	r0, 0x3f	; 63
    8954:	f8 94       	cli
    8956:	de bf       	out	0x3e, r29	; 62
    8958:	0f be       	out	0x3f, r0	; 63
    895a:	cd bf       	out	0x3d, r28	; 61
    895c:	cf 91       	pop	r28
    895e:	df 91       	pop	r29
    8960:	08 95       	ret

00008962 <Calculator_voidInit>:
u8 operations_arr_count=0;
s32 result=0;
u8 clear_flag;

void Calculator_voidInit(void)
{
    8962:	df 93       	push	r29
    8964:	cf 93       	push	r28
    8966:	cd b7       	in	r28, 0x3d	; 61
    8968:	de b7       	in	r29, 0x3e	; 62
}
    896a:	cf 91       	pop	r28
    896c:	df 91       	pop	r29
    896e:	08 95       	ret

00008970 <Calculator_voidGetString>:

void Calculator_voidGetString(void)
{
    8970:	df 93       	push	r29
    8972:	cf 93       	push	r28
    8974:	00 d0       	rcall	.+0      	; 0x8976 <Calculator_voidGetString+0x6>
    8976:	00 d0       	rcall	.+0      	; 0x8978 <Calculator_voidGetString+0x8>
    8978:	0f 92       	push	r0
    897a:	cd b7       	in	r28, 0x3d	; 61
    897c:	de b7       	in	r29, 0x3e	; 62
	static u8 op_flag=0;
	static u8 sign_flag=0;
	u8 key=KPD_u8GetPressedKey();
    897e:	0e 94 84 0c 	call	0x1908	; 0x1908 <KPD_u8GetPressedKey>
    8982:	8d 83       	std	Y+5, r24	; 0x05
	if(key!=0)
    8984:	8d 81       	ldd	r24, Y+5	; 0x05
    8986:	88 23       	and	r24, r24
    8988:	09 f4       	brne	.+2      	; 0x898c <Calculator_voidGetString+0x1c>
    898a:	a4 c1       	rjmp	.+840    	; 0x8cd4 <Calculator_voidGetString+0x364>
	{
		if(clear_flag==1)
    898c:	80 91 46 08 	lds	r24, 0x0846
    8990:	81 30       	cpi	r24, 0x01	; 1
    8992:	09 f0       	breq	.+2      	; 0x8996 <Calculator_voidGetString+0x26>
    8994:	5e c0       	rjmp	.+188    	; 0x8a52 <Calculator_voidGetString+0xe2>
		{
			clear_flag=0;
    8996:	10 92 46 08 	sts	0x0846, r1
			numbers_arr_count=0;
    899a:	10 92 0f 08 	sts	0x080F, r1
			operations_arr_count=0;
    899e:	10 92 10 08 	sts	0x0810, r1
			str_count=0;
    89a2:	10 92 bd 07 	sts	0x07BD, r1
			result=0;
    89a6:	10 92 11 08 	sts	0x0811, r1
    89aa:	10 92 12 08 	sts	0x0812, r1
    89ae:	10 92 13 08 	sts	0x0813, r1
    89b2:	10 92 14 08 	sts	0x0814, r1
			for(int i=0;str[i];i++)
    89b6:	1c 82       	std	Y+4, r1	; 0x04
    89b8:	1b 82       	std	Y+3, r1	; 0x03
    89ba:	0b c0       	rjmp	.+22     	; 0x89d2 <Calculator_voidGetString+0x62>
			{
				str[i]=0;
    89bc:	8b 81       	ldd	r24, Y+3	; 0x03
    89be:	9c 81       	ldd	r25, Y+4	; 0x04
    89c0:	fc 01       	movw	r30, r24
    89c2:	e2 5e       	subi	r30, 0xE2	; 226
    89c4:	f7 4f       	sbci	r31, 0xF7	; 247
    89c6:	10 82       	st	Z, r1
			clear_flag=0;
			numbers_arr_count=0;
			operations_arr_count=0;
			str_count=0;
			result=0;
			for(int i=0;str[i];i++)
    89c8:	8b 81       	ldd	r24, Y+3	; 0x03
    89ca:	9c 81       	ldd	r25, Y+4	; 0x04
    89cc:	01 96       	adiw	r24, 0x01	; 1
    89ce:	9c 83       	std	Y+4, r25	; 0x04
    89d0:	8b 83       	std	Y+3, r24	; 0x03
    89d2:	8b 81       	ldd	r24, Y+3	; 0x03
    89d4:	9c 81       	ldd	r25, Y+4	; 0x04
    89d6:	fc 01       	movw	r30, r24
    89d8:	e2 5e       	subi	r30, 0xE2	; 226
    89da:	f7 4f       	sbci	r31, 0xF7	; 247
    89dc:	80 81       	ld	r24, Z
    89de:	88 23       	and	r24, r24
    89e0:	69 f7       	brne	.-38     	; 0x89bc <Calculator_voidGetString+0x4c>
			{
				str[i]=0;
			}
			for (int i=0;i<20;i++)
    89e2:	1a 82       	std	Y+2, r1	; 0x02
    89e4:	19 82       	std	Y+1, r1	; 0x01
    89e6:	18 c0       	rjmp	.+48     	; 0x8a18 <Calculator_voidGetString+0xa8>
			{
				numbers_arr[i]=0;
    89e8:	89 81       	ldd	r24, Y+1	; 0x01
    89ea:	9a 81       	ldd	r25, Y+2	; 0x02
    89ec:	88 0f       	add	r24, r24
    89ee:	99 1f       	adc	r25, r25
    89f0:	88 0f       	add	r24, r24
    89f2:	99 1f       	adc	r25, r25
    89f4:	fc 01       	movw	r30, r24
    89f6:	e1 54       	subi	r30, 0x41	; 65
    89f8:	f8 4f       	sbci	r31, 0xF8	; 248
    89fa:	10 82       	st	Z, r1
    89fc:	11 82       	std	Z+1, r1	; 0x01
    89fe:	12 82       	std	Z+2, r1	; 0x02
    8a00:	13 82       	std	Z+3, r1	; 0x03
				operations_arr[i]=0;
    8a02:	89 81       	ldd	r24, Y+1	; 0x01
    8a04:	9a 81       	ldd	r25, Y+2	; 0x02
    8a06:	fc 01       	movw	r30, r24
    8a08:	e9 5b       	subi	r30, 0xB9	; 185
    8a0a:	f7 4f       	sbci	r31, 0xF7	; 247
    8a0c:	10 82       	st	Z, r1
			result=0;
			for(int i=0;str[i];i++)
			{
				str[i]=0;
			}
			for (int i=0;i<20;i++)
    8a0e:	89 81       	ldd	r24, Y+1	; 0x01
    8a10:	9a 81       	ldd	r25, Y+2	; 0x02
    8a12:	01 96       	adiw	r24, 0x01	; 1
    8a14:	9a 83       	std	Y+2, r25	; 0x02
    8a16:	89 83       	std	Y+1, r24	; 0x01
    8a18:	89 81       	ldd	r24, Y+1	; 0x01
    8a1a:	9a 81       	ldd	r25, Y+2	; 0x02
    8a1c:	84 31       	cpi	r24, 0x14	; 20
    8a1e:	91 05       	cpc	r25, r1
    8a20:	1c f3       	brlt	.-58     	; 0x89e8 <Calculator_voidGetString+0x78>
			{
				numbers_arr[i]=0;
				operations_arr[i]=0;
			}
			GoToXY(0,0);
    8a22:	80 e0       	ldi	r24, 0x00	; 0
    8a24:	60 e0       	ldi	r22, 0x00	; 0
    8a26:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
			LCD_SendString("                     ");
    8a2a:	85 e0       	ldi	r24, 0x05	; 5
    8a2c:	91 e0       	ldi	r25, 0x01	; 1
    8a2e:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
			GoToXY(1,0);
    8a32:	81 e0       	ldi	r24, 0x01	; 1
    8a34:	60 e0       	ldi	r22, 0x00	; 0
    8a36:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
			LCD_SendString("                     ");
    8a3a:	85 e0       	ldi	r24, 0x05	; 5
    8a3c:	91 e0       	ldi	r25, 0x01	; 1
    8a3e:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
			GoToXY(3,0);
    8a42:	83 e0       	ldi	r24, 0x03	; 3
    8a44:	60 e0       	ldi	r22, 0x00	; 0
    8a46:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
			LCD_SendString("                     ");
    8a4a:	85 e0       	ldi	r24, 0x05	; 5
    8a4c:	91 e0       	ldi	r25, 0x01	; 1
    8a4e:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
		}
		if (str_count==0)
    8a52:	80 91 bd 07 	lds	r24, 0x07BD
    8a56:	88 23       	and	r24, r24
    8a58:	59 f5       	brne	.+86     	; 0x8ab0 <Calculator_voidGetString+0x140>
		{
			if ((key>='0'&&key<='9'))
    8a5a:	8d 81       	ldd	r24, Y+5	; 0x05
    8a5c:	80 33       	cpi	r24, 0x30	; 48
    8a5e:	90 f0       	brcs	.+36     	; 0x8a84 <Calculator_voidGetString+0x114>
    8a60:	8d 81       	ldd	r24, Y+5	; 0x05
    8a62:	8a 33       	cpi	r24, 0x3A	; 58
    8a64:	78 f4       	brcc	.+30     	; 0x8a84 <Calculator_voidGetString+0x114>
			{
				str[str_count]=key;
    8a66:	80 91 bd 07 	lds	r24, 0x07BD
    8a6a:	88 2f       	mov	r24, r24
    8a6c:	90 e0       	ldi	r25, 0x00	; 0
    8a6e:	fc 01       	movw	r30, r24
    8a70:	e2 5e       	subi	r30, 0xE2	; 226
    8a72:	f7 4f       	sbci	r31, 0xF7	; 247
    8a74:	8d 81       	ldd	r24, Y+5	; 0x05
    8a76:	80 83       	st	Z, r24
				str_count++;
    8a78:	80 91 bd 07 	lds	r24, 0x07BD
    8a7c:	8f 5f       	subi	r24, 0xFF	; 255
    8a7e:	80 93 bd 07 	sts	0x07BD, r24
    8a82:	1e c1       	rjmp	.+572    	; 0x8cc0 <Calculator_voidGetString+0x350>
			}
			else if (key=='-')
    8a84:	8d 81       	ldd	r24, Y+5	; 0x05
    8a86:	8d 32       	cpi	r24, 0x2D	; 45
    8a88:	09 f0       	breq	.+2      	; 0x8a8c <Calculator_voidGetString+0x11c>
    8a8a:	1a c1       	rjmp	.+564    	; 0x8cc0 <Calculator_voidGetString+0x350>
			{
				str[str_count]=key;
    8a8c:	80 91 bd 07 	lds	r24, 0x07BD
    8a90:	88 2f       	mov	r24, r24
    8a92:	90 e0       	ldi	r25, 0x00	; 0
    8a94:	fc 01       	movw	r30, r24
    8a96:	e2 5e       	subi	r30, 0xE2	; 226
    8a98:	f7 4f       	sbci	r31, 0xF7	; 247
    8a9a:	8d 81       	ldd	r24, Y+5	; 0x05
    8a9c:	80 83       	st	Z, r24
				str_count++;
    8a9e:	80 91 bd 07 	lds	r24, 0x07BD
    8aa2:	8f 5f       	subi	r24, 0xFF	; 255
    8aa4:	80 93 bd 07 	sts	0x07BD, r24
				sign_flag=1;
    8aa8:	81 e0       	ldi	r24, 0x01	; 1
    8aaa:	80 93 15 08 	sts	0x0815, r24
    8aae:	08 c1       	rjmp	.+528    	; 0x8cc0 <Calculator_voidGetString+0x350>
			}
		}
		else if(str_count>0)
    8ab0:	80 91 bd 07 	lds	r24, 0x07BD
    8ab4:	88 23       	and	r24, r24
    8ab6:	09 f4       	brne	.+2      	; 0x8aba <Calculator_voidGetString+0x14a>
    8ab8:	03 c1       	rjmp	.+518    	; 0x8cc0 <Calculator_voidGetString+0x350>
		{
			if ((key>='0'&&key<='9'))
    8aba:	8d 81       	ldd	r24, Y+5	; 0x05
    8abc:	80 33       	cpi	r24, 0x30	; 48
    8abe:	b8 f0       	brcs	.+46     	; 0x8aee <Calculator_voidGetString+0x17e>
    8ac0:	8d 81       	ldd	r24, Y+5	; 0x05
    8ac2:	8a 33       	cpi	r24, 0x3A	; 58
    8ac4:	a0 f4       	brcc	.+40     	; 0x8aee <Calculator_voidGetString+0x17e>
			{
				str[str_count]=key;
    8ac6:	80 91 bd 07 	lds	r24, 0x07BD
    8aca:	88 2f       	mov	r24, r24
    8acc:	90 e0       	ldi	r25, 0x00	; 0
    8ace:	fc 01       	movw	r30, r24
    8ad0:	e2 5e       	subi	r30, 0xE2	; 226
    8ad2:	f7 4f       	sbci	r31, 0xF7	; 247
    8ad4:	8d 81       	ldd	r24, Y+5	; 0x05
    8ad6:	80 83       	st	Z, r24
				str_count++;
    8ad8:	80 91 bd 07 	lds	r24, 0x07BD
    8adc:	8f 5f       	subi	r24, 0xFF	; 255
    8ade:	80 93 bd 07 	sts	0x07BD, r24
				sign_flag=1;
    8ae2:	81 e0       	ldi	r24, 0x01	; 1
    8ae4:	80 93 15 08 	sts	0x0815, r24
				op_flag=0;
    8ae8:	10 92 16 08 	sts	0x0816, r1
    8aec:	e9 c0       	rjmp	.+466    	; 0x8cc0 <Calculator_voidGetString+0x350>
			}
			else if ((key=='/'||key=='*'||key=='-'||key=='+')&&op_flag==0)
    8aee:	8d 81       	ldd	r24, Y+5	; 0x05
    8af0:	8f 32       	cpi	r24, 0x2F	; 47
    8af2:	49 f0       	breq	.+18     	; 0x8b06 <Calculator_voidGetString+0x196>
    8af4:	8d 81       	ldd	r24, Y+5	; 0x05
    8af6:	8a 32       	cpi	r24, 0x2A	; 42
    8af8:	31 f0       	breq	.+12     	; 0x8b06 <Calculator_voidGetString+0x196>
    8afa:	8d 81       	ldd	r24, Y+5	; 0x05
    8afc:	8d 32       	cpi	r24, 0x2D	; 45
    8afe:	19 f0       	breq	.+6      	; 0x8b06 <Calculator_voidGetString+0x196>
    8b00:	8d 81       	ldd	r24, Y+5	; 0x05
    8b02:	8b 32       	cpi	r24, 0x2B	; 43
    8b04:	c1 f4       	brne	.+48     	; 0x8b36 <Calculator_voidGetString+0x1c6>
    8b06:	80 91 16 08 	lds	r24, 0x0816
    8b0a:	88 23       	and	r24, r24
    8b0c:	a1 f4       	brne	.+40     	; 0x8b36 <Calculator_voidGetString+0x1c6>
			{
				str[str_count]=key;
    8b0e:	80 91 bd 07 	lds	r24, 0x07BD
    8b12:	88 2f       	mov	r24, r24
    8b14:	90 e0       	ldi	r25, 0x00	; 0
    8b16:	fc 01       	movw	r30, r24
    8b18:	e2 5e       	subi	r30, 0xE2	; 226
    8b1a:	f7 4f       	sbci	r31, 0xF7	; 247
    8b1c:	8d 81       	ldd	r24, Y+5	; 0x05
    8b1e:	80 83       	st	Z, r24
				str_count++;
    8b20:	80 91 bd 07 	lds	r24, 0x07BD
    8b24:	8f 5f       	subi	r24, 0xFF	; 255
    8b26:	80 93 bd 07 	sts	0x07BD, r24
				op_flag=1;
    8b2a:	81 e0       	ldi	r24, 0x01	; 1
    8b2c:	80 93 16 08 	sts	0x0816, r24
				sign_flag=0;
    8b30:	10 92 15 08 	sts	0x0815, r1
    8b34:	c5 c0       	rjmp	.+394    	; 0x8cc0 <Calculator_voidGetString+0x350>
			}
			else if(sign_flag==0&&key=='-'&&op_flag==1)
    8b36:	80 91 15 08 	lds	r24, 0x0815
    8b3a:	88 23       	and	r24, r24
    8b3c:	c9 f4       	brne	.+50     	; 0x8b70 <Calculator_voidGetString+0x200>
    8b3e:	8d 81       	ldd	r24, Y+5	; 0x05
    8b40:	8d 32       	cpi	r24, 0x2D	; 45
    8b42:	b1 f4       	brne	.+44     	; 0x8b70 <Calculator_voidGetString+0x200>
    8b44:	80 91 16 08 	lds	r24, 0x0816
    8b48:	81 30       	cpi	r24, 0x01	; 1
    8b4a:	91 f4       	brne	.+36     	; 0x8b70 <Calculator_voidGetString+0x200>
			{
				str[str_count]=key;
    8b4c:	80 91 bd 07 	lds	r24, 0x07BD
    8b50:	88 2f       	mov	r24, r24
    8b52:	90 e0       	ldi	r25, 0x00	; 0
    8b54:	fc 01       	movw	r30, r24
    8b56:	e2 5e       	subi	r30, 0xE2	; 226
    8b58:	f7 4f       	sbci	r31, 0xF7	; 247
    8b5a:	8d 81       	ldd	r24, Y+5	; 0x05
    8b5c:	80 83       	st	Z, r24
				str_count++;
    8b5e:	80 91 bd 07 	lds	r24, 0x07BD
    8b62:	8f 5f       	subi	r24, 0xFF	; 255
    8b64:	80 93 bd 07 	sts	0x07BD, r24
				sign_flag=1;
    8b68:	81 e0       	ldi	r24, 0x01	; 1
    8b6a:	80 93 15 08 	sts	0x0815, r24
    8b6e:	a8 c0       	rjmp	.+336    	; 0x8cc0 <Calculator_voidGetString+0x350>
			}
			else if ((key=='/'||key=='*'||key=='-'||key=='+')&&op_flag==1&&sign_flag==0)
    8b70:	8d 81       	ldd	r24, Y+5	; 0x05
    8b72:	8f 32       	cpi	r24, 0x2F	; 47
    8b74:	49 f0       	breq	.+18     	; 0x8b88 <Calculator_voidGetString+0x218>
    8b76:	8d 81       	ldd	r24, Y+5	; 0x05
    8b78:	8a 32       	cpi	r24, 0x2A	; 42
    8b7a:	31 f0       	breq	.+12     	; 0x8b88 <Calculator_voidGetString+0x218>
    8b7c:	8d 81       	ldd	r24, Y+5	; 0x05
    8b7e:	8d 32       	cpi	r24, 0x2D	; 45
    8b80:	19 f0       	breq	.+6      	; 0x8b88 <Calculator_voidGetString+0x218>
    8b82:	8d 81       	ldd	r24, Y+5	; 0x05
    8b84:	8b 32       	cpi	r24, 0x2B	; 43
    8b86:	e1 f4       	brne	.+56     	; 0x8bc0 <Calculator_voidGetString+0x250>
    8b88:	80 91 16 08 	lds	r24, 0x0816
    8b8c:	81 30       	cpi	r24, 0x01	; 1
    8b8e:	c1 f4       	brne	.+48     	; 0x8bc0 <Calculator_voidGetString+0x250>
    8b90:	80 91 15 08 	lds	r24, 0x0815
    8b94:	88 23       	and	r24, r24
    8b96:	a1 f4       	brne	.+40     	; 0x8bc0 <Calculator_voidGetString+0x250>
			{
				str_count--;
    8b98:	80 91 bd 07 	lds	r24, 0x07BD
    8b9c:	81 50       	subi	r24, 0x01	; 1
    8b9e:	80 93 bd 07 	sts	0x07BD, r24
				str[str_count]=key;
    8ba2:	80 91 bd 07 	lds	r24, 0x07BD
    8ba6:	88 2f       	mov	r24, r24
    8ba8:	90 e0       	ldi	r25, 0x00	; 0
    8baa:	fc 01       	movw	r30, r24
    8bac:	e2 5e       	subi	r30, 0xE2	; 226
    8bae:	f7 4f       	sbci	r31, 0xF7	; 247
    8bb0:	8d 81       	ldd	r24, Y+5	; 0x05
    8bb2:	80 83       	st	Z, r24
				str_count++;
    8bb4:	80 91 bd 07 	lds	r24, 0x07BD
    8bb8:	8f 5f       	subi	r24, 0xFF	; 255
    8bba:	80 93 bd 07 	sts	0x07BD, r24
    8bbe:	80 c0       	rjmp	.+256    	; 0x8cc0 <Calculator_voidGetString+0x350>
			}
			else if (key=='c')
    8bc0:	8d 81       	ldd	r24, Y+5	; 0x05
    8bc2:	83 36       	cpi	r24, 0x63	; 99
    8bc4:	09 f0       	breq	.+2      	; 0x8bc8 <Calculator_voidGetString+0x258>
    8bc6:	7c c0       	rjmp	.+248    	; 0x8cc0 <Calculator_voidGetString+0x350>
			{
				str_count--;
    8bc8:	80 91 bd 07 	lds	r24, 0x07BD
    8bcc:	81 50       	subi	r24, 0x01	; 1
    8bce:	80 93 bd 07 	sts	0x07BD, r24
				str[str_count]=0;
    8bd2:	80 91 bd 07 	lds	r24, 0x07BD
    8bd6:	88 2f       	mov	r24, r24
    8bd8:	90 e0       	ldi	r25, 0x00	; 0
    8bda:	fc 01       	movw	r30, r24
    8bdc:	e2 5e       	subi	r30, 0xE2	; 226
    8bde:	f7 4f       	sbci	r31, 0xF7	; 247
    8be0:	10 82       	st	Z, r1
				if((str[str_count-2]=='*'||str[str_count-2]=='/'||str[str_count-2]=='-'||str[str_count-2]=='+')&&str[str_count-1]=='-')
    8be2:	80 91 bd 07 	lds	r24, 0x07BD
    8be6:	88 2f       	mov	r24, r24
    8be8:	90 e0       	ldi	r25, 0x00	; 0
    8bea:	02 97       	sbiw	r24, 0x02	; 2
    8bec:	fc 01       	movw	r30, r24
    8bee:	e2 5e       	subi	r30, 0xE2	; 226
    8bf0:	f7 4f       	sbci	r31, 0xF7	; 247
    8bf2:	80 81       	ld	r24, Z
    8bf4:	8a 32       	cpi	r24, 0x2A	; 42
    8bf6:	09 f1       	breq	.+66     	; 0x8c3a <Calculator_voidGetString+0x2ca>
    8bf8:	80 91 bd 07 	lds	r24, 0x07BD
    8bfc:	88 2f       	mov	r24, r24
    8bfe:	90 e0       	ldi	r25, 0x00	; 0
    8c00:	02 97       	sbiw	r24, 0x02	; 2
    8c02:	fc 01       	movw	r30, r24
    8c04:	e2 5e       	subi	r30, 0xE2	; 226
    8c06:	f7 4f       	sbci	r31, 0xF7	; 247
    8c08:	80 81       	ld	r24, Z
    8c0a:	8f 32       	cpi	r24, 0x2F	; 47
    8c0c:	b1 f0       	breq	.+44     	; 0x8c3a <Calculator_voidGetString+0x2ca>
    8c0e:	80 91 bd 07 	lds	r24, 0x07BD
    8c12:	88 2f       	mov	r24, r24
    8c14:	90 e0       	ldi	r25, 0x00	; 0
    8c16:	02 97       	sbiw	r24, 0x02	; 2
    8c18:	fc 01       	movw	r30, r24
    8c1a:	e2 5e       	subi	r30, 0xE2	; 226
    8c1c:	f7 4f       	sbci	r31, 0xF7	; 247
    8c1e:	80 81       	ld	r24, Z
    8c20:	8d 32       	cpi	r24, 0x2D	; 45
    8c22:	59 f0       	breq	.+22     	; 0x8c3a <Calculator_voidGetString+0x2ca>
    8c24:	80 91 bd 07 	lds	r24, 0x07BD
    8c28:	88 2f       	mov	r24, r24
    8c2a:	90 e0       	ldi	r25, 0x00	; 0
    8c2c:	02 97       	sbiw	r24, 0x02	; 2
    8c2e:	fc 01       	movw	r30, r24
    8c30:	e2 5e       	subi	r30, 0xE2	; 226
    8c32:	f7 4f       	sbci	r31, 0xF7	; 247
    8c34:	80 81       	ld	r24, Z
    8c36:	8b 32       	cpi	r24, 0x2B	; 43
    8c38:	91 f4       	brne	.+36     	; 0x8c5e <Calculator_voidGetString+0x2ee>
    8c3a:	80 91 bd 07 	lds	r24, 0x07BD
    8c3e:	88 2f       	mov	r24, r24
    8c40:	90 e0       	ldi	r25, 0x00	; 0
    8c42:	01 97       	sbiw	r24, 0x01	; 1
    8c44:	fc 01       	movw	r30, r24
    8c46:	e2 5e       	subi	r30, 0xE2	; 226
    8c48:	f7 4f       	sbci	r31, 0xF7	; 247
    8c4a:	80 81       	ld	r24, Z
    8c4c:	8d 32       	cpi	r24, 0x2D	; 45
    8c4e:	39 f4       	brne	.+14     	; 0x8c5e <Calculator_voidGetString+0x2ee>
				{
					sign_flag=1;
    8c50:	81 e0       	ldi	r24, 0x01	; 1
    8c52:	80 93 15 08 	sts	0x0815, r24
					op_flag=1;
    8c56:	81 e0       	ldi	r24, 0x01	; 1
    8c58:	80 93 16 08 	sts	0x0816, r24
    8c5c:	31 c0       	rjmp	.+98     	; 0x8cc0 <Calculator_voidGetString+0x350>
				}
				else if(str[str_count-1]=='*'||str[str_count-1]=='/'||str[str_count-1]=='-'||str[str_count-1]=='+')
    8c5e:	80 91 bd 07 	lds	r24, 0x07BD
    8c62:	88 2f       	mov	r24, r24
    8c64:	90 e0       	ldi	r25, 0x00	; 0
    8c66:	01 97       	sbiw	r24, 0x01	; 1
    8c68:	fc 01       	movw	r30, r24
    8c6a:	e2 5e       	subi	r30, 0xE2	; 226
    8c6c:	f7 4f       	sbci	r31, 0xF7	; 247
    8c6e:	80 81       	ld	r24, Z
    8c70:	8a 32       	cpi	r24, 0x2A	; 42
    8c72:	09 f1       	breq	.+66     	; 0x8cb6 <Calculator_voidGetString+0x346>
    8c74:	80 91 bd 07 	lds	r24, 0x07BD
    8c78:	88 2f       	mov	r24, r24
    8c7a:	90 e0       	ldi	r25, 0x00	; 0
    8c7c:	01 97       	sbiw	r24, 0x01	; 1
    8c7e:	fc 01       	movw	r30, r24
    8c80:	e2 5e       	subi	r30, 0xE2	; 226
    8c82:	f7 4f       	sbci	r31, 0xF7	; 247
    8c84:	80 81       	ld	r24, Z
    8c86:	8f 32       	cpi	r24, 0x2F	; 47
    8c88:	b1 f0       	breq	.+44     	; 0x8cb6 <Calculator_voidGetString+0x346>
    8c8a:	80 91 bd 07 	lds	r24, 0x07BD
    8c8e:	88 2f       	mov	r24, r24
    8c90:	90 e0       	ldi	r25, 0x00	; 0
    8c92:	01 97       	sbiw	r24, 0x01	; 1
    8c94:	fc 01       	movw	r30, r24
    8c96:	e2 5e       	subi	r30, 0xE2	; 226
    8c98:	f7 4f       	sbci	r31, 0xF7	; 247
    8c9a:	80 81       	ld	r24, Z
    8c9c:	8d 32       	cpi	r24, 0x2D	; 45
    8c9e:	59 f0       	breq	.+22     	; 0x8cb6 <Calculator_voidGetString+0x346>
    8ca0:	80 91 bd 07 	lds	r24, 0x07BD
    8ca4:	88 2f       	mov	r24, r24
    8ca6:	90 e0       	ldi	r25, 0x00	; 0
    8ca8:	01 97       	sbiw	r24, 0x01	; 1
    8caa:	fc 01       	movw	r30, r24
    8cac:	e2 5e       	subi	r30, 0xE2	; 226
    8cae:	f7 4f       	sbci	r31, 0xF7	; 247
    8cb0:	80 81       	ld	r24, Z
    8cb2:	8b 32       	cpi	r24, 0x2B	; 43
    8cb4:	29 f4       	brne	.+10     	; 0x8cc0 <Calculator_voidGetString+0x350>
				{
					sign_flag=0;
    8cb6:	10 92 15 08 	sts	0x0815, r1
					op_flag=1;
    8cba:	81 e0       	ldi	r24, 0x01	; 1
    8cbc:	80 93 16 08 	sts	0x0816, r24
				
				
			}
			
		}
		if(str_count==40||key=='=')
    8cc0:	80 91 bd 07 	lds	r24, 0x07BD
    8cc4:	88 32       	cpi	r24, 0x28	; 40
    8cc6:	19 f0       	breq	.+6      	; 0x8cce <Calculator_voidGetString+0x35e>
    8cc8:	8d 81       	ldd	r24, Y+5	; 0x05
    8cca:	8d 33       	cpi	r24, 0x3D	; 61
    8ccc:	19 f4       	brne	.+6      	; 0x8cd4 <Calculator_voidGetString+0x364>
		{
			eq_flag=1;
    8cce:	81 e0       	ldi	r24, 0x01	; 1
    8cd0:	80 93 be 07 	sts	0x07BE, r24
		}
		
	}
}
    8cd4:	0f 90       	pop	r0
    8cd6:	0f 90       	pop	r0
    8cd8:	0f 90       	pop	r0
    8cda:	0f 90       	pop	r0
    8cdc:	0f 90       	pop	r0
    8cde:	cf 91       	pop	r28
    8ce0:	df 91       	pop	r29
    8ce2:	08 95       	ret

00008ce4 <Calculator_voidAnalysisString>:

void Calculator_voidAnalysisString(void)
{
    8ce4:	0f 93       	push	r16
    8ce6:	1f 93       	push	r17
    8ce8:	df 93       	push	r29
    8cea:	cf 93       	push	r28
    8cec:	00 d0       	rcall	.+0      	; 0x8cee <Calculator_voidAnalysisString+0xa>
    8cee:	00 d0       	rcall	.+0      	; 0x8cf0 <Calculator_voidAnalysisString+0xc>
    8cf0:	00 d0       	rcall	.+0      	; 0x8cf2 <Calculator_voidAnalysisString+0xe>
    8cf2:	cd b7       	in	r28, 0x3d	; 61
    8cf4:	de b7       	in	r29, 0x3e	; 62
	s32 sign_flag=0;
    8cf6:	1b 82       	std	Y+3, r1	; 0x03
    8cf8:	1c 82       	std	Y+4, r1	; 0x04
    8cfa:	1d 82       	std	Y+5, r1	; 0x05
    8cfc:	1e 82       	std	Y+6, r1	; 0x06
	for (int i=0;i<str_count;i++)
    8cfe:	1a 82       	std	Y+2, r1	; 0x02
    8d00:	19 82       	std	Y+1, r1	; 0x01
    8d02:	07 c1       	rjmp	.+526    	; 0x8f12 <Calculator_voidAnalysisString+0x22e>
	{
		if(str[i]=='-'&&i==0)
    8d04:	89 81       	ldd	r24, Y+1	; 0x01
    8d06:	9a 81       	ldd	r25, Y+2	; 0x02
    8d08:	fc 01       	movw	r30, r24
    8d0a:	e2 5e       	subi	r30, 0xE2	; 226
    8d0c:	f7 4f       	sbci	r31, 0xF7	; 247
    8d0e:	80 81       	ld	r24, Z
    8d10:	8d 32       	cpi	r24, 0x2D	; 45
    8d12:	69 f4       	brne	.+26     	; 0x8d2e <Calculator_voidAnalysisString+0x4a>
    8d14:	89 81       	ldd	r24, Y+1	; 0x01
    8d16:	9a 81       	ldd	r25, Y+2	; 0x02
    8d18:	00 97       	sbiw	r24, 0x00	; 0
    8d1a:	49 f4       	brne	.+18     	; 0x8d2e <Calculator_voidAnalysisString+0x4a>
		{
			sign_flag=1;
    8d1c:	81 e0       	ldi	r24, 0x01	; 1
    8d1e:	90 e0       	ldi	r25, 0x00	; 0
    8d20:	a0 e0       	ldi	r26, 0x00	; 0
    8d22:	b0 e0       	ldi	r27, 0x00	; 0
    8d24:	8b 83       	std	Y+3, r24	; 0x03
    8d26:	9c 83       	std	Y+4, r25	; 0x04
    8d28:	ad 83       	std	Y+5, r26	; 0x05
    8d2a:	be 83       	std	Y+6, r27	; 0x06
    8d2c:	ed c0       	rjmp	.+474    	; 0x8f08 <Calculator_voidAnalysisString+0x224>
		}
		else if ((str[i]=='-')&&(str[i-1]=='*'||str[i-1]=='/'||str[i-1]=='-'||str[i-1]=='+'))
    8d2e:	89 81       	ldd	r24, Y+1	; 0x01
    8d30:	9a 81       	ldd	r25, Y+2	; 0x02
    8d32:	fc 01       	movw	r30, r24
    8d34:	e2 5e       	subi	r30, 0xE2	; 226
    8d36:	f7 4f       	sbci	r31, 0xF7	; 247
    8d38:	80 81       	ld	r24, Z
    8d3a:	8d 32       	cpi	r24, 0x2D	; 45
    8d3c:	69 f5       	brne	.+90     	; 0x8d98 <Calculator_voidAnalysisString+0xb4>
    8d3e:	89 81       	ldd	r24, Y+1	; 0x01
    8d40:	9a 81       	ldd	r25, Y+2	; 0x02
    8d42:	01 97       	sbiw	r24, 0x01	; 1
    8d44:	fc 01       	movw	r30, r24
    8d46:	e2 5e       	subi	r30, 0xE2	; 226
    8d48:	f7 4f       	sbci	r31, 0xF7	; 247
    8d4a:	80 81       	ld	r24, Z
    8d4c:	8a 32       	cpi	r24, 0x2A	; 42
    8d4e:	d9 f0       	breq	.+54     	; 0x8d86 <Calculator_voidAnalysisString+0xa2>
    8d50:	89 81       	ldd	r24, Y+1	; 0x01
    8d52:	9a 81       	ldd	r25, Y+2	; 0x02
    8d54:	01 97       	sbiw	r24, 0x01	; 1
    8d56:	fc 01       	movw	r30, r24
    8d58:	e2 5e       	subi	r30, 0xE2	; 226
    8d5a:	f7 4f       	sbci	r31, 0xF7	; 247
    8d5c:	80 81       	ld	r24, Z
    8d5e:	8f 32       	cpi	r24, 0x2F	; 47
    8d60:	91 f0       	breq	.+36     	; 0x8d86 <Calculator_voidAnalysisString+0xa2>
    8d62:	89 81       	ldd	r24, Y+1	; 0x01
    8d64:	9a 81       	ldd	r25, Y+2	; 0x02
    8d66:	01 97       	sbiw	r24, 0x01	; 1
    8d68:	fc 01       	movw	r30, r24
    8d6a:	e2 5e       	subi	r30, 0xE2	; 226
    8d6c:	f7 4f       	sbci	r31, 0xF7	; 247
    8d6e:	80 81       	ld	r24, Z
    8d70:	8d 32       	cpi	r24, 0x2D	; 45
    8d72:	49 f0       	breq	.+18     	; 0x8d86 <Calculator_voidAnalysisString+0xa2>
    8d74:	89 81       	ldd	r24, Y+1	; 0x01
    8d76:	9a 81       	ldd	r25, Y+2	; 0x02
    8d78:	01 97       	sbiw	r24, 0x01	; 1
    8d7a:	fc 01       	movw	r30, r24
    8d7c:	e2 5e       	subi	r30, 0xE2	; 226
    8d7e:	f7 4f       	sbci	r31, 0xF7	; 247
    8d80:	80 81       	ld	r24, Z
    8d82:	8b 32       	cpi	r24, 0x2B	; 43
    8d84:	49 f4       	brne	.+18     	; 0x8d98 <Calculator_voidAnalysisString+0xb4>
		{
			sign_flag=1;
    8d86:	81 e0       	ldi	r24, 0x01	; 1
    8d88:	90 e0       	ldi	r25, 0x00	; 0
    8d8a:	a0 e0       	ldi	r26, 0x00	; 0
    8d8c:	b0 e0       	ldi	r27, 0x00	; 0
    8d8e:	8b 83       	std	Y+3, r24	; 0x03
    8d90:	9c 83       	std	Y+4, r25	; 0x04
    8d92:	ad 83       	std	Y+5, r26	; 0x05
    8d94:	be 83       	std	Y+6, r27	; 0x06
    8d96:	b8 c0       	rjmp	.+368    	; 0x8f08 <Calculator_voidAnalysisString+0x224>
		}
		else if (str[i]=='*'||str[i]=='/'||str[i]=='+'||str[i]=='-')
    8d98:	89 81       	ldd	r24, Y+1	; 0x01
    8d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    8d9c:	fc 01       	movw	r30, r24
    8d9e:	e2 5e       	subi	r30, 0xE2	; 226
    8da0:	f7 4f       	sbci	r31, 0xF7	; 247
    8da2:	80 81       	ld	r24, Z
    8da4:	8a 32       	cpi	r24, 0x2A	; 42
    8da6:	c9 f0       	breq	.+50     	; 0x8dda <Calculator_voidAnalysisString+0xf6>
    8da8:	89 81       	ldd	r24, Y+1	; 0x01
    8daa:	9a 81       	ldd	r25, Y+2	; 0x02
    8dac:	fc 01       	movw	r30, r24
    8dae:	e2 5e       	subi	r30, 0xE2	; 226
    8db0:	f7 4f       	sbci	r31, 0xF7	; 247
    8db2:	80 81       	ld	r24, Z
    8db4:	8f 32       	cpi	r24, 0x2F	; 47
    8db6:	89 f0       	breq	.+34     	; 0x8dda <Calculator_voidAnalysisString+0xf6>
    8db8:	89 81       	ldd	r24, Y+1	; 0x01
    8dba:	9a 81       	ldd	r25, Y+2	; 0x02
    8dbc:	fc 01       	movw	r30, r24
    8dbe:	e2 5e       	subi	r30, 0xE2	; 226
    8dc0:	f7 4f       	sbci	r31, 0xF7	; 247
    8dc2:	80 81       	ld	r24, Z
    8dc4:	8b 32       	cpi	r24, 0x2B	; 43
    8dc6:	49 f0       	breq	.+18     	; 0x8dda <Calculator_voidAnalysisString+0xf6>
    8dc8:	89 81       	ldd	r24, Y+1	; 0x01
    8dca:	9a 81       	ldd	r25, Y+2	; 0x02
    8dcc:	fc 01       	movw	r30, r24
    8dce:	e2 5e       	subi	r30, 0xE2	; 226
    8dd0:	f7 4f       	sbci	r31, 0xF7	; 247
    8dd2:	80 81       	ld	r24, Z
    8dd4:	8d 32       	cpi	r24, 0x2D	; 45
    8dd6:	09 f0       	breq	.+2      	; 0x8dda <Calculator_voidAnalysisString+0xf6>
    8dd8:	4c c0       	rjmp	.+152    	; 0x8e72 <Calculator_voidAnalysisString+0x18e>
		{
			operations_arr[operations_arr_count]=str[i];
    8dda:	80 91 10 08 	lds	r24, 0x0810
    8dde:	28 2f       	mov	r18, r24
    8de0:	30 e0       	ldi	r19, 0x00	; 0
    8de2:	89 81       	ldd	r24, Y+1	; 0x01
    8de4:	9a 81       	ldd	r25, Y+2	; 0x02
    8de6:	fc 01       	movw	r30, r24
    8de8:	e2 5e       	subi	r30, 0xE2	; 226
    8dea:	f7 4f       	sbci	r31, 0xF7	; 247
    8dec:	80 81       	ld	r24, Z
    8dee:	f9 01       	movw	r30, r18
    8df0:	e9 5b       	subi	r30, 0xB9	; 185
    8df2:	f7 4f       	sbci	r31, 0xF7	; 247
    8df4:	80 83       	st	Z, r24
			if (sign_flag==1)
    8df6:	8b 81       	ldd	r24, Y+3	; 0x03
    8df8:	9c 81       	ldd	r25, Y+4	; 0x04
    8dfa:	ad 81       	ldd	r26, Y+5	; 0x05
    8dfc:	be 81       	ldd	r27, Y+6	; 0x06
    8dfe:	81 30       	cpi	r24, 0x01	; 1
    8e00:	91 05       	cpc	r25, r1
    8e02:	a1 05       	cpc	r26, r1
    8e04:	b1 05       	cpc	r27, r1
    8e06:	51 f5       	brne	.+84     	; 0x8e5c <Calculator_voidAnalysisString+0x178>
			{
				numbers_arr[numbers_arr_count]=numbers_arr[numbers_arr_count]*-1;
    8e08:	80 91 0f 08 	lds	r24, 0x080F
    8e0c:	68 2f       	mov	r22, r24
    8e0e:	70 e0       	ldi	r23, 0x00	; 0
    8e10:	80 91 0f 08 	lds	r24, 0x080F
    8e14:	88 2f       	mov	r24, r24
    8e16:	90 e0       	ldi	r25, 0x00	; 0
    8e18:	88 0f       	add	r24, r24
    8e1a:	99 1f       	adc	r25, r25
    8e1c:	88 0f       	add	r24, r24
    8e1e:	99 1f       	adc	r25, r25
    8e20:	fc 01       	movw	r30, r24
    8e22:	e1 54       	subi	r30, 0x41	; 65
    8e24:	f8 4f       	sbci	r31, 0xF8	; 248
    8e26:	80 81       	ld	r24, Z
    8e28:	91 81       	ldd	r25, Z+1	; 0x01
    8e2a:	a2 81       	ldd	r26, Z+2	; 0x02
    8e2c:	b3 81       	ldd	r27, Z+3	; 0x03
    8e2e:	22 27       	eor	r18, r18
    8e30:	33 27       	eor	r19, r19
    8e32:	a9 01       	movw	r20, r18
    8e34:	28 1b       	sub	r18, r24
    8e36:	39 0b       	sbc	r19, r25
    8e38:	4a 0b       	sbc	r20, r26
    8e3a:	5b 0b       	sbc	r21, r27
    8e3c:	cb 01       	movw	r24, r22
    8e3e:	88 0f       	add	r24, r24
    8e40:	99 1f       	adc	r25, r25
    8e42:	88 0f       	add	r24, r24
    8e44:	99 1f       	adc	r25, r25
    8e46:	fc 01       	movw	r30, r24
    8e48:	e1 54       	subi	r30, 0x41	; 65
    8e4a:	f8 4f       	sbci	r31, 0xF8	; 248
    8e4c:	20 83       	st	Z, r18
    8e4e:	31 83       	std	Z+1, r19	; 0x01
    8e50:	42 83       	std	Z+2, r20	; 0x02
    8e52:	53 83       	std	Z+3, r21	; 0x03
				sign_flag=0;
    8e54:	1b 82       	std	Y+3, r1	; 0x03
    8e56:	1c 82       	std	Y+4, r1	; 0x04
    8e58:	1d 82       	std	Y+5, r1	; 0x05
    8e5a:	1e 82       	std	Y+6, r1	; 0x06
			}
			operations_arr_count++;
    8e5c:	80 91 10 08 	lds	r24, 0x0810
    8e60:	8f 5f       	subi	r24, 0xFF	; 255
    8e62:	80 93 10 08 	sts	0x0810, r24
			numbers_arr_count++;
    8e66:	80 91 0f 08 	lds	r24, 0x080F
    8e6a:	8f 5f       	subi	r24, 0xFF	; 255
    8e6c:	80 93 0f 08 	sts	0x080F, r24
    8e70:	4b c0       	rjmp	.+150    	; 0x8f08 <Calculator_voidAnalysisString+0x224>
		}
		else if (str[i]>='0'&&str[i]<='9')
    8e72:	89 81       	ldd	r24, Y+1	; 0x01
    8e74:	9a 81       	ldd	r25, Y+2	; 0x02
    8e76:	fc 01       	movw	r30, r24
    8e78:	e2 5e       	subi	r30, 0xE2	; 226
    8e7a:	f7 4f       	sbci	r31, 0xF7	; 247
    8e7c:	80 81       	ld	r24, Z
    8e7e:	80 33       	cpi	r24, 0x30	; 48
    8e80:	08 f4       	brcc	.+2      	; 0x8e84 <Calculator_voidAnalysisString+0x1a0>
    8e82:	42 c0       	rjmp	.+132    	; 0x8f08 <Calculator_voidAnalysisString+0x224>
    8e84:	89 81       	ldd	r24, Y+1	; 0x01
    8e86:	9a 81       	ldd	r25, Y+2	; 0x02
    8e88:	fc 01       	movw	r30, r24
    8e8a:	e2 5e       	subi	r30, 0xE2	; 226
    8e8c:	f7 4f       	sbci	r31, 0xF7	; 247
    8e8e:	80 81       	ld	r24, Z
    8e90:	8a 33       	cpi	r24, 0x3A	; 58
    8e92:	d0 f5       	brcc	.+116    	; 0x8f08 <Calculator_voidAnalysisString+0x224>
		{
			numbers_arr[numbers_arr_count]=(((s32)numbers_arr[numbers_arr_count]*(s32)10)+(s32)(str[i]-'0'));
    8e94:	80 91 0f 08 	lds	r24, 0x080F
    8e98:	08 2f       	mov	r16, r24
    8e9a:	10 e0       	ldi	r17, 0x00	; 0
    8e9c:	80 91 0f 08 	lds	r24, 0x080F
    8ea0:	88 2f       	mov	r24, r24
    8ea2:	90 e0       	ldi	r25, 0x00	; 0
    8ea4:	88 0f       	add	r24, r24
    8ea6:	99 1f       	adc	r25, r25
    8ea8:	88 0f       	add	r24, r24
    8eaa:	99 1f       	adc	r25, r25
    8eac:	fc 01       	movw	r30, r24
    8eae:	e1 54       	subi	r30, 0x41	; 65
    8eb0:	f8 4f       	sbci	r31, 0xF8	; 248
    8eb2:	80 81       	ld	r24, Z
    8eb4:	91 81       	ldd	r25, Z+1	; 0x01
    8eb6:	a2 81       	ldd	r26, Z+2	; 0x02
    8eb8:	b3 81       	ldd	r27, Z+3	; 0x03
    8eba:	2a e0       	ldi	r18, 0x0A	; 10
    8ebc:	30 e0       	ldi	r19, 0x00	; 0
    8ebe:	40 e0       	ldi	r20, 0x00	; 0
    8ec0:	50 e0       	ldi	r21, 0x00	; 0
    8ec2:	bc 01       	movw	r22, r24
    8ec4:	cd 01       	movw	r24, r26
    8ec6:	0e 94 cc 4c 	call	0x9998	; 0x9998 <__mulsi3>
    8eca:	9b 01       	movw	r18, r22
    8ecc:	ac 01       	movw	r20, r24
    8ece:	89 81       	ldd	r24, Y+1	; 0x01
    8ed0:	9a 81       	ldd	r25, Y+2	; 0x02
    8ed2:	fc 01       	movw	r30, r24
    8ed4:	e2 5e       	subi	r30, 0xE2	; 226
    8ed6:	f7 4f       	sbci	r31, 0xF7	; 247
    8ed8:	80 81       	ld	r24, Z
    8eda:	88 2f       	mov	r24, r24
    8edc:	90 e0       	ldi	r25, 0x00	; 0
    8ede:	c0 97       	sbiw	r24, 0x30	; 48
    8ee0:	aa 27       	eor	r26, r26
    8ee2:	97 fd       	sbrc	r25, 7
    8ee4:	a0 95       	com	r26
    8ee6:	ba 2f       	mov	r27, r26
    8ee8:	28 0f       	add	r18, r24
    8eea:	39 1f       	adc	r19, r25
    8eec:	4a 1f       	adc	r20, r26
    8eee:	5b 1f       	adc	r21, r27
    8ef0:	c8 01       	movw	r24, r16
    8ef2:	88 0f       	add	r24, r24
    8ef4:	99 1f       	adc	r25, r25
    8ef6:	88 0f       	add	r24, r24
    8ef8:	99 1f       	adc	r25, r25
    8efa:	fc 01       	movw	r30, r24
    8efc:	e1 54       	subi	r30, 0x41	; 65
    8efe:	f8 4f       	sbci	r31, 0xF8	; 248
    8f00:	20 83       	st	Z, r18
    8f02:	31 83       	std	Z+1, r19	; 0x01
    8f04:	42 83       	std	Z+2, r20	; 0x02
    8f06:	53 83       	std	Z+3, r21	; 0x03
}

void Calculator_voidAnalysisString(void)
{
	s32 sign_flag=0;
	for (int i=0;i<str_count;i++)
    8f08:	89 81       	ldd	r24, Y+1	; 0x01
    8f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    8f0c:	01 96       	adiw	r24, 0x01	; 1
    8f0e:	9a 83       	std	Y+2, r25	; 0x02
    8f10:	89 83       	std	Y+1, r24	; 0x01
    8f12:	80 91 bd 07 	lds	r24, 0x07BD
    8f16:	28 2f       	mov	r18, r24
    8f18:	30 e0       	ldi	r19, 0x00	; 0
    8f1a:	89 81       	ldd	r24, Y+1	; 0x01
    8f1c:	9a 81       	ldd	r25, Y+2	; 0x02
    8f1e:	82 17       	cp	r24, r18
    8f20:	93 07       	cpc	r25, r19
    8f22:	0c f4       	brge	.+2      	; 0x8f26 <Calculator_voidAnalysisString+0x242>
    8f24:	ef ce       	rjmp	.-546    	; 0x8d04 <Calculator_voidAnalysisString+0x20>
		{
			numbers_arr[numbers_arr_count]=(((s32)numbers_arr[numbers_arr_count]*(s32)10)+(s32)(str[i]-'0'));
		}

	}
	if (sign_flag==1)
    8f26:	8b 81       	ldd	r24, Y+3	; 0x03
    8f28:	9c 81       	ldd	r25, Y+4	; 0x04
    8f2a:	ad 81       	ldd	r26, Y+5	; 0x05
    8f2c:	be 81       	ldd	r27, Y+6	; 0x06
    8f2e:	81 30       	cpi	r24, 0x01	; 1
    8f30:	91 05       	cpc	r25, r1
    8f32:	a1 05       	cpc	r26, r1
    8f34:	b1 05       	cpc	r27, r1
    8f36:	51 f5       	brne	.+84     	; 0x8f8c <Calculator_voidAnalysisString+0x2a8>
	{
		numbers_arr[numbers_arr_count]=numbers_arr[numbers_arr_count]*-1;
    8f38:	80 91 0f 08 	lds	r24, 0x080F
    8f3c:	68 2f       	mov	r22, r24
    8f3e:	70 e0       	ldi	r23, 0x00	; 0
    8f40:	80 91 0f 08 	lds	r24, 0x080F
    8f44:	88 2f       	mov	r24, r24
    8f46:	90 e0       	ldi	r25, 0x00	; 0
    8f48:	88 0f       	add	r24, r24
    8f4a:	99 1f       	adc	r25, r25
    8f4c:	88 0f       	add	r24, r24
    8f4e:	99 1f       	adc	r25, r25
    8f50:	fc 01       	movw	r30, r24
    8f52:	e1 54       	subi	r30, 0x41	; 65
    8f54:	f8 4f       	sbci	r31, 0xF8	; 248
    8f56:	80 81       	ld	r24, Z
    8f58:	91 81       	ldd	r25, Z+1	; 0x01
    8f5a:	a2 81       	ldd	r26, Z+2	; 0x02
    8f5c:	b3 81       	ldd	r27, Z+3	; 0x03
    8f5e:	22 27       	eor	r18, r18
    8f60:	33 27       	eor	r19, r19
    8f62:	a9 01       	movw	r20, r18
    8f64:	28 1b       	sub	r18, r24
    8f66:	39 0b       	sbc	r19, r25
    8f68:	4a 0b       	sbc	r20, r26
    8f6a:	5b 0b       	sbc	r21, r27
    8f6c:	cb 01       	movw	r24, r22
    8f6e:	88 0f       	add	r24, r24
    8f70:	99 1f       	adc	r25, r25
    8f72:	88 0f       	add	r24, r24
    8f74:	99 1f       	adc	r25, r25
    8f76:	fc 01       	movw	r30, r24
    8f78:	e1 54       	subi	r30, 0x41	; 65
    8f7a:	f8 4f       	sbci	r31, 0xF8	; 248
    8f7c:	20 83       	st	Z, r18
    8f7e:	31 83       	std	Z+1, r19	; 0x01
    8f80:	42 83       	std	Z+2, r20	; 0x02
    8f82:	53 83       	std	Z+3, r21	; 0x03
		sign_flag=0;
    8f84:	1b 82       	std	Y+3, r1	; 0x03
    8f86:	1c 82       	std	Y+4, r1	; 0x04
    8f88:	1d 82       	std	Y+5, r1	; 0x05
    8f8a:	1e 82       	std	Y+6, r1	; 0x06
	}
		
}
    8f8c:	26 96       	adiw	r28, 0x06	; 6
    8f8e:	0f b6       	in	r0, 0x3f	; 63
    8f90:	f8 94       	cli
    8f92:	de bf       	out	0x3e, r29	; 62
    8f94:	0f be       	out	0x3f, r0	; 63
    8f96:	cd bf       	out	0x3d, r28	; 61
    8f98:	cf 91       	pop	r28
    8f9a:	df 91       	pop	r29
    8f9c:	1f 91       	pop	r17
    8f9e:	0f 91       	pop	r16
    8fa0:	08 95       	ret

00008fa2 <Calculator_voidCalculate>:

void Calculator_voidCalculate(void)
{
    8fa2:	cf 92       	push	r12
    8fa4:	df 92       	push	r13
    8fa6:	ef 92       	push	r14
    8fa8:	ff 92       	push	r15
    8faa:	0f 93       	push	r16
    8fac:	1f 93       	push	r17
    8fae:	df 93       	push	r29
    8fb0:	cf 93       	push	r28
    8fb2:	00 d0       	rcall	.+0      	; 0x8fb4 <Calculator_voidCalculate+0x12>
    8fb4:	00 d0       	rcall	.+0      	; 0x8fb6 <Calculator_voidCalculate+0x14>
    8fb6:	00 d0       	rcall	.+0      	; 0x8fb8 <Calculator_voidCalculate+0x16>
    8fb8:	cd b7       	in	r28, 0x3d	; 61
    8fba:	de b7       	in	r29, 0x3e	; 62
	s8 index=-1;
    8fbc:	8f ef       	ldi	r24, 0xFF	; 255
    8fbe:	8e 83       	std	Y+6, r24	; 0x06
	u8 switch_flag=0;
    8fc0:	1d 82       	std	Y+5, r1	; 0x05
    8fc2:	77 c1       	rjmp	.+750    	; 0x92b2 <Calculator_voidCalculate+0x310>
	while(operations_arr_count!=0)
	{
		if (switch_flag==0)
    8fc4:	8d 81       	ldd	r24, Y+5	; 0x05
    8fc6:	88 23       	and	r24, r24
    8fc8:	09 f0       	breq	.+2      	; 0x8fcc <Calculator_voidCalculate+0x2a>
    8fca:	98 c0       	rjmp	.+304    	; 0x90fc <Calculator_voidCalculate+0x15a>
		{
			for (u8 i=0;i<operations_arr_count;i++)
    8fcc:	1c 82       	std	Y+4, r1	; 0x04
    8fce:	8f c0       	rjmp	.+286    	; 0x90ee <Calculator_voidCalculate+0x14c>
			{
				switch_flag=1;
    8fd0:	81 e0       	ldi	r24, 0x01	; 1
    8fd2:	8d 83       	std	Y+5, r24	; 0x05
				if(operations_arr[i]=='*')
    8fd4:	8c 81       	ldd	r24, Y+4	; 0x04
    8fd6:	88 2f       	mov	r24, r24
    8fd8:	90 e0       	ldi	r25, 0x00	; 0
    8fda:	fc 01       	movw	r30, r24
    8fdc:	e9 5b       	subi	r30, 0xB9	; 185
    8fde:	f7 4f       	sbci	r31, 0xF7	; 247
    8fe0:	80 81       	ld	r24, Z
    8fe2:	8a 32       	cpi	r24, 0x2A	; 42
    8fe4:	d9 f5       	brne	.+118    	; 0x905c <Calculator_voidCalculate+0xba>
				{
					numbers_arr[i]=numbers_arr[i]*numbers_arr[i+1];
    8fe6:	8c 81       	ldd	r24, Y+4	; 0x04
    8fe8:	c8 2e       	mov	r12, r24
    8fea:	dd 24       	eor	r13, r13
    8fec:	8c 81       	ldd	r24, Y+4	; 0x04
    8fee:	88 2f       	mov	r24, r24
    8ff0:	90 e0       	ldi	r25, 0x00	; 0
    8ff2:	88 0f       	add	r24, r24
    8ff4:	99 1f       	adc	r25, r25
    8ff6:	88 0f       	add	r24, r24
    8ff8:	99 1f       	adc	r25, r25
    8ffa:	fc 01       	movw	r30, r24
    8ffc:	e1 54       	subi	r30, 0x41	; 65
    8ffe:	f8 4f       	sbci	r31, 0xF8	; 248
    9000:	e0 80       	ld	r14, Z
    9002:	f1 80       	ldd	r15, Z+1	; 0x01
    9004:	02 81       	ldd	r16, Z+2	; 0x02
    9006:	13 81       	ldd	r17, Z+3	; 0x03
    9008:	8c 81       	ldd	r24, Y+4	; 0x04
    900a:	88 2f       	mov	r24, r24
    900c:	90 e0       	ldi	r25, 0x00	; 0
    900e:	01 96       	adiw	r24, 0x01	; 1
    9010:	88 0f       	add	r24, r24
    9012:	99 1f       	adc	r25, r25
    9014:	88 0f       	add	r24, r24
    9016:	99 1f       	adc	r25, r25
    9018:	fc 01       	movw	r30, r24
    901a:	e1 54       	subi	r30, 0x41	; 65
    901c:	f8 4f       	sbci	r31, 0xF8	; 248
    901e:	20 81       	ld	r18, Z
    9020:	31 81       	ldd	r19, Z+1	; 0x01
    9022:	42 81       	ldd	r20, Z+2	; 0x02
    9024:	53 81       	ldd	r21, Z+3	; 0x03
    9026:	c8 01       	movw	r24, r16
    9028:	b7 01       	movw	r22, r14
    902a:	0e 94 cc 4c 	call	0x9998	; 0x9998 <__mulsi3>
    902e:	9b 01       	movw	r18, r22
    9030:	ac 01       	movw	r20, r24
    9032:	c6 01       	movw	r24, r12
    9034:	88 0f       	add	r24, r24
    9036:	99 1f       	adc	r25, r25
    9038:	88 0f       	add	r24, r24
    903a:	99 1f       	adc	r25, r25
    903c:	fc 01       	movw	r30, r24
    903e:	e1 54       	subi	r30, 0x41	; 65
    9040:	f8 4f       	sbci	r31, 0xF8	; 248
    9042:	20 83       	st	Z, r18
    9044:	31 83       	std	Z+1, r19	; 0x01
    9046:	42 83       	std	Z+2, r20	; 0x02
    9048:	53 83       	std	Z+3, r21	; 0x03
					index=i;
    904a:	8c 81       	ldd	r24, Y+4	; 0x04
    904c:	8e 83       	std	Y+6, r24	; 0x06
					operations_arr_count--;
    904e:	80 91 10 08 	lds	r24, 0x0810
    9052:	81 50       	subi	r24, 0x01	; 1
    9054:	80 93 10 08 	sts	0x0810, r24
					switch_flag=0;
    9058:	1d 82       	std	Y+5, r1	; 0x05
    905a:	e1 c0       	rjmp	.+450    	; 0x921e <Calculator_voidCalculate+0x27c>
					break;
				}
				else if(operations_arr[i]=='/')
    905c:	8c 81       	ldd	r24, Y+4	; 0x04
    905e:	88 2f       	mov	r24, r24
    9060:	90 e0       	ldi	r25, 0x00	; 0
    9062:	fc 01       	movw	r30, r24
    9064:	e9 5b       	subi	r30, 0xB9	; 185
    9066:	f7 4f       	sbci	r31, 0xF7	; 247
    9068:	80 81       	ld	r24, Z
    906a:	8f 32       	cpi	r24, 0x2F	; 47
    906c:	e9 f5       	brne	.+122    	; 0x90e8 <Calculator_voidCalculate+0x146>
				{
					numbers_arr[i]=numbers_arr[i]/numbers_arr[i+1];
    906e:	8c 81       	ldd	r24, Y+4	; 0x04
    9070:	c8 2e       	mov	r12, r24
    9072:	dd 24       	eor	r13, r13
    9074:	8c 81       	ldd	r24, Y+4	; 0x04
    9076:	88 2f       	mov	r24, r24
    9078:	90 e0       	ldi	r25, 0x00	; 0
    907a:	88 0f       	add	r24, r24
    907c:	99 1f       	adc	r25, r25
    907e:	88 0f       	add	r24, r24
    9080:	99 1f       	adc	r25, r25
    9082:	fc 01       	movw	r30, r24
    9084:	e1 54       	subi	r30, 0x41	; 65
    9086:	f8 4f       	sbci	r31, 0xF8	; 248
    9088:	e0 80       	ld	r14, Z
    908a:	f1 80       	ldd	r15, Z+1	; 0x01
    908c:	02 81       	ldd	r16, Z+2	; 0x02
    908e:	13 81       	ldd	r17, Z+3	; 0x03
    9090:	8c 81       	ldd	r24, Y+4	; 0x04
    9092:	88 2f       	mov	r24, r24
    9094:	90 e0       	ldi	r25, 0x00	; 0
    9096:	01 96       	adiw	r24, 0x01	; 1
    9098:	88 0f       	add	r24, r24
    909a:	99 1f       	adc	r25, r25
    909c:	88 0f       	add	r24, r24
    909e:	99 1f       	adc	r25, r25
    90a0:	fc 01       	movw	r30, r24
    90a2:	e1 54       	subi	r30, 0x41	; 65
    90a4:	f8 4f       	sbci	r31, 0xF8	; 248
    90a6:	20 81       	ld	r18, Z
    90a8:	31 81       	ldd	r19, Z+1	; 0x01
    90aa:	42 81       	ldd	r20, Z+2	; 0x02
    90ac:	53 81       	ldd	r21, Z+3	; 0x03
    90ae:	c8 01       	movw	r24, r16
    90b0:	b7 01       	movw	r22, r14
    90b2:	0e 94 34 4d 	call	0x9a68	; 0x9a68 <__divmodsi4>
    90b6:	da 01       	movw	r26, r20
    90b8:	c9 01       	movw	r24, r18
    90ba:	9c 01       	movw	r18, r24
    90bc:	ad 01       	movw	r20, r26
    90be:	c6 01       	movw	r24, r12
    90c0:	88 0f       	add	r24, r24
    90c2:	99 1f       	adc	r25, r25
    90c4:	88 0f       	add	r24, r24
    90c6:	99 1f       	adc	r25, r25
    90c8:	fc 01       	movw	r30, r24
    90ca:	e1 54       	subi	r30, 0x41	; 65
    90cc:	f8 4f       	sbci	r31, 0xF8	; 248
    90ce:	20 83       	st	Z, r18
    90d0:	31 83       	std	Z+1, r19	; 0x01
    90d2:	42 83       	std	Z+2, r20	; 0x02
    90d4:	53 83       	std	Z+3, r21	; 0x03
					index=i;
    90d6:	8c 81       	ldd	r24, Y+4	; 0x04
    90d8:	8e 83       	std	Y+6, r24	; 0x06
					operations_arr_count--;
    90da:	80 91 10 08 	lds	r24, 0x0810
    90de:	81 50       	subi	r24, 0x01	; 1
    90e0:	80 93 10 08 	sts	0x0810, r24
					switch_flag=0;
    90e4:	1d 82       	std	Y+5, r1	; 0x05
    90e6:	9b c0       	rjmp	.+310    	; 0x921e <Calculator_voidCalculate+0x27c>
	u8 switch_flag=0;
	while(operations_arr_count!=0)
	{
		if (switch_flag==0)
		{
			for (u8 i=0;i<operations_arr_count;i++)
    90e8:	8c 81       	ldd	r24, Y+4	; 0x04
    90ea:	8f 5f       	subi	r24, 0xFF	; 255
    90ec:	8c 83       	std	Y+4, r24	; 0x04
    90ee:	90 91 10 08 	lds	r25, 0x0810
    90f2:	8c 81       	ldd	r24, Y+4	; 0x04
    90f4:	89 17       	cp	r24, r25
    90f6:	08 f4       	brcc	.+2      	; 0x90fa <Calculator_voidCalculate+0x158>
    90f8:	6b cf       	rjmp	.-298    	; 0x8fd0 <Calculator_voidCalculate+0x2e>
    90fa:	91 c0       	rjmp	.+290    	; 0x921e <Calculator_voidCalculate+0x27c>
				}
			}
		}
		else
		{
			for (u8 i=0;i<operations_arr_count;i++)
    90fc:	1b 82       	std	Y+3, r1	; 0x03
    90fe:	89 c0       	rjmp	.+274    	; 0x9212 <Calculator_voidCalculate+0x270>
			{
				switch_flag=1;
    9100:	81 e0       	ldi	r24, 0x01	; 1
    9102:	8d 83       	std	Y+5, r24	; 0x05
				if(operations_arr[i]=='+')
    9104:	8b 81       	ldd	r24, Y+3	; 0x03
    9106:	88 2f       	mov	r24, r24
    9108:	90 e0       	ldi	r25, 0x00	; 0
    910a:	fc 01       	movw	r30, r24
    910c:	e9 5b       	subi	r30, 0xB9	; 185
    910e:	f7 4f       	sbci	r31, 0xF7	; 247
    9110:	80 81       	ld	r24, Z
    9112:	8b 32       	cpi	r24, 0x2B	; 43
    9114:	c9 f5       	brne	.+114    	; 0x9188 <Calculator_voidCalculate+0x1e6>
				{
					numbers_arr[i]=numbers_arr[i]+numbers_arr[i+1];
    9116:	8b 81       	ldd	r24, Y+3	; 0x03
    9118:	68 2f       	mov	r22, r24
    911a:	70 e0       	ldi	r23, 0x00	; 0
    911c:	8b 81       	ldd	r24, Y+3	; 0x03
    911e:	88 2f       	mov	r24, r24
    9120:	90 e0       	ldi	r25, 0x00	; 0
    9122:	88 0f       	add	r24, r24
    9124:	99 1f       	adc	r25, r25
    9126:	88 0f       	add	r24, r24
    9128:	99 1f       	adc	r25, r25
    912a:	fc 01       	movw	r30, r24
    912c:	e1 54       	subi	r30, 0x41	; 65
    912e:	f8 4f       	sbci	r31, 0xF8	; 248
    9130:	20 81       	ld	r18, Z
    9132:	31 81       	ldd	r19, Z+1	; 0x01
    9134:	42 81       	ldd	r20, Z+2	; 0x02
    9136:	53 81       	ldd	r21, Z+3	; 0x03
    9138:	8b 81       	ldd	r24, Y+3	; 0x03
    913a:	88 2f       	mov	r24, r24
    913c:	90 e0       	ldi	r25, 0x00	; 0
    913e:	01 96       	adiw	r24, 0x01	; 1
    9140:	88 0f       	add	r24, r24
    9142:	99 1f       	adc	r25, r25
    9144:	88 0f       	add	r24, r24
    9146:	99 1f       	adc	r25, r25
    9148:	fc 01       	movw	r30, r24
    914a:	e1 54       	subi	r30, 0x41	; 65
    914c:	f8 4f       	sbci	r31, 0xF8	; 248
    914e:	80 81       	ld	r24, Z
    9150:	91 81       	ldd	r25, Z+1	; 0x01
    9152:	a2 81       	ldd	r26, Z+2	; 0x02
    9154:	b3 81       	ldd	r27, Z+3	; 0x03
    9156:	28 0f       	add	r18, r24
    9158:	39 1f       	adc	r19, r25
    915a:	4a 1f       	adc	r20, r26
    915c:	5b 1f       	adc	r21, r27
    915e:	cb 01       	movw	r24, r22
    9160:	88 0f       	add	r24, r24
    9162:	99 1f       	adc	r25, r25
    9164:	88 0f       	add	r24, r24
    9166:	99 1f       	adc	r25, r25
    9168:	fc 01       	movw	r30, r24
    916a:	e1 54       	subi	r30, 0x41	; 65
    916c:	f8 4f       	sbci	r31, 0xF8	; 248
    916e:	20 83       	st	Z, r18
    9170:	31 83       	std	Z+1, r19	; 0x01
    9172:	42 83       	std	Z+2, r20	; 0x02
    9174:	53 83       	std	Z+3, r21	; 0x03
					index=i;
    9176:	8b 81       	ldd	r24, Y+3	; 0x03
    9178:	8e 83       	std	Y+6, r24	; 0x06
					operations_arr_count--;
    917a:	80 91 10 08 	lds	r24, 0x0810
    917e:	81 50       	subi	r24, 0x01	; 1
    9180:	80 93 10 08 	sts	0x0810, r24
					switch_flag=0;
    9184:	1d 82       	std	Y+5, r1	; 0x05
    9186:	4b c0       	rjmp	.+150    	; 0x921e <Calculator_voidCalculate+0x27c>
					break;
				}
				else if(operations_arr[i]=='-')
    9188:	8b 81       	ldd	r24, Y+3	; 0x03
    918a:	88 2f       	mov	r24, r24
    918c:	90 e0       	ldi	r25, 0x00	; 0
    918e:	fc 01       	movw	r30, r24
    9190:	e9 5b       	subi	r30, 0xB9	; 185
    9192:	f7 4f       	sbci	r31, 0xF7	; 247
    9194:	80 81       	ld	r24, Z
    9196:	8d 32       	cpi	r24, 0x2D	; 45
    9198:	c9 f5       	brne	.+114    	; 0x920c <Calculator_voidCalculate+0x26a>
				{
					numbers_arr[i]=numbers_arr[i]-numbers_arr[i+1];
    919a:	8b 81       	ldd	r24, Y+3	; 0x03
    919c:	68 2f       	mov	r22, r24
    919e:	70 e0       	ldi	r23, 0x00	; 0
    91a0:	8b 81       	ldd	r24, Y+3	; 0x03
    91a2:	88 2f       	mov	r24, r24
    91a4:	90 e0       	ldi	r25, 0x00	; 0
    91a6:	88 0f       	add	r24, r24
    91a8:	99 1f       	adc	r25, r25
    91aa:	88 0f       	add	r24, r24
    91ac:	99 1f       	adc	r25, r25
    91ae:	fc 01       	movw	r30, r24
    91b0:	e1 54       	subi	r30, 0x41	; 65
    91b2:	f8 4f       	sbci	r31, 0xF8	; 248
    91b4:	20 81       	ld	r18, Z
    91b6:	31 81       	ldd	r19, Z+1	; 0x01
    91b8:	42 81       	ldd	r20, Z+2	; 0x02
    91ba:	53 81       	ldd	r21, Z+3	; 0x03
    91bc:	8b 81       	ldd	r24, Y+3	; 0x03
    91be:	88 2f       	mov	r24, r24
    91c0:	90 e0       	ldi	r25, 0x00	; 0
    91c2:	01 96       	adiw	r24, 0x01	; 1
    91c4:	88 0f       	add	r24, r24
    91c6:	99 1f       	adc	r25, r25
    91c8:	88 0f       	add	r24, r24
    91ca:	99 1f       	adc	r25, r25
    91cc:	fc 01       	movw	r30, r24
    91ce:	e1 54       	subi	r30, 0x41	; 65
    91d0:	f8 4f       	sbci	r31, 0xF8	; 248
    91d2:	80 81       	ld	r24, Z
    91d4:	91 81       	ldd	r25, Z+1	; 0x01
    91d6:	a2 81       	ldd	r26, Z+2	; 0x02
    91d8:	b3 81       	ldd	r27, Z+3	; 0x03
    91da:	28 1b       	sub	r18, r24
    91dc:	39 0b       	sbc	r19, r25
    91de:	4a 0b       	sbc	r20, r26
    91e0:	5b 0b       	sbc	r21, r27
    91e2:	cb 01       	movw	r24, r22
    91e4:	88 0f       	add	r24, r24
    91e6:	99 1f       	adc	r25, r25
    91e8:	88 0f       	add	r24, r24
    91ea:	99 1f       	adc	r25, r25
    91ec:	fc 01       	movw	r30, r24
    91ee:	e1 54       	subi	r30, 0x41	; 65
    91f0:	f8 4f       	sbci	r31, 0xF8	; 248
    91f2:	20 83       	st	Z, r18
    91f4:	31 83       	std	Z+1, r19	; 0x01
    91f6:	42 83       	std	Z+2, r20	; 0x02
    91f8:	53 83       	std	Z+3, r21	; 0x03
					index=i;
    91fa:	8b 81       	ldd	r24, Y+3	; 0x03
    91fc:	8e 83       	std	Y+6, r24	; 0x06
					operations_arr_count--;
    91fe:	80 91 10 08 	lds	r24, 0x0810
    9202:	81 50       	subi	r24, 0x01	; 1
    9204:	80 93 10 08 	sts	0x0810, r24
					switch_flag=0;
    9208:	1d 82       	std	Y+5, r1	; 0x05
    920a:	09 c0       	rjmp	.+18     	; 0x921e <Calculator_voidCalculate+0x27c>
				}
			}
		}
		else
		{
			for (u8 i=0;i<operations_arr_count;i++)
    920c:	8b 81       	ldd	r24, Y+3	; 0x03
    920e:	8f 5f       	subi	r24, 0xFF	; 255
    9210:	8b 83       	std	Y+3, r24	; 0x03
    9212:	90 91 10 08 	lds	r25, 0x0810
    9216:	8b 81       	ldd	r24, Y+3	; 0x03
    9218:	89 17       	cp	r24, r25
    921a:	08 f4       	brcc	.+2      	; 0x921e <Calculator_voidCalculate+0x27c>
    921c:	71 cf       	rjmp	.-286    	; 0x9100 <Calculator_voidCalculate+0x15e>
					break;
				}
			}
		}
		
		if(index!=-1)
    921e:	8e 81       	ldd	r24, Y+6	; 0x06
    9220:	8f 3f       	cpi	r24, 0xFF	; 255
    9222:	09 f4       	brne	.+2      	; 0x9226 <Calculator_voidCalculate+0x284>
    9224:	46 c0       	rjmp	.+140    	; 0x92b2 <Calculator_voidCalculate+0x310>
		{
			for (u8 i=index;i<operations_arr_count;i++)
    9226:	8e 81       	ldd	r24, Y+6	; 0x06
    9228:	8a 83       	std	Y+2, r24	; 0x02
    922a:	12 c0       	rjmp	.+36     	; 0x9250 <Calculator_voidCalculate+0x2ae>
			{
				operations_arr[i]=operations_arr[i+1];
    922c:	8a 81       	ldd	r24, Y+2	; 0x02
    922e:	28 2f       	mov	r18, r24
    9230:	30 e0       	ldi	r19, 0x00	; 0
    9232:	8a 81       	ldd	r24, Y+2	; 0x02
    9234:	88 2f       	mov	r24, r24
    9236:	90 e0       	ldi	r25, 0x00	; 0
    9238:	01 96       	adiw	r24, 0x01	; 1
    923a:	fc 01       	movw	r30, r24
    923c:	e9 5b       	subi	r30, 0xB9	; 185
    923e:	f7 4f       	sbci	r31, 0xF7	; 247
    9240:	80 81       	ld	r24, Z
    9242:	f9 01       	movw	r30, r18
    9244:	e9 5b       	subi	r30, 0xB9	; 185
    9246:	f7 4f       	sbci	r31, 0xF7	; 247
    9248:	80 83       	st	Z, r24
			}
		}
		
		if(index!=-1)
		{
			for (u8 i=index;i<operations_arr_count;i++)
    924a:	8a 81       	ldd	r24, Y+2	; 0x02
    924c:	8f 5f       	subi	r24, 0xFF	; 255
    924e:	8a 83       	std	Y+2, r24	; 0x02
    9250:	90 91 10 08 	lds	r25, 0x0810
    9254:	8a 81       	ldd	r24, Y+2	; 0x02
    9256:	89 17       	cp	r24, r25
    9258:	48 f3       	brcs	.-46     	; 0x922c <Calculator_voidCalculate+0x28a>
			{
				operations_arr[i]=operations_arr[i+1];
			}
			for(u8 i=index+1;i<=operations_arr_count;i++)
    925a:	8e 81       	ldd	r24, Y+6	; 0x06
    925c:	8f 5f       	subi	r24, 0xFF	; 255
    925e:	89 83       	std	Y+1, r24	; 0x01
    9260:	21 c0       	rjmp	.+66     	; 0x92a4 <Calculator_voidCalculate+0x302>
			{
				numbers_arr[i]=numbers_arr[i+1];
    9262:	89 81       	ldd	r24, Y+1	; 0x01
    9264:	68 2f       	mov	r22, r24
    9266:	70 e0       	ldi	r23, 0x00	; 0
    9268:	89 81       	ldd	r24, Y+1	; 0x01
    926a:	88 2f       	mov	r24, r24
    926c:	90 e0       	ldi	r25, 0x00	; 0
    926e:	01 96       	adiw	r24, 0x01	; 1
    9270:	88 0f       	add	r24, r24
    9272:	99 1f       	adc	r25, r25
    9274:	88 0f       	add	r24, r24
    9276:	99 1f       	adc	r25, r25
    9278:	fc 01       	movw	r30, r24
    927a:	e1 54       	subi	r30, 0x41	; 65
    927c:	f8 4f       	sbci	r31, 0xF8	; 248
    927e:	20 81       	ld	r18, Z
    9280:	31 81       	ldd	r19, Z+1	; 0x01
    9282:	42 81       	ldd	r20, Z+2	; 0x02
    9284:	53 81       	ldd	r21, Z+3	; 0x03
    9286:	cb 01       	movw	r24, r22
    9288:	88 0f       	add	r24, r24
    928a:	99 1f       	adc	r25, r25
    928c:	88 0f       	add	r24, r24
    928e:	99 1f       	adc	r25, r25
    9290:	fc 01       	movw	r30, r24
    9292:	e1 54       	subi	r30, 0x41	; 65
    9294:	f8 4f       	sbci	r31, 0xF8	; 248
    9296:	20 83       	st	Z, r18
    9298:	31 83       	std	Z+1, r19	; 0x01
    929a:	42 83       	std	Z+2, r20	; 0x02
    929c:	53 83       	std	Z+3, r21	; 0x03
		{
			for (u8 i=index;i<operations_arr_count;i++)
			{
				operations_arr[i]=operations_arr[i+1];
			}
			for(u8 i=index+1;i<=operations_arr_count;i++)
    929e:	89 81       	ldd	r24, Y+1	; 0x01
    92a0:	8f 5f       	subi	r24, 0xFF	; 255
    92a2:	89 83       	std	Y+1, r24	; 0x01
    92a4:	90 91 10 08 	lds	r25, 0x0810
    92a8:	89 81       	ldd	r24, Y+1	; 0x01
    92aa:	98 17       	cp	r25, r24
    92ac:	d0 f6       	brcc	.-76     	; 0x9262 <Calculator_voidCalculate+0x2c0>
			{
				numbers_arr[i]=numbers_arr[i+1];
			}
			index=-1;
    92ae:	8f ef       	ldi	r24, 0xFF	; 255
    92b0:	8e 83       	std	Y+6, r24	; 0x06

void Calculator_voidCalculate(void)
{
	s8 index=-1;
	u8 switch_flag=0;
	while(operations_arr_count!=0)
    92b2:	80 91 10 08 	lds	r24, 0x0810
    92b6:	88 23       	and	r24, r24
    92b8:	09 f0       	breq	.+2      	; 0x92bc <Calculator_voidCalculate+0x31a>
    92ba:	84 ce       	rjmp	.-760    	; 0x8fc4 <Calculator_voidCalculate+0x22>
				numbers_arr[i]=numbers_arr[i+1];
			}
			index=-1;
		}
	}
	result=numbers_arr[0];
    92bc:	80 91 bf 07 	lds	r24, 0x07BF
    92c0:	90 91 c0 07 	lds	r25, 0x07C0
    92c4:	a0 91 c1 07 	lds	r26, 0x07C1
    92c8:	b0 91 c2 07 	lds	r27, 0x07C2
    92cc:	80 93 11 08 	sts	0x0811, r24
    92d0:	90 93 12 08 	sts	0x0812, r25
    92d4:	a0 93 13 08 	sts	0x0813, r26
    92d8:	b0 93 14 08 	sts	0x0814, r27
	
}
    92dc:	26 96       	adiw	r28, 0x06	; 6
    92de:	0f b6       	in	r0, 0x3f	; 63
    92e0:	f8 94       	cli
    92e2:	de bf       	out	0x3e, r29	; 62
    92e4:	0f be       	out	0x3f, r0	; 63
    92e6:	cd bf       	out	0x3d, r28	; 61
    92e8:	cf 91       	pop	r28
    92ea:	df 91       	pop	r29
    92ec:	1f 91       	pop	r17
    92ee:	0f 91       	pop	r16
    92f0:	ff 90       	pop	r15
    92f2:	ef 90       	pop	r14
    92f4:	df 90       	pop	r13
    92f6:	cf 90       	pop	r12
    92f8:	08 95       	ret

000092fa <Calculator_voidRunable>:
void Calculator_voidRunable(void)
{
    92fa:	df 93       	push	r29
    92fc:	cf 93       	push	r28
    92fe:	cd b7       	in	r28, 0x3d	; 61
    9300:	de b7       	in	r29, 0x3e	; 62
	Calculator_voidGetString();
    9302:	0e 94 b8 44 	call	0x8970	; 0x8970 <Calculator_voidGetString>
	GoToXY(0,0);
    9306:	80 e0       	ldi	r24, 0x00	; 0
    9308:	60 e0       	ldi	r22, 0x00	; 0
    930a:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
	LCD_SendString(str);
    930e:	8e e1       	ldi	r24, 0x1E	; 30
    9310:	98 e0       	ldi	r25, 0x08	; 8
    9312:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
	LCD_SendString(" ");
    9316:	8b e1       	ldi	r24, 0x1B	; 27
    9318:	91 e0       	ldi	r25, 0x01	; 1
    931a:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
	if (eq_flag==1)
    931e:	80 91 be 07 	lds	r24, 0x07BE
    9322:	81 30       	cpi	r24, 0x01	; 1
    9324:	e1 f4       	brne	.+56     	; 0x935e <Calculator_voidRunable+0x64>
	{
		Calculator_voidAnalysisString();
    9326:	0e 94 72 46 	call	0x8ce4	; 0x8ce4 <Calculator_voidAnalysisString>
		Calculator_voidCalculate();
    932a:	0e 94 d1 47 	call	0x8fa2	; 0x8fa2 <Calculator_voidCalculate>
		GoToXY(0,0);
    932e:	80 e0       	ldi	r24, 0x00	; 0
    9330:	60 e0       	ldi	r22, 0x00	; 0
    9332:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
		LCD_sendChar('=');
    9336:	8d e3       	ldi	r24, 0x3D	; 61
    9338:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
		LCD_voidWriteNumber(result);
    933c:	80 91 11 08 	lds	r24, 0x0811
    9340:	90 91 12 08 	lds	r25, 0x0812
    9344:	a0 91 13 08 	lds	r26, 0x0813
    9348:	b0 91 14 08 	lds	r27, 0x0814
    934c:	bc 01       	movw	r22, r24
    934e:	cd 01       	movw	r24, r26
    9350:	0e 94 84 13 	call	0x2708	; 0x2708 <LCD_voidWriteNumber>
		clear_flag=1;
    9354:	81 e0       	ldi	r24, 0x01	; 1
    9356:	80 93 46 08 	sts	0x0846, r24
		eq_flag=0;
    935a:	10 92 be 07 	sts	0x07BE, r1
	}
	
}
    935e:	cf 91       	pop	r28
    9360:	df 91       	pop	r29
    9362:	08 95       	ret

00009364 <GetPass>:
u8 KeyPressed=0;
u8 x;
u8 Password;


void GetPass(){
    9364:	df 93       	push	r29
    9366:	cf 93       	push	r28
    9368:	0f 92       	push	r0
    936a:	cd b7       	in	r28, 0x3d	; 61
    936c:	de b7       	in	r29, 0x3e	; 62

	u8 flag=0;
    936e:	19 82       	std	Y+1, r1	; 0x01
	while(1){
		if(flag==0){
    9370:	89 81       	ldd	r24, Y+1	; 0x01
    9372:	88 23       	and	r24, r24
    9374:	31 f4       	brne	.+12     	; 0x9382 <GetPass+0x1e>
			LCD_SendString("Enter Pass:");
    9376:	8d e1       	ldi	r24, 0x1D	; 29
    9378:	91 e0       	ldi	r25, 0x01	; 1
    937a:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
			flag=1;
    937e:	81 e0       	ldi	r24, 0x01	; 1
    9380:	89 83       	std	Y+1, r24	; 0x01
		}
		KeyPressed=KPD_u8GetPressedKey();
    9382:	0e 94 84 0c 	call	0x1908	; 0x1908 <KPD_u8GetPressedKey>
    9386:	80 93 1d 08 	sts	0x081D, r24
		if(KeyPressed != 0){
    938a:	80 91 1d 08 	lds	r24, 0x081D
    938e:	88 23       	and	r24, r24
    9390:	41 f1       	breq	.+80     	; 0x93e2 <GetPass+0x7e>
			GoToXY(x,1);
    9392:	80 91 5d 08 	lds	r24, 0x085D
    9396:	61 e0       	ldi	r22, 0x01	; 1
    9398:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
			LCD_sendChar(KeyPressed);
    939c:	80 91 1d 08 	lds	r24, 0x081D
    93a0:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
			xQueueSendToBack(xQueue, &KeyPressed, 10);
    93a4:	80 91 5e 08 	lds	r24, 0x085E
    93a8:	90 91 5f 08 	lds	r25, 0x085F
    93ac:	2d e1       	ldi	r18, 0x1D	; 29
    93ae:	38 e0       	ldi	r19, 0x08	; 8
    93b0:	b9 01       	movw	r22, r18
    93b2:	4a e0       	ldi	r20, 0x0A	; 10
    93b4:	50 e0       	ldi	r21, 0x00	; 0
    93b6:	20 e0       	ldi	r18, 0x00	; 0
    93b8:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <xQueueGenericSend>
			x++;
    93bc:	80 91 5d 08 	lds	r24, 0x085D
    93c0:	8f 5f       	subi	r24, 0xFF	; 255
    93c2:	80 93 5d 08 	sts	0x085D, r24
			if(x==4){
    93c6:	80 91 5d 08 	lds	r24, 0x085D
    93ca:	84 30       	cpi	r24, 0x04	; 4
    93cc:	51 f4       	brne	.+20     	; 0x93e2 <GetPass+0x7e>
				xEventGroupSetBits(xEventGroup,( 1 << 0 ));
    93ce:	80 91 5b 08 	lds	r24, 0x085B
    93d2:	90 91 5c 08 	lds	r25, 0x085C
    93d6:	61 e0       	ldi	r22, 0x01	; 1
    93d8:	70 e0       	ldi	r23, 0x00	; 0
    93da:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xEventGroupSetBits>
				x=0;
    93de:	10 92 5d 08 	sts	0x085D, r1
			}
		}


	    vTaskDelay(50);
    93e2:	82 e3       	ldi	r24, 0x32	; 50
    93e4:	90 e0       	ldi	r25, 0x00	; 0
    93e6:	0e 94 18 2f 	call	0x5e30	; 0x5e30 <vTaskDelay>
    93ea:	c2 cf       	rjmp	.-124    	; 0x9370 <GetPass+0xc>

000093ec <VerifyPass>:

	}

}

void VerifyPass(){
    93ec:	0f 93       	push	r16
    93ee:	1f 93       	push	r17
    93f0:	df 93       	push	r29
    93f2:	cf 93       	push	r28
    93f4:	cd b7       	in	r28, 0x3d	; 61
    93f6:	de b7       	in	r29, 0x3e	; 62
    93f8:	27 97       	sbiw	r28, 0x07	; 7
    93fa:	0f b6       	in	r0, 0x3f	; 63
    93fc:	f8 94       	cli
    93fe:	de bf       	out	0x3e, r29	; 62
    9400:	0f be       	out	0x3f, r0	; 63
    9402:	cd bf       	out	0x3d, r28	; 61


	while(1){

		u8 xstatus;
		u8 pass[4]={'5','6','7','8'};
    9404:	85 e3       	ldi	r24, 0x35	; 53
    9406:	8c 83       	std	Y+4, r24	; 0x04
    9408:	86 e3       	ldi	r24, 0x36	; 54
    940a:	8d 83       	std	Y+5, r24	; 0x05
    940c:	87 e3       	ldi	r24, 0x37	; 55
    940e:	8e 83       	std	Y+6, r24	; 0x06
    9410:	88 e3       	ldi	r24, 0x38	; 56
    9412:	8f 83       	std	Y+7, r24	; 0x07
		u8 flag=0;
    9414:	1a 82       	std	Y+2, r1	; 0x02

		xstatus = xEventGroupWaitBits(xEventGroup, (1 << 0), pdTRUE,pdTRUE,10);
    9416:	80 91 5b 08 	lds	r24, 0x085B
    941a:	90 91 5c 08 	lds	r25, 0x085C
    941e:	61 e0       	ldi	r22, 0x01	; 1
    9420:	70 e0       	ldi	r23, 0x00	; 0
    9422:	41 e0       	ldi	r20, 0x01	; 1
    9424:	21 e0       	ldi	r18, 0x01	; 1
    9426:	0a e0       	ldi	r16, 0x0A	; 10
    9428:	10 e0       	ldi	r17, 0x00	; 0
    942a:	0e 94 ed 14 	call	0x29da	; 0x29da <xEventGroupWaitBits>
    942e:	8b 83       	std	Y+3, r24	; 0x03
		if (xstatus==1){
    9430:	8b 81       	ldd	r24, Y+3	; 0x03
    9432:	81 30       	cpi	r24, 0x01	; 1
    9434:	09 f0       	breq	.+2      	; 0x9438 <VerifyPass+0x4c>
    9436:	69 c0       	rjmp	.+210    	; 0x950a <VerifyPass+0x11e>

			if (xSemaphoreTake(LCDsem, 10) == pdTRUE) {
    9438:	80 91 63 08 	lds	r24, 0x0863
    943c:	90 91 64 08 	lds	r25, 0x0864
    9440:	6a e0       	ldi	r22, 0x0A	; 10
    9442:	70 e0       	ldi	r23, 0x00	; 0
    9444:	0e 94 bd 1f 	call	0x3f7a	; 0x3f7a <xQueueSemaphoreTake>
    9448:	81 30       	cpi	r24, 0x01	; 1
    944a:	09 f0       	breq	.+2      	; 0x944e <VerifyPass+0x62>
    944c:	5e c0       	rjmp	.+188    	; 0x950a <VerifyPass+0x11e>

				for(u8 i=0;i<4;i++){
    944e:	19 82       	std	Y+1, r1	; 0x01
    9450:	1e c0       	rjmp	.+60     	; 0x948e <VerifyPass+0xa2>
				xQueueReceive(xQueue, &Password, 10);
    9452:	80 91 5e 08 	lds	r24, 0x085E
    9456:	90 91 5f 08 	lds	r25, 0x085F
    945a:	22 e6       	ldi	r18, 0x62	; 98
    945c:	38 e0       	ldi	r19, 0x08	; 8
    945e:	b9 01       	movw	r22, r18
    9460:	4a e0       	ldi	r20, 0x0A	; 10
    9462:	50 e0       	ldi	r21, 0x00	; 0
    9464:	0e 94 12 1f 	call	0x3e24	; 0x3e24 <xQueueReceive>
					if(Password != pass[i]){
    9468:	89 81       	ldd	r24, Y+1	; 0x01
    946a:	28 2f       	mov	r18, r24
    946c:	30 e0       	ldi	r19, 0x00	; 0
    946e:	ce 01       	movw	r24, r28
    9470:	04 96       	adiw	r24, 0x04	; 4
    9472:	fc 01       	movw	r30, r24
    9474:	e2 0f       	add	r30, r18
    9476:	f3 1f       	adc	r31, r19
    9478:	90 81       	ld	r25, Z
    947a:	80 91 62 08 	lds	r24, 0x0862
    947e:	98 17       	cp	r25, r24
    9480:	19 f0       	breq	.+6      	; 0x9488 <VerifyPass+0x9c>
					flag=1;
    9482:	81 e0       	ldi	r24, 0x01	; 1
    9484:	8a 83       	std	Y+2, r24	; 0x02
    9486:	06 c0       	rjmp	.+12     	; 0x9494 <VerifyPass+0xa8>
		xstatus = xEventGroupWaitBits(xEventGroup, (1 << 0), pdTRUE,pdTRUE,10);
		if (xstatus==1){

			if (xSemaphoreTake(LCDsem, 10) == pdTRUE) {

				for(u8 i=0;i<4;i++){
    9488:	89 81       	ldd	r24, Y+1	; 0x01
    948a:	8f 5f       	subi	r24, 0xFF	; 255
    948c:	89 83       	std	Y+1, r24	; 0x01
    948e:	89 81       	ldd	r24, Y+1	; 0x01
    9490:	84 30       	cpi	r24, 0x04	; 4
    9492:	f8 f2       	brcs	.-66     	; 0x9452 <VerifyPass+0x66>
					if(Password != pass[i]){
					flag=1;
					break;
					}
				}
				if(flag==0){
    9494:	8a 81       	ldd	r24, Y+2	; 0x02
    9496:	88 23       	and	r24, r24
    9498:	69 f5       	brne	.+90     	; 0x94f4 <VerifyPass+0x108>
					GoToXY(0,1);
    949a:	80 e0       	ldi	r24, 0x00	; 0
    949c:	61 e0       	ldi	r22, 0x01	; 1
    949e:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
					LCD_SendString("Welcome Sir");
    94a2:	89 e2       	ldi	r24, 0x29	; 41
    94a4:	91 e0       	ldi	r25, 0x01	; 1
    94a6:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
					xEventGroupSetBits(xEventGroup,( 1 << 4 ));
    94aa:	80 91 5b 08 	lds	r24, 0x085B
    94ae:	90 91 5c 08 	lds	r25, 0x085C
    94b2:	60 e1       	ldi	r22, 0x10	; 16
    94b4:	70 e0       	ldi	r23, 0x00	; 0
    94b6:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <xEventGroupSetBits>
					xSemaphoreGive(LCDsem);
    94ba:	80 91 63 08 	lds	r24, 0x0863
    94be:	90 91 64 08 	lds	r25, 0x0864
    94c2:	60 e0       	ldi	r22, 0x00	; 0
    94c4:	70 e0       	ldi	r23, 0x00	; 0
    94c6:	40 e0       	ldi	r20, 0x00	; 0
    94c8:	50 e0       	ldi	r21, 0x00	; 0
    94ca:	20 e0       	ldi	r18, 0x00	; 0
    94cc:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <xQueueGenericSend>
					xQueueSend(T1_sus,0,10);
    94d0:	80 91 60 08 	lds	r24, 0x0860
    94d4:	90 91 61 08 	lds	r25, 0x0861
    94d8:	60 e0       	ldi	r22, 0x00	; 0
    94da:	70 e0       	ldi	r23, 0x00	; 0
    94dc:	4a e0       	ldi	r20, 0x0A	; 10
    94de:	50 e0       	ldi	r21, 0x00	; 0
    94e0:	20 e0       	ldi	r18, 0x00	; 0
    94e2:	0e 94 ab 1d 	call	0x3b56	; 0x3b56 <xQueueGenericSend>
				//	vTaskSuspend(NULL);
					vTaskSuspend(T1);
    94e6:	80 91 17 08 	lds	r24, 0x0817
    94ea:	90 91 18 08 	lds	r25, 0x0818
    94ee:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <vTaskSuspend>
    94f2:	0b c0       	rjmp	.+22     	; 0x950a <VerifyPass+0x11e>
					}
				else if(flag==1){
    94f4:	8a 81       	ldd	r24, Y+2	; 0x02
    94f6:	81 30       	cpi	r24, 0x01	; 1
    94f8:	41 f4       	brne	.+16     	; 0x950a <VerifyPass+0x11e>
					GoToXY(0,1);
    94fa:	80 e0       	ldi	r24, 0x00	; 0
    94fc:	61 e0       	ldi	r22, 0x01	; 1
    94fe:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
					LCD_SendString("haramyy!!");
    9502:	85 e3       	ldi	r24, 0x35	; 53
    9504:	91 e0       	ldi	r25, 0x01	; 1
    9506:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
					}
			}
		}
	 	vTaskDelay(300);
    950a:	8c e2       	ldi	r24, 0x2C	; 44
    950c:	91 e0       	ldi	r25, 0x01	; 1
    950e:	0e 94 18 2f 	call	0x5e30	; 0x5e30 <vTaskDelay>
    9512:	78 cf       	rjmp	.-272    	; 0x9404 <VerifyPass+0x18>

00009514 <Calculate>:
	}

}

void Calculate(){
    9514:	0f 93       	push	r16
    9516:	1f 93       	push	r17
    9518:	df 93       	push	r29
    951a:	cf 93       	push	r28
    951c:	cd b7       	in	r28, 0x3d	; 61
    951e:	de b7       	in	r29, 0x3e	; 62
    9520:	ce 56       	subi	r28, 0x6E	; 110
    9522:	d0 40       	sbci	r29, 0x00	; 0
    9524:	0f b6       	in	r0, 0x3f	; 63
    9526:	f8 94       	cli
    9528:	de bf       	out	0x3e, r29	; 62
    952a:	0f be       	out	0x3f, r0	; 63
    952c:	cd bf       	out	0x3d, r28	; 61


	while(1){
			bitsWaited = xEventGroupWaitBits(xEventGroup, bitsToWaitFor, pdTRUE, pdTRUE, 10);
    952e:	80 91 5b 08 	lds	r24, 0x085B
    9532:	90 91 5c 08 	lds	r25, 0x085C
    9536:	20 91 5f 01 	lds	r18, 0x015F
    953a:	30 91 60 01 	lds	r19, 0x0160
    953e:	b9 01       	movw	r22, r18
    9540:	41 e0       	ldi	r20, 0x01	; 1
    9542:	21 e0       	ldi	r18, 0x01	; 1
    9544:	0a e0       	ldi	r16, 0x0A	; 10
    9546:	10 e0       	ldi	r17, 0x00	; 0
    9548:	0e 94 ed 14 	call	0x29da	; 0x29da <xEventGroupWaitBits>
    954c:	90 93 66 08 	sts	0x0866, r25
    9550:	80 93 65 08 	sts	0x0865, r24
				if((bitsWaited & bitsToWaitFor) == bitsToWaitFor){
    9554:	20 91 65 08 	lds	r18, 0x0865
    9558:	30 91 66 08 	lds	r19, 0x0866
    955c:	80 91 5f 01 	lds	r24, 0x015F
    9560:	90 91 60 01 	lds	r25, 0x0160
    9564:	28 23       	and	r18, r24
    9566:	39 23       	and	r19, r25
    9568:	80 91 5f 01 	lds	r24, 0x015F
    956c:	90 91 60 01 	lds	r25, 0x0160
    9570:	28 17       	cp	r18, r24
    9572:	39 07       	cpc	r19, r25
    9574:	09 f0       	breq	.+2      	; 0x9578 <Calculate+0x64>
    9576:	b4 c1       	rjmp	.+872    	; 0x98e0 <Calculate+0x3cc>
				u8 T1_sus_val = 0;
    9578:	1a 86       	std	Y+10, r1	; 0x0a
				u8 KeyVal;
				u8 i = 0;
    957a:	18 86       	std	Y+8, r1	; 0x08
				u8 flag = 0;
    957c:	1f 82       	std	Y+7, r1	; 0x07
				u32 answer = 0;
    957e:	1b 82       	std	Y+3, r1	; 0x03
    9580:	1c 82       	std	Y+4, r1	; 0x04
    9582:	1d 82       	std	Y+5, r1	; 0x05
    9584:	1e 82       	std	Y+6, r1	; 0x06
				u8 num1[50],num2[50];

				start:
				LCD_SendCommand(0x01);
    9586:	81 e0       	ldi	r24, 0x01	; 1
    9588:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>
				GoToXY(0,0);
    958c:	80 e0       	ldi	r24, 0x00	; 0
    958e:	60 e0       	ldi	r22, 0x00	; 0
    9590:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
				LCD_SendString("Write Equation:");
    9594:	8f e3       	ldi	r24, 0x3F	; 63
    9596:	91 e0       	ldi	r25, 0x01	; 1
    9598:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
				GoToXY(0,1);
    959c:	80 e0       	ldi	r24, 0x00	; 0
    959e:	61 e0       	ldi	r22, 0x01	; 1
    95a0:	0e 94 5a 13 	call	0x26b4	; 0x26b4 <GoToXY>
				while(1){
					KeyVal= KPD_u8GetPressedKey();
    95a4:	0e 94 84 0c 	call	0x1908	; 0x1908 <KPD_u8GetPressedKey>
    95a8:	89 87       	std	Y+9, r24	; 0x09
					if(KeyVal != 0)
    95aa:	89 85       	ldd	r24, Y+9	; 0x09
    95ac:	88 23       	and	r24, r24
    95ae:	d1 f3       	breq	.-12     	; 0x95a4 <Calculate+0x90>
					{
						if( (KeyVal != '+') && (KeyVal != '-') && (KeyVal != 'x') && (KeyVal != '%') && (KeyVal != '#') )
    95b0:	89 85       	ldd	r24, Y+9	; 0x09
    95b2:	8b 32       	cpi	r24, 0x2B	; 43
    95b4:	e9 f0       	breq	.+58     	; 0x95f0 <Calculate+0xdc>
    95b6:	89 85       	ldd	r24, Y+9	; 0x09
    95b8:	8d 32       	cpi	r24, 0x2D	; 45
    95ba:	d1 f0       	breq	.+52     	; 0x95f0 <Calculate+0xdc>
    95bc:	89 85       	ldd	r24, Y+9	; 0x09
    95be:	88 37       	cpi	r24, 0x78	; 120
    95c0:	b9 f0       	breq	.+46     	; 0x95f0 <Calculate+0xdc>
    95c2:	89 85       	ldd	r24, Y+9	; 0x09
    95c4:	85 32       	cpi	r24, 0x25	; 37
    95c6:	a1 f0       	breq	.+40     	; 0x95f0 <Calculate+0xdc>
    95c8:	89 85       	ldd	r24, Y+9	; 0x09
    95ca:	83 32       	cpi	r24, 0x23	; 35
    95cc:	89 f0       	breq	.+34     	; 0x95f0 <Calculate+0xdc>
						{
							LCD_sendChar(KeyVal);
    95ce:	89 85       	ldd	r24, Y+9	; 0x09
    95d0:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
							num1[i] = KeyVal;
    95d4:	88 85       	ldd	r24, Y+8	; 0x08
    95d6:	28 2f       	mov	r18, r24
    95d8:	30 e0       	ldi	r19, 0x00	; 0
    95da:	ce 01       	movw	r24, r28
    95dc:	0b 96       	adiw	r24, 0x0b	; 11
    95de:	fc 01       	movw	r30, r24
    95e0:	e2 0f       	add	r30, r18
    95e2:	f3 1f       	adc	r31, r19
    95e4:	89 85       	ldd	r24, Y+9	; 0x09
    95e6:	80 83       	st	Z, r24
							i++;
    95e8:	88 85       	ldd	r24, Y+8	; 0x08
    95ea:	8f 5f       	subi	r24, 0xFF	; 255
    95ec:	88 87       	std	Y+8, r24	; 0x08
    95ee:	4e c0       	rjmp	.+156    	; 0x968c <Calculate+0x178>
						}else if(KeyVal == '+')
    95f0:	89 85       	ldd	r24, Y+9	; 0x09
    95f2:	8b 32       	cpi	r24, 0x2B	; 43
    95f4:	09 f0       	breq	.+2      	; 0x95f8 <Calculate+0xe4>
    95f6:	4a c0       	rjmp	.+148    	; 0x968c <Calculate+0x178>
						{
							LCD_sendChar(KeyVal);
    95f8:	89 85       	ldd	r24, Y+9	; 0x09
    95fa:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
							i=0;
    95fe:	18 86       	std	Y+8, r1	; 0x08
							flag = 1;
    9600:	81 e0       	ldi	r24, 0x01	; 1
    9602:	8f 83       	std	Y+7, r24	; 0x07
    9604:	3f c0       	rjmp	.+126    	; 0x9684 <Calculate+0x170>
							while(flag == 1)
							{
								KeyVal= KPD_u8GetPressedKey();
    9606:	0e 94 84 0c 	call	0x1908	; 0x1908 <KPD_u8GetPressedKey>
    960a:	89 87       	std	Y+9, r24	; 0x09
								if(KeyVal != 0)
    960c:	89 85       	ldd	r24, Y+9	; 0x09
    960e:	88 23       	and	r24, r24
    9610:	c9 f1       	breq	.+114    	; 0x9684 <Calculate+0x170>
								{
									if(KeyVal != '=')
    9612:	89 85       	ldd	r24, Y+9	; 0x09
    9614:	8d 33       	cpi	r24, 0x3D	; 61
    9616:	89 f0       	breq	.+34     	; 0x963a <Calculate+0x126>
									{
										LCD_sendChar(KeyVal);
    9618:	89 85       	ldd	r24, Y+9	; 0x09
    961a:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
										num2[i] = KeyVal;
    961e:	88 85       	ldd	r24, Y+8	; 0x08
    9620:	28 2f       	mov	r18, r24
    9622:	30 e0       	ldi	r19, 0x00	; 0
    9624:	ce 01       	movw	r24, r28
    9626:	cd 96       	adiw	r24, 0x3d	; 61
    9628:	fc 01       	movw	r30, r24
    962a:	e2 0f       	add	r30, r18
    962c:	f3 1f       	adc	r31, r19
    962e:	89 85       	ldd	r24, Y+9	; 0x09
    9630:	80 83       	st	Z, r24
										i++;
    9632:	88 85       	ldd	r24, Y+8	; 0x08
    9634:	8f 5f       	subi	r24, 0xFF	; 255
    9636:	88 87       	std	Y+8, r24	; 0x08
    9638:	25 c0       	rjmp	.+74     	; 0x9684 <Calculate+0x170>
									}
									else if(KeyVal == '=')
    963a:	89 85       	ldd	r24, Y+9	; 0x09
    963c:	8d 33       	cpi	r24, 0x3D	; 61
    963e:	11 f5       	brne	.+68     	; 0x9684 <Calculate+0x170>
									{
										LCD_sendChar(KeyVal);
    9640:	89 85       	ldd	r24, Y+9	; 0x09
    9642:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>

										//GoToXY(1,0);
										answer = atoi(num1) + atoi(num2);
    9646:	ce 01       	movw	r24, r28
    9648:	0b 96       	adiw	r24, 0x0b	; 11
    964a:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <atoi>
    964e:	8c 01       	movw	r16, r24
    9650:	ce 01       	movw	r24, r28
    9652:	cd 96       	adiw	r24, 0x3d	; 61
    9654:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <atoi>
    9658:	80 0f       	add	r24, r16
    965a:	91 1f       	adc	r25, r17
    965c:	aa 27       	eor	r26, r26
    965e:	97 fd       	sbrc	r25, 7
    9660:	a0 95       	com	r26
    9662:	ba 2f       	mov	r27, r26
    9664:	8b 83       	std	Y+3, r24	; 0x03
    9666:	9c 83       	std	Y+4, r25	; 0x04
    9668:	ad 83       	std	Y+5, r26	; 0x05
    966a:	be 83       	std	Y+6, r27	; 0x06
										LCD_voidWriteNumber(answer);
    966c:	8b 81       	ldd	r24, Y+3	; 0x03
    966e:	9c 81       	ldd	r25, Y+4	; 0x04
    9670:	ad 81       	ldd	r26, Y+5	; 0x05
    9672:	be 81       	ldd	r27, Y+6	; 0x06
    9674:	bc 01       	movw	r22, r24
    9676:	cd 01       	movw	r24, r26
    9678:	0e 94 84 13 	call	0x2708	; 0x2708 <LCD_voidWriteNumber>
										LCD_SendString("      ");
    967c:	8f e4       	ldi	r24, 0x4F	; 79
    967e:	91 e0       	ldi	r25, 0x01	; 1
    9680:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
						}else if(KeyVal == '+')
						{
							LCD_sendChar(KeyVal);
							i=0;
							flag = 1;
							while(flag == 1)
    9684:	8f 81       	ldd	r24, Y+7	; 0x07
    9686:	81 30       	cpi	r24, 0x01	; 1
    9688:	09 f4       	brne	.+2      	; 0x968c <Calculate+0x178>
    968a:	bd cf       	rjmp	.-134    	; 0x9606 <Calculate+0xf2>
										LCD_SendString("      ");
									}
								}
							}
						}
							if(KeyVal == '#')
    968c:	89 85       	ldd	r24, Y+9	; 0x09
    968e:	83 32       	cpi	r24, 0x23	; 35
    9690:	69 f5       	brne	.+90     	; 0x96ec <Calculate+0x1d8>
							{
								LCD_SendCommand(0x01);
    9692:	81 e0       	ldi	r24, 0x01	; 1
    9694:	0e 94 45 10 	call	0x208a	; 0x208a <LCD_SendCommand>
								flag = 0;
    9698:	1f 82       	std	Y+7, r1	; 0x07
								answer = 0;
    969a:	1b 82       	std	Y+3, r1	; 0x03
    969c:	1c 82       	std	Y+4, r1	; 0x04
    969e:	1d 82       	std	Y+5, r1	; 0x05
    96a0:	1e 82       	std	Y+6, r1	; 0x06
								// Clear num1 array
									for (u8 j = 0; j < sizeof(num1); j++) {
    96a2:	1a 82       	std	Y+2, r1	; 0x02
    96a4:	0c c0       	rjmp	.+24     	; 0x96be <Calculate+0x1aa>
										num1[j] = 0;
    96a6:	8a 81       	ldd	r24, Y+2	; 0x02
    96a8:	28 2f       	mov	r18, r24
    96aa:	30 e0       	ldi	r19, 0x00	; 0
    96ac:	ce 01       	movw	r24, r28
    96ae:	0b 96       	adiw	r24, 0x0b	; 11
    96b0:	fc 01       	movw	r30, r24
    96b2:	e2 0f       	add	r30, r18
    96b4:	f3 1f       	adc	r31, r19
    96b6:	10 82       	st	Z, r1
							{
								LCD_SendCommand(0x01);
								flag = 0;
								answer = 0;
								// Clear num1 array
									for (u8 j = 0; j < sizeof(num1); j++) {
    96b8:	8a 81       	ldd	r24, Y+2	; 0x02
    96ba:	8f 5f       	subi	r24, 0xFF	; 255
    96bc:	8a 83       	std	Y+2, r24	; 0x02
    96be:	8a 81       	ldd	r24, Y+2	; 0x02
    96c0:	82 33       	cpi	r24, 0x32	; 50
    96c2:	88 f3       	brcs	.-30     	; 0x96a6 <Calculate+0x192>
										num1[j] = 0;
									}

									// Clear num2 array
									for (u8 j = 0; j < sizeof(num2); j++) {
    96c4:	19 82       	std	Y+1, r1	; 0x01
    96c6:	0c c0       	rjmp	.+24     	; 0x96e0 <Calculate+0x1cc>
										num2[j] = 0;
    96c8:	89 81       	ldd	r24, Y+1	; 0x01
    96ca:	28 2f       	mov	r18, r24
    96cc:	30 e0       	ldi	r19, 0x00	; 0
    96ce:	ce 01       	movw	r24, r28
    96d0:	cd 96       	adiw	r24, 0x3d	; 61
    96d2:	fc 01       	movw	r30, r24
    96d4:	e2 0f       	add	r30, r18
    96d6:	f3 1f       	adc	r31, r19
    96d8:	10 82       	st	Z, r1
									for (u8 j = 0; j < sizeof(num1); j++) {
										num1[j] = 0;
									}

									// Clear num2 array
									for (u8 j = 0; j < sizeof(num2); j++) {
    96da:	89 81       	ldd	r24, Y+1	; 0x01
    96dc:	8f 5f       	subi	r24, 0xFF	; 255
    96de:	89 83       	std	Y+1, r24	; 0x01
    96e0:	89 81       	ldd	r24, Y+1	; 0x01
    96e2:	82 33       	cpi	r24, 0x32	; 50
    96e4:	88 f3       	brcs	.-30     	; 0x96c8 <Calculate+0x1b4>
										num2[j] = 0;
									}
								KeyVal = 0;
    96e6:	19 86       	std	Y+9, r1	; 0x09
								i = 0;
    96e8:	18 86       	std	Y+8, r1	; 0x08
    96ea:	4d cf       	rjmp	.-358    	; 0x9586 <Calculate+0x72>
								goto start;

								}else if(KeyVal == '%')
    96ec:	89 85       	ldd	r24, Y+9	; 0x09
    96ee:	85 32       	cpi	r24, 0x25	; 37
    96f0:	09 f0       	breq	.+2      	; 0x96f4 <Calculate+0x1e0>
    96f2:	4f c0       	rjmp	.+158    	; 0x9792 <Calculate+0x27e>
										{
											LCD_sendChar(KeyVal);
    96f4:	89 85       	ldd	r24, Y+9	; 0x09
    96f6:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
											i=0;
    96fa:	18 86       	std	Y+8, r1	; 0x08
											flag = 1;
    96fc:	81 e0       	ldi	r24, 0x01	; 1
    96fe:	8f 83       	std	Y+7, r24	; 0x07
    9700:	43 c0       	rjmp	.+134    	; 0x9788 <Calculate+0x274>
											while(flag == 1)
											{
												KeyVal= KPD_u8GetPressedKey();
    9702:	0e 94 84 0c 	call	0x1908	; 0x1908 <KPD_u8GetPressedKey>
    9706:	89 87       	std	Y+9, r24	; 0x09
												if(KeyVal != 0)
    9708:	89 85       	ldd	r24, Y+9	; 0x09
    970a:	88 23       	and	r24, r24
    970c:	e9 f1       	breq	.+122    	; 0x9788 <Calculate+0x274>
												{
													if(KeyVal != '=')
    970e:	89 85       	ldd	r24, Y+9	; 0x09
    9710:	8d 33       	cpi	r24, 0x3D	; 61
    9712:	89 f0       	breq	.+34     	; 0x9736 <Calculate+0x222>
													{
														LCD_sendChar(KeyVal);
    9714:	89 85       	ldd	r24, Y+9	; 0x09
    9716:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
														num2[i] = KeyVal;
    971a:	88 85       	ldd	r24, Y+8	; 0x08
    971c:	28 2f       	mov	r18, r24
    971e:	30 e0       	ldi	r19, 0x00	; 0
    9720:	ce 01       	movw	r24, r28
    9722:	cd 96       	adiw	r24, 0x3d	; 61
    9724:	fc 01       	movw	r30, r24
    9726:	e2 0f       	add	r30, r18
    9728:	f3 1f       	adc	r31, r19
    972a:	89 85       	ldd	r24, Y+9	; 0x09
    972c:	80 83       	st	Z, r24
														i++;
    972e:	88 85       	ldd	r24, Y+8	; 0x08
    9730:	8f 5f       	subi	r24, 0xFF	; 255
    9732:	88 87       	std	Y+8, r24	; 0x08
    9734:	29 c0       	rjmp	.+82     	; 0x9788 <Calculate+0x274>
													}
													else if(KeyVal == '=')
    9736:	89 85       	ldd	r24, Y+9	; 0x09
    9738:	8d 33       	cpi	r24, 0x3D	; 61
    973a:	31 f5       	brne	.+76     	; 0x9788 <Calculate+0x274>
													{
														LCD_sendChar(KeyVal);
    973c:	89 85       	ldd	r24, Y+9	; 0x09
    973e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
														answer = atoi(num1) / atoi(num2);
    9742:	ce 01       	movw	r24, r28
    9744:	0b 96       	adiw	r24, 0x0b	; 11
    9746:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <atoi>
    974a:	8c 01       	movw	r16, r24
    974c:	ce 01       	movw	r24, r28
    974e:	cd 96       	adiw	r24, 0x3d	; 61
    9750:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <atoi>
    9754:	9c 01       	movw	r18, r24
    9756:	c8 01       	movw	r24, r16
    9758:	b9 01       	movw	r22, r18
    975a:	0e 94 ff 4c 	call	0x99fe	; 0x99fe <__divmodhi4>
    975e:	cb 01       	movw	r24, r22
    9760:	aa 27       	eor	r26, r26
    9762:	97 fd       	sbrc	r25, 7
    9764:	a0 95       	com	r26
    9766:	ba 2f       	mov	r27, r26
    9768:	8b 83       	std	Y+3, r24	; 0x03
    976a:	9c 83       	std	Y+4, r25	; 0x04
    976c:	ad 83       	std	Y+5, r26	; 0x05
    976e:	be 83       	std	Y+6, r27	; 0x06
														LCD_voidWriteNumber(answer);
    9770:	8b 81       	ldd	r24, Y+3	; 0x03
    9772:	9c 81       	ldd	r25, Y+4	; 0x04
    9774:	ad 81       	ldd	r26, Y+5	; 0x05
    9776:	be 81       	ldd	r27, Y+6	; 0x06
    9778:	bc 01       	movw	r22, r24
    977a:	cd 01       	movw	r24, r26
    977c:	0e 94 84 13 	call	0x2708	; 0x2708 <LCD_voidWriteNumber>
														LCD_SendString("      ");
    9780:	8f e4       	ldi	r24, 0x4F	; 79
    9782:	91 e0       	ldi	r25, 0x01	; 1
    9784:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
								}else if(KeyVal == '%')
										{
											LCD_sendChar(KeyVal);
											i=0;
											flag = 1;
											while(flag == 1)
    9788:	8f 81       	ldd	r24, Y+7	; 0x07
    978a:	81 30       	cpi	r24, 0x01	; 1
    978c:	09 f4       	brne	.+2      	; 0x9790 <Calculate+0x27c>
    978e:	b9 cf       	rjmp	.-142    	; 0x9702 <Calculate+0x1ee>
    9790:	09 cf       	rjmp	.-494    	; 0x95a4 <Calculate+0x90>
														LCD_voidWriteNumber(answer);
														LCD_SendString("      ");
													}
												}
											}
										}else if(KeyVal == '-')
    9792:	89 85       	ldd	r24, Y+9	; 0x09
    9794:	8d 32       	cpi	r24, 0x2D	; 45
    9796:	09 f0       	breq	.+2      	; 0x979a <Calculate+0x286>
    9798:	4d c0       	rjmp	.+154    	; 0x9834 <Calculate+0x320>
												{
													LCD_sendChar(KeyVal);
    979a:	89 85       	ldd	r24, Y+9	; 0x09
    979c:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
													i=0;
    97a0:	18 86       	std	Y+8, r1	; 0x08
													flag = 1;
    97a2:	81 e0       	ldi	r24, 0x01	; 1
    97a4:	8f 83       	std	Y+7, r24	; 0x07
    97a6:	41 c0       	rjmp	.+130    	; 0x982a <Calculate+0x316>
													while(flag == 1)
													{
														KeyVal= KPD_u8GetPressedKey();
    97a8:	0e 94 84 0c 	call	0x1908	; 0x1908 <KPD_u8GetPressedKey>
    97ac:	89 87       	std	Y+9, r24	; 0x09
														if(KeyVal != 0)
    97ae:	89 85       	ldd	r24, Y+9	; 0x09
    97b0:	88 23       	and	r24, r24
    97b2:	d9 f1       	breq	.+118    	; 0x982a <Calculate+0x316>
														{
															if(KeyVal != '=')
    97b4:	89 85       	ldd	r24, Y+9	; 0x09
    97b6:	8d 33       	cpi	r24, 0x3D	; 61
    97b8:	89 f0       	breq	.+34     	; 0x97dc <Calculate+0x2c8>
															{
																LCD_sendChar(KeyVal);
    97ba:	89 85       	ldd	r24, Y+9	; 0x09
    97bc:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
																num2[i] = KeyVal;
    97c0:	88 85       	ldd	r24, Y+8	; 0x08
    97c2:	28 2f       	mov	r18, r24
    97c4:	30 e0       	ldi	r19, 0x00	; 0
    97c6:	ce 01       	movw	r24, r28
    97c8:	cd 96       	adiw	r24, 0x3d	; 61
    97ca:	fc 01       	movw	r30, r24
    97cc:	e2 0f       	add	r30, r18
    97ce:	f3 1f       	adc	r31, r19
    97d0:	89 85       	ldd	r24, Y+9	; 0x09
    97d2:	80 83       	st	Z, r24
																i++;
    97d4:	88 85       	ldd	r24, Y+8	; 0x08
    97d6:	8f 5f       	subi	r24, 0xFF	; 255
    97d8:	88 87       	std	Y+8, r24	; 0x08
    97da:	27 c0       	rjmp	.+78     	; 0x982a <Calculate+0x316>
															}
															else if(KeyVal == '=')
    97dc:	89 85       	ldd	r24, Y+9	; 0x09
    97de:	8d 33       	cpi	r24, 0x3D	; 61
    97e0:	21 f5       	brne	.+72     	; 0x982a <Calculate+0x316>
															{
																LCD_sendChar(KeyVal);
    97e2:	89 85       	ldd	r24, Y+9	; 0x09
    97e4:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>

																//GoToXY(1,0);
																answer = atoi(num1) - atoi(num2);
    97e8:	ce 01       	movw	r24, r28
    97ea:	0b 96       	adiw	r24, 0x0b	; 11
    97ec:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <atoi>
    97f0:	8c 01       	movw	r16, r24
    97f2:	ce 01       	movw	r24, r28
    97f4:	cd 96       	adiw	r24, 0x3d	; 61
    97f6:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <atoi>
    97fa:	98 01       	movw	r18, r16
    97fc:	28 1b       	sub	r18, r24
    97fe:	39 0b       	sbc	r19, r25
    9800:	c9 01       	movw	r24, r18
    9802:	aa 27       	eor	r26, r26
    9804:	97 fd       	sbrc	r25, 7
    9806:	a0 95       	com	r26
    9808:	ba 2f       	mov	r27, r26
    980a:	8b 83       	std	Y+3, r24	; 0x03
    980c:	9c 83       	std	Y+4, r25	; 0x04
    980e:	ad 83       	std	Y+5, r26	; 0x05
    9810:	be 83       	std	Y+6, r27	; 0x06
																LCD_voidWriteNumber(answer);
    9812:	8b 81       	ldd	r24, Y+3	; 0x03
    9814:	9c 81       	ldd	r25, Y+4	; 0x04
    9816:	ad 81       	ldd	r26, Y+5	; 0x05
    9818:	be 81       	ldd	r27, Y+6	; 0x06
    981a:	bc 01       	movw	r22, r24
    981c:	cd 01       	movw	r24, r26
    981e:	0e 94 84 13 	call	0x2708	; 0x2708 <LCD_voidWriteNumber>
																LCD_SendString("      ");
    9822:	8f e4       	ldi	r24, 0x4F	; 79
    9824:	91 e0       	ldi	r25, 0x01	; 1
    9826:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
										}else if(KeyVal == '-')
												{
													LCD_sendChar(KeyVal);
													i=0;
													flag = 1;
													while(flag == 1)
    982a:	8f 81       	ldd	r24, Y+7	; 0x07
    982c:	81 30       	cpi	r24, 0x01	; 1
    982e:	09 f4       	brne	.+2      	; 0x9832 <Calculate+0x31e>
    9830:	bb cf       	rjmp	.-138    	; 0x97a8 <Calculate+0x294>
    9832:	b8 ce       	rjmp	.-656    	; 0x95a4 <Calculate+0x90>
														}
													}


												}
												else if(KeyVal == 'x')
    9834:	89 85       	ldd	r24, Y+9	; 0x09
    9836:	88 37       	cpi	r24, 0x78	; 120
    9838:	09 f0       	breq	.+2      	; 0x983c <Calculate+0x328>
    983a:	b4 ce       	rjmp	.-664    	; 0x95a4 <Calculate+0x90>
												{
													LCD_sendChar(KeyVal);
    983c:	89 85       	ldd	r24, Y+9	; 0x09
    983e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
													i=0;
    9842:	18 86       	std	Y+8, r1	; 0x08
													flag = 1;
    9844:	81 e0       	ldi	r24, 0x01	; 1
    9846:	8f 83       	std	Y+7, r24	; 0x07
    9848:	46 c0       	rjmp	.+140    	; 0x98d6 <Calculate+0x3c2>
													while(flag == 1)
													{
														KeyVal= KPD_u8GetPressedKey();
    984a:	0e 94 84 0c 	call	0x1908	; 0x1908 <KPD_u8GetPressedKey>
    984e:	89 87       	std	Y+9, r24	; 0x09
														if(KeyVal != 0)
    9850:	89 85       	ldd	r24, Y+9	; 0x09
    9852:	88 23       	and	r24, r24
    9854:	09 f4       	brne	.+2      	; 0x9858 <Calculate+0x344>
    9856:	3f c0       	rjmp	.+126    	; 0x98d6 <Calculate+0x3c2>
														{
															if(KeyVal != '=')
    9858:	89 85       	ldd	r24, Y+9	; 0x09
    985a:	8d 33       	cpi	r24, 0x3D	; 61
    985c:	89 f0       	breq	.+34     	; 0x9880 <Calculate+0x36c>
															{
																LCD_sendChar(KeyVal);
    985e:	89 85       	ldd	r24, Y+9	; 0x09
    9860:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
																num2[i] = KeyVal;
    9864:	88 85       	ldd	r24, Y+8	; 0x08
    9866:	28 2f       	mov	r18, r24
    9868:	30 e0       	ldi	r19, 0x00	; 0
    986a:	ce 01       	movw	r24, r28
    986c:	cd 96       	adiw	r24, 0x3d	; 61
    986e:	fc 01       	movw	r30, r24
    9870:	e2 0f       	add	r30, r18
    9872:	f3 1f       	adc	r31, r19
    9874:	89 85       	ldd	r24, Y+9	; 0x09
    9876:	80 83       	st	Z, r24
																i++;
    9878:	88 85       	ldd	r24, Y+8	; 0x08
    987a:	8f 5f       	subi	r24, 0xFF	; 255
    987c:	88 87       	std	Y+8, r24	; 0x08
    987e:	2b c0       	rjmp	.+86     	; 0x98d6 <Calculate+0x3c2>
															}
															else if(KeyVal == '=')
    9880:	89 85       	ldd	r24, Y+9	; 0x09
    9882:	8d 33       	cpi	r24, 0x3D	; 61
    9884:	41 f5       	brne	.+80     	; 0x98d6 <Calculate+0x3c2>
															{
																LCD_sendChar(KeyVal);
    9886:	89 85       	ldd	r24, Y+9	; 0x09
    9888:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <LCD_sendChar>
																answer = atoi(num1) * atoi(num2);
    988c:	ce 01       	movw	r24, r28
    988e:	0b 96       	adiw	r24, 0x0b	; 11
    9890:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <atoi>
    9894:	8c 01       	movw	r16, r24
    9896:	ce 01       	movw	r24, r28
    9898:	cd 96       	adiw	r24, 0x3d	; 61
    989a:	0e 94 86 4d 	call	0x9b0c	; 0x9b0c <atoi>
    989e:	9c 01       	movw	r18, r24
    98a0:	02 9f       	mul	r16, r18
    98a2:	c0 01       	movw	r24, r0
    98a4:	03 9f       	mul	r16, r19
    98a6:	90 0d       	add	r25, r0
    98a8:	12 9f       	mul	r17, r18
    98aa:	90 0d       	add	r25, r0
    98ac:	11 24       	eor	r1, r1
    98ae:	aa 27       	eor	r26, r26
    98b0:	97 fd       	sbrc	r25, 7
    98b2:	a0 95       	com	r26
    98b4:	ba 2f       	mov	r27, r26
    98b6:	8b 83       	std	Y+3, r24	; 0x03
    98b8:	9c 83       	std	Y+4, r25	; 0x04
    98ba:	ad 83       	std	Y+5, r26	; 0x05
    98bc:	be 83       	std	Y+6, r27	; 0x06
																LCD_voidWriteNumber(answer);
    98be:	8b 81       	ldd	r24, Y+3	; 0x03
    98c0:	9c 81       	ldd	r25, Y+4	; 0x04
    98c2:	ad 81       	ldd	r26, Y+5	; 0x05
    98c4:	be 81       	ldd	r27, Y+6	; 0x06
    98c6:	bc 01       	movw	r22, r24
    98c8:	cd 01       	movw	r24, r26
    98ca:	0e 94 84 13 	call	0x2708	; 0x2708 <LCD_voidWriteNumber>
																LCD_SendString("      ");
    98ce:	8f e4       	ldi	r24, 0x4F	; 79
    98d0:	91 e0       	ldi	r25, 0x01	; 1
    98d2:	0e 94 31 13 	call	0x2662	; 0x2662 <LCD_SendString>
												else if(KeyVal == 'x')
												{
													LCD_sendChar(KeyVal);
													i=0;
													flag = 1;
													while(flag == 1)
    98d6:	8f 81       	ldd	r24, Y+7	; 0x07
    98d8:	81 30       	cpi	r24, 0x01	; 1
    98da:	09 f4       	brne	.+2      	; 0x98de <Calculate+0x3ca>
    98dc:	b6 cf       	rjmp	.-148    	; 0x984a <Calculate+0x336>
    98de:	62 ce       	rjmp	.-828    	; 0x95a4 <Calculate+0x90>
													}
												  }
											}
										}
									}
				vTaskDelay(500);
    98e0:	84 ef       	ldi	r24, 0xF4	; 244
    98e2:	91 e0       	ldi	r25, 0x01	; 1
    98e4:	0e 94 18 2f 	call	0x5e30	; 0x5e30 <vTaskDelay>
    98e8:	22 ce       	rjmp	.-956    	; 0x952e <Calculate+0x1a>

000098ea <main>:





void main () {
    98ea:	ef 92       	push	r14
    98ec:	ff 92       	push	r15
    98ee:	0f 93       	push	r16
    98f0:	df 93       	push	r29
    98f2:	cf 93       	push	r28
    98f4:	cd b7       	in	r28, 0x3d	; 61
    98f6:	de b7       	in	r29, 0x3e	; 62


		 LCD_init();
    98f8:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <LCD_init>
		 KPD_vidINIT();
    98fc:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <KPD_vidINIT>

		 LCDsem = xSemaphoreCreateMutex();
    9900:	81 e0       	ldi	r24, 0x01	; 1
    9902:	0e 94 62 1d 	call	0x3ac4	; 0x3ac4 <xQueueCreateMutex>
    9906:	90 93 64 08 	sts	0x0864, r25
    990a:	80 93 63 08 	sts	0x0863, r24
		 xQueue = xQueueCreate(10, 4);
    990e:	8a e0       	ldi	r24, 0x0A	; 10
    9910:	64 e0       	ldi	r22, 0x04	; 4
    9912:	40 e0       	ldi	r20, 0x00	; 0
    9914:	0e 94 8f 1c 	call	0x391e	; 0x391e <xQueueGenericCreate>
    9918:	90 93 5f 08 	sts	0x085F, r25
    991c:	80 93 5e 08 	sts	0x085E, r24
		 xEventGroup = xEventGroupCreate();
    9920:	0e 94 15 14 	call	0x282a	; 0x282a <xEventGroupCreate>
    9924:	90 93 5c 08 	sts	0x085C, r25
    9928:	80 93 5b 08 	sts	0x085B, r24
		 T1_sus = xQueueCreate(1, sizeof(u16));
    992c:	81 e0       	ldi	r24, 0x01	; 1
    992e:	62 e0       	ldi	r22, 0x02	; 2
    9930:	40 e0       	ldi	r20, 0x00	; 0
    9932:	0e 94 8f 1c 	call	0x391e	; 0x391e <xQueueGenericCreate>
    9936:	90 93 61 08 	sts	0x0861, r25
    993a:	80 93 60 08 	sts	0x0860, r24

		 xTaskCreate(GetPass, NULL, 400, NULL, 1, &T1);
    993e:	82 eb       	ldi	r24, 0xB2	; 178
    9940:	99 e4       	ldi	r25, 0x49	; 73
    9942:	e7 e1       	ldi	r30, 0x17	; 23
    9944:	f8 e0       	ldi	r31, 0x08	; 8
    9946:	60 e0       	ldi	r22, 0x00	; 0
    9948:	70 e0       	ldi	r23, 0x00	; 0
    994a:	40 e9       	ldi	r20, 0x90	; 144
    994c:	51 e0       	ldi	r21, 0x01	; 1
    994e:	20 e0       	ldi	r18, 0x00	; 0
    9950:	30 e0       	ldi	r19, 0x00	; 0
    9952:	01 e0       	ldi	r16, 0x01	; 1
    9954:	7f 01       	movw	r14, r30
    9956:	0e 94 3a 2c 	call	0x5874	; 0x5874 <xTaskCreate>
		 xTaskCreate(VerifyPass, NULL, 200, NULL, 1, &T2);
    995a:	86 ef       	ldi	r24, 0xF6	; 246
    995c:	99 e4       	ldi	r25, 0x49	; 73
    995e:	e9 e1       	ldi	r30, 0x19	; 25
    9960:	f8 e0       	ldi	r31, 0x08	; 8
    9962:	60 e0       	ldi	r22, 0x00	; 0
    9964:	70 e0       	ldi	r23, 0x00	; 0
    9966:	48 ec       	ldi	r20, 0xC8	; 200
    9968:	50 e0       	ldi	r21, 0x00	; 0
    996a:	20 e0       	ldi	r18, 0x00	; 0
    996c:	30 e0       	ldi	r19, 0x00	; 0
    996e:	01 e0       	ldi	r16, 0x01	; 1
    9970:	7f 01       	movw	r14, r30
    9972:	0e 94 3a 2c 	call	0x5874	; 0x5874 <xTaskCreate>
		 xTaskCreate(Calculate, NULL, 400, NULL, 2, &T3);
    9976:	8a e8       	ldi	r24, 0x8A	; 138
    9978:	9a e4       	ldi	r25, 0x4A	; 74
    997a:	eb e1       	ldi	r30, 0x1B	; 27
    997c:	f8 e0       	ldi	r31, 0x08	; 8
    997e:	60 e0       	ldi	r22, 0x00	; 0
    9980:	70 e0       	ldi	r23, 0x00	; 0
    9982:	40 e9       	ldi	r20, 0x90	; 144
    9984:	51 e0       	ldi	r21, 0x01	; 1
    9986:	20 e0       	ldi	r18, 0x00	; 0
    9988:	30 e0       	ldi	r19, 0x00	; 0
    998a:	02 e0       	ldi	r16, 0x02	; 2
    998c:	7f 01       	movw	r14, r30
    998e:	0e 94 3a 2c 	call	0x5874	; 0x5874 <xTaskCreate>


		 vTaskStartScheduler();
    9992:	0e 94 53 31 	call	0x62a6	; 0x62a6 <vTaskStartScheduler>
    9996:	ff cf       	rjmp	.-2      	; 0x9996 <main+0xac>

00009998 <__mulsi3>:
    9998:	62 9f       	mul	r22, r18
    999a:	d0 01       	movw	r26, r0
    999c:	73 9f       	mul	r23, r19
    999e:	f0 01       	movw	r30, r0
    99a0:	82 9f       	mul	r24, r18
    99a2:	e0 0d       	add	r30, r0
    99a4:	f1 1d       	adc	r31, r1
    99a6:	64 9f       	mul	r22, r20
    99a8:	e0 0d       	add	r30, r0
    99aa:	f1 1d       	adc	r31, r1
    99ac:	92 9f       	mul	r25, r18
    99ae:	f0 0d       	add	r31, r0
    99b0:	83 9f       	mul	r24, r19
    99b2:	f0 0d       	add	r31, r0
    99b4:	74 9f       	mul	r23, r20
    99b6:	f0 0d       	add	r31, r0
    99b8:	65 9f       	mul	r22, r21
    99ba:	f0 0d       	add	r31, r0
    99bc:	99 27       	eor	r25, r25
    99be:	72 9f       	mul	r23, r18
    99c0:	b0 0d       	add	r27, r0
    99c2:	e1 1d       	adc	r30, r1
    99c4:	f9 1f       	adc	r31, r25
    99c6:	63 9f       	mul	r22, r19
    99c8:	b0 0d       	add	r27, r0
    99ca:	e1 1d       	adc	r30, r1
    99cc:	f9 1f       	adc	r31, r25
    99ce:	bd 01       	movw	r22, r26
    99d0:	cf 01       	movw	r24, r30
    99d2:	11 24       	eor	r1, r1
    99d4:	08 95       	ret

000099d6 <__udivmodhi4>:
    99d6:	aa 1b       	sub	r26, r26
    99d8:	bb 1b       	sub	r27, r27
    99da:	51 e1       	ldi	r21, 0x11	; 17
    99dc:	07 c0       	rjmp	.+14     	; 0x99ec <__udivmodhi4_ep>

000099de <__udivmodhi4_loop>:
    99de:	aa 1f       	adc	r26, r26
    99e0:	bb 1f       	adc	r27, r27
    99e2:	a6 17       	cp	r26, r22
    99e4:	b7 07       	cpc	r27, r23
    99e6:	10 f0       	brcs	.+4      	; 0x99ec <__udivmodhi4_ep>
    99e8:	a6 1b       	sub	r26, r22
    99ea:	b7 0b       	sbc	r27, r23

000099ec <__udivmodhi4_ep>:
    99ec:	88 1f       	adc	r24, r24
    99ee:	99 1f       	adc	r25, r25
    99f0:	5a 95       	dec	r21
    99f2:	a9 f7       	brne	.-22     	; 0x99de <__udivmodhi4_loop>
    99f4:	80 95       	com	r24
    99f6:	90 95       	com	r25
    99f8:	bc 01       	movw	r22, r24
    99fa:	cd 01       	movw	r24, r26
    99fc:	08 95       	ret

000099fe <__divmodhi4>:
    99fe:	97 fb       	bst	r25, 7
    9a00:	09 2e       	mov	r0, r25
    9a02:	07 26       	eor	r0, r23
    9a04:	0a d0       	rcall	.+20     	; 0x9a1a <__divmodhi4_neg1>
    9a06:	77 fd       	sbrc	r23, 7
    9a08:	04 d0       	rcall	.+8      	; 0x9a12 <__divmodhi4_neg2>
    9a0a:	e5 df       	rcall	.-54     	; 0x99d6 <__udivmodhi4>
    9a0c:	06 d0       	rcall	.+12     	; 0x9a1a <__divmodhi4_neg1>
    9a0e:	00 20       	and	r0, r0
    9a10:	1a f4       	brpl	.+6      	; 0x9a18 <__divmodhi4_exit>

00009a12 <__divmodhi4_neg2>:
    9a12:	70 95       	com	r23
    9a14:	61 95       	neg	r22
    9a16:	7f 4f       	sbci	r23, 0xFF	; 255

00009a18 <__divmodhi4_exit>:
    9a18:	08 95       	ret

00009a1a <__divmodhi4_neg1>:
    9a1a:	f6 f7       	brtc	.-4      	; 0x9a18 <__divmodhi4_exit>
    9a1c:	90 95       	com	r25
    9a1e:	81 95       	neg	r24
    9a20:	9f 4f       	sbci	r25, 0xFF	; 255
    9a22:	08 95       	ret

00009a24 <__udivmodsi4>:
    9a24:	a1 e2       	ldi	r26, 0x21	; 33
    9a26:	1a 2e       	mov	r1, r26
    9a28:	aa 1b       	sub	r26, r26
    9a2a:	bb 1b       	sub	r27, r27
    9a2c:	fd 01       	movw	r30, r26
    9a2e:	0d c0       	rjmp	.+26     	; 0x9a4a <__udivmodsi4_ep>

00009a30 <__udivmodsi4_loop>:
    9a30:	aa 1f       	adc	r26, r26
    9a32:	bb 1f       	adc	r27, r27
    9a34:	ee 1f       	adc	r30, r30
    9a36:	ff 1f       	adc	r31, r31
    9a38:	a2 17       	cp	r26, r18
    9a3a:	b3 07       	cpc	r27, r19
    9a3c:	e4 07       	cpc	r30, r20
    9a3e:	f5 07       	cpc	r31, r21
    9a40:	20 f0       	brcs	.+8      	; 0x9a4a <__udivmodsi4_ep>
    9a42:	a2 1b       	sub	r26, r18
    9a44:	b3 0b       	sbc	r27, r19
    9a46:	e4 0b       	sbc	r30, r20
    9a48:	f5 0b       	sbc	r31, r21

00009a4a <__udivmodsi4_ep>:
    9a4a:	66 1f       	adc	r22, r22
    9a4c:	77 1f       	adc	r23, r23
    9a4e:	88 1f       	adc	r24, r24
    9a50:	99 1f       	adc	r25, r25
    9a52:	1a 94       	dec	r1
    9a54:	69 f7       	brne	.-38     	; 0x9a30 <__udivmodsi4_loop>
    9a56:	60 95       	com	r22
    9a58:	70 95       	com	r23
    9a5a:	80 95       	com	r24
    9a5c:	90 95       	com	r25
    9a5e:	9b 01       	movw	r18, r22
    9a60:	ac 01       	movw	r20, r24
    9a62:	bd 01       	movw	r22, r26
    9a64:	cf 01       	movw	r24, r30
    9a66:	08 95       	ret

00009a68 <__divmodsi4>:
    9a68:	97 fb       	bst	r25, 7
    9a6a:	09 2e       	mov	r0, r25
    9a6c:	05 26       	eor	r0, r21
    9a6e:	0e d0       	rcall	.+28     	; 0x9a8c <__divmodsi4_neg1>
    9a70:	57 fd       	sbrc	r21, 7
    9a72:	04 d0       	rcall	.+8      	; 0x9a7c <__divmodsi4_neg2>
    9a74:	d7 df       	rcall	.-82     	; 0x9a24 <__udivmodsi4>
    9a76:	0a d0       	rcall	.+20     	; 0x9a8c <__divmodsi4_neg1>
    9a78:	00 1c       	adc	r0, r0
    9a7a:	38 f4       	brcc	.+14     	; 0x9a8a <__divmodsi4_exit>

00009a7c <__divmodsi4_neg2>:
    9a7c:	50 95       	com	r21
    9a7e:	40 95       	com	r20
    9a80:	30 95       	com	r19
    9a82:	21 95       	neg	r18
    9a84:	3f 4f       	sbci	r19, 0xFF	; 255
    9a86:	4f 4f       	sbci	r20, 0xFF	; 255
    9a88:	5f 4f       	sbci	r21, 0xFF	; 255

00009a8a <__divmodsi4_exit>:
    9a8a:	08 95       	ret

00009a8c <__divmodsi4_neg1>:
    9a8c:	f6 f7       	brtc	.-4      	; 0x9a8a <__divmodsi4_exit>
    9a8e:	90 95       	com	r25
    9a90:	80 95       	com	r24
    9a92:	70 95       	com	r23
    9a94:	61 95       	neg	r22
    9a96:	7f 4f       	sbci	r23, 0xFF	; 255
    9a98:	8f 4f       	sbci	r24, 0xFF	; 255
    9a9a:	9f 4f       	sbci	r25, 0xFF	; 255
    9a9c:	08 95       	ret

00009a9e <__prologue_saves__>:
    9a9e:	2f 92       	push	r2
    9aa0:	3f 92       	push	r3
    9aa2:	4f 92       	push	r4
    9aa4:	5f 92       	push	r5
    9aa6:	6f 92       	push	r6
    9aa8:	7f 92       	push	r7
    9aaa:	8f 92       	push	r8
    9aac:	9f 92       	push	r9
    9aae:	af 92       	push	r10
    9ab0:	bf 92       	push	r11
    9ab2:	cf 92       	push	r12
    9ab4:	df 92       	push	r13
    9ab6:	ef 92       	push	r14
    9ab8:	ff 92       	push	r15
    9aba:	0f 93       	push	r16
    9abc:	1f 93       	push	r17
    9abe:	cf 93       	push	r28
    9ac0:	df 93       	push	r29
    9ac2:	cd b7       	in	r28, 0x3d	; 61
    9ac4:	de b7       	in	r29, 0x3e	; 62
    9ac6:	ca 1b       	sub	r28, r26
    9ac8:	db 0b       	sbc	r29, r27
    9aca:	0f b6       	in	r0, 0x3f	; 63
    9acc:	f8 94       	cli
    9ace:	de bf       	out	0x3e, r29	; 62
    9ad0:	0f be       	out	0x3f, r0	; 63
    9ad2:	cd bf       	out	0x3d, r28	; 61
    9ad4:	09 94       	ijmp

00009ad6 <__epilogue_restores__>:
    9ad6:	2a 88       	ldd	r2, Y+18	; 0x12
    9ad8:	39 88       	ldd	r3, Y+17	; 0x11
    9ada:	48 88       	ldd	r4, Y+16	; 0x10
    9adc:	5f 84       	ldd	r5, Y+15	; 0x0f
    9ade:	6e 84       	ldd	r6, Y+14	; 0x0e
    9ae0:	7d 84       	ldd	r7, Y+13	; 0x0d
    9ae2:	8c 84       	ldd	r8, Y+12	; 0x0c
    9ae4:	9b 84       	ldd	r9, Y+11	; 0x0b
    9ae6:	aa 84       	ldd	r10, Y+10	; 0x0a
    9ae8:	b9 84       	ldd	r11, Y+9	; 0x09
    9aea:	c8 84       	ldd	r12, Y+8	; 0x08
    9aec:	df 80       	ldd	r13, Y+7	; 0x07
    9aee:	ee 80       	ldd	r14, Y+6	; 0x06
    9af0:	fd 80       	ldd	r15, Y+5	; 0x05
    9af2:	0c 81       	ldd	r16, Y+4	; 0x04
    9af4:	1b 81       	ldd	r17, Y+3	; 0x03
    9af6:	aa 81       	ldd	r26, Y+2	; 0x02
    9af8:	b9 81       	ldd	r27, Y+1	; 0x01
    9afa:	ce 0f       	add	r28, r30
    9afc:	d1 1d       	adc	r29, r1
    9afe:	0f b6       	in	r0, 0x3f	; 63
    9b00:	f8 94       	cli
    9b02:	de bf       	out	0x3e, r29	; 62
    9b04:	0f be       	out	0x3f, r0	; 63
    9b06:	cd bf       	out	0x3d, r28	; 61
    9b08:	ed 01       	movw	r28, r26
    9b0a:	08 95       	ret

00009b0c <atoi>:
    9b0c:	fc 01       	movw	r30, r24
    9b0e:	88 27       	eor	r24, r24
    9b10:	99 27       	eor	r25, r25
    9b12:	e8 94       	clt
    9b14:	21 91       	ld	r18, Z+
    9b16:	20 32       	cpi	r18, 0x20	; 32
    9b18:	e9 f3       	breq	.-6      	; 0x9b14 <atoi+0x8>
    9b1a:	29 30       	cpi	r18, 0x09	; 9
    9b1c:	10 f0       	brcs	.+4      	; 0x9b22 <atoi+0x16>
    9b1e:	2e 30       	cpi	r18, 0x0E	; 14
    9b20:	c8 f3       	brcs	.-14     	; 0x9b14 <atoi+0x8>
    9b22:	2b 32       	cpi	r18, 0x2B	; 43
    9b24:	41 f0       	breq	.+16     	; 0x9b36 <atoi+0x2a>
    9b26:	2d 32       	cpi	r18, 0x2D	; 45
    9b28:	39 f4       	brne	.+14     	; 0x9b38 <atoi+0x2c>
    9b2a:	68 94       	set
    9b2c:	04 c0       	rjmp	.+8      	; 0x9b36 <atoi+0x2a>
    9b2e:	0e 94 b4 4d 	call	0x9b68	; 0x9b68 <__mulhi_const_10>
    9b32:	82 0f       	add	r24, r18
    9b34:	91 1d       	adc	r25, r1
    9b36:	21 91       	ld	r18, Z+
    9b38:	20 53       	subi	r18, 0x30	; 48
    9b3a:	2a 30       	cpi	r18, 0x0A	; 10
    9b3c:	c0 f3       	brcs	.-16     	; 0x9b2e <atoi+0x22>
    9b3e:	1e f4       	brtc	.+6      	; 0x9b46 <atoi+0x3a>
    9b40:	90 95       	com	r25
    9b42:	81 95       	neg	r24
    9b44:	9f 4f       	sbci	r25, 0xFF	; 255
    9b46:	08 95       	ret

00009b48 <memcpy>:
    9b48:	fb 01       	movw	r30, r22
    9b4a:	dc 01       	movw	r26, r24
    9b4c:	02 c0       	rjmp	.+4      	; 0x9b52 <memcpy+0xa>
    9b4e:	01 90       	ld	r0, Z+
    9b50:	0d 92       	st	X+, r0
    9b52:	41 50       	subi	r20, 0x01	; 1
    9b54:	50 40       	sbci	r21, 0x00	; 0
    9b56:	d8 f7       	brcc	.-10     	; 0x9b4e <memcpy+0x6>
    9b58:	08 95       	ret

00009b5a <memset>:
    9b5a:	dc 01       	movw	r26, r24
    9b5c:	01 c0       	rjmp	.+2      	; 0x9b60 <memset+0x6>
    9b5e:	6d 93       	st	X+, r22
    9b60:	41 50       	subi	r20, 0x01	; 1
    9b62:	50 40       	sbci	r21, 0x00	; 0
    9b64:	e0 f7       	brcc	.-8      	; 0x9b5e <memset+0x4>
    9b66:	08 95       	ret

00009b68 <__mulhi_const_10>:
    9b68:	7a e0       	ldi	r23, 0x0A	; 10
    9b6a:	97 9f       	mul	r25, r23
    9b6c:	90 2d       	mov	r25, r0
    9b6e:	87 9f       	mul	r24, r23
    9b70:	80 2d       	mov	r24, r0
    9b72:	91 0d       	add	r25, r1
    9b74:	11 24       	eor	r1, r1
    9b76:	08 95       	ret

00009b78 <_exit>:
    9b78:	f8 94       	cli

00009b7a <__stop_program>:
    9b7a:	ff cf       	rjmp	.-2      	; 0x9b7a <__stop_program>
